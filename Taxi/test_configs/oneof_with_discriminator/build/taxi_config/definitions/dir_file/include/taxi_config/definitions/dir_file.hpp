/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s):
// taxi/schemas/schemas/configs/definitions/dir/file.yaml

#pragma once

#include <array>
#include <boost/type_traits/has_equal_to.hpp>
#include <codegen/convert_to_json_optional.hpp>
#include <codegen/format.hpp>
#include <codegen/non_null_ptr.hpp>
#include <codegen/parsing_flags.hpp>
#include <optional>
#include <string>
#include <userver/formats/json/inline.hpp>
#include <userver/formats/json/string_builder_fwd.hpp>
#include <userver/formats/json/value.hpp>
#include <userver/formats/json/value_builder.hpp>
#include <userver/logging/log_helper_fwd.hpp>

namespace taxi_config::dir_file {

struct Def2 {
  ::std::optional<::std::string> type{};
};

Def2 Parse(const formats::json::Value& elem, formats::parse::To<Def2>);

template <typename U>
std::enable_if_t<std::is_same<U, Def2>::value, bool> operator==(const U& lhs,
                                                                const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(boost::has_equal_to<decltype(lhs.type)>::value,
                "No operator==() defined for field 'type' of type "
                "'::std::optional<::std::string>'");

  return std::tie(lhs.type) == std::tie(rhs.type);
}

template <typename U>
std::enable_if_t<std::is_same<U, Def2>::value, bool> operator!=(const U& lhs,
                                                                const U& rhs)
{
  return !(lhs == rhs);
}

}

namespace taxi_config::dir_file {

struct Def {
  ::std::optional<::std::string> type{};
};

Def Parse(const formats::json::Value& elem, formats::parse::To<Def>);

template <typename U>
std::enable_if_t<std::is_same<U, Def>::value, bool> operator==(const U& lhs,
                                                               const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(boost::has_equal_to<decltype(lhs.type)>::value,
                "No operator==() defined for field 'type' of type "
                "'::std::optional<::std::string>'");

  return std::tie(lhs.type) == std::tie(rhs.type);
}

template <typename U>
std::enable_if_t<std::is_same<U, Def>::value, bool> operator!=(const U& lhs,
                                                               const U& rhs)
{
  return !(lhs == rhs);
}

}
