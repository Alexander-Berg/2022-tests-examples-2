/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s):
// taxi/schemas/schemas/configs/declarations/some/CONFIG.yaml

#pragma once

#include <userver/dynamic_config/fwd.hpp>
#include <userver/dynamic_config/snapshot.hpp>
#include <userver/dynamic_config/value.hpp>

#include <array>
#include <boost/type_traits/has_equal_to.hpp>
#include <codegen/convert_to_json_optional.hpp>
#include <codegen/format.hpp>
#include <codegen/parsing_flags.hpp>
#include <optional>
#include <string>
#include <taxi_config/definitions/dir_file.hpp>
#include <userver/formats/json/inline.hpp>
#include <userver/formats/json/string_builder_fwd.hpp>
#include <userver/formats/json/value_builder.hpp>
#include <userver/logging/log_helper_fwd.hpp>
#include <variant>

namespace taxi_config::config {

class OneOfWithDiscriminator {
 public:
  using Variant =
      std::variant<taxi_config::dir_file::Def, taxi_config::dir_file::Def2>;

  OneOfWithDiscriminator() = default;

  template <
      class T,
      class = std::enable_if_t<
          std::is_same<std::decay_t<T>, Variant>::value ||
          std::is_same<std::decay_t<T>, taxi_config::dir_file::Def>::value ||
          std::is_same<std::decay_t<T>, taxi_config::dir_file::Def2>::value>>
  explicit OneOfWithDiscriminator(T&& value)
      : data_(std::forward<T>(value))
  {}

  template <
      class T,
      class = std::enable_if_t<
          std::is_same<std::decay_t<T>, Variant>::value ||
          std::is_same<std::decay_t<T>, taxi_config::dir_file::Def>::value ||
          std::is_same<std::decay_t<T>, taxi_config::dir_file::Def2>::value>>
  OneOfWithDiscriminator& operator=(T&& value) {
    data_ = std::forward<T>(value);
    return *this;
  }

  template <class Target>
  Target& As() {
    return std::get<Target>(data_);
  }

  template <class Target>
  const Target& As() const {
    return std::get<Target>(data_);
  }

  Variant& AsVariant() { return data_; }
  const Variant& AsVariant() const { return data_; }

 private:
  Variant data_{};
};

OneOfWithDiscriminator Parse(const formats::json::Value& elem,
                             formats::parse::To<OneOfWithDiscriminator>);

template <typename U>
std::enable_if_t<std::is_same<U, OneOfWithDiscriminator>::value, bool>
operator==(const U& lhs, const U& rhs) {
  return lhs.AsVariant() == rhs.AsVariant();
}

template <typename U>
std::enable_if_t<std::is_same<U, OneOfWithDiscriminator>::value, bool>
operator!=(const U& lhs, const U& rhs) {
  return !(lhs.data_ == rhs.data_);
}

}

namespace taxi_config::config {

using VariableType = ::std::string;

VariableType ParseVariable(const dynamic_config::DocsMap&);

}

namespace taxi_config {

inline constexpr dynamic_config::Key<config::ParseVariable> CONFIG;

}
