{
  "consumer": "eda-surge",
  "global_scope": {
    "source_code": "let kA = 0;"
  },
  "id": "0",
  "name": "validation_test",
  "stages": [
    {
      "conditions": [],
      "in_bindings": [],
      "name": "fetch_settings",
      "optional": false,
      "resources": [
        {
          "name": "places_settings"
        }
      ],
      "source_code": "return{places_settings:{}};"
    },
    {
      "conditions": [],
      "in_bindings": [
        {
          "domain": "input",
          "query": {
            "operations": [
              {
                "property_name": "places"
              }
            ]
          }
        }
      ],
      "name": "fetch_taxi_surge",
      "optional": false,
      "resources": [
        {
          "field": "taxi_surge",
          "name": "warehouse_taxi_surge"
        }
      ],
      "source_code": "/*check global_scope*/ log.info_ex('kA = ' + kA); let ids = [];\nfor (let i in places) {\n  let place = places[i];\n  ids.push(place.place_id);\n}\n\nreturn {\n  taxi_surge: {\n    place_ids: ids,\n    categories: ['courier', 'express','econom']\n  }\n};"
    },
    {
      "conditions": [],
      "in_bindings": [
        {
          "domain": "input",
          "query": "places"
        },
        {
          "domain": "resource",
          "query": "places_settings"
        }
      ],
      "name": "fetch_counters",
      "optional": false,
      "resources": [
        {
          "name": "eda_supply"
        }
      ],
      "source_code": "let supply_params = [];\nfor (let i in places) {\n  let place = places[i];\n  let params = places_settings[place.place_id][place.zone_id];\n  supply_params.push({\n    place_id: place.place_id,\n    zone_id: place.zone_id,\n    region_id: params.region_id,\n    radius: params.settings.max_distance * 0.7,\n    time_quants: params.settings.time_quants\n  });\n}\nreturn {eda_supply: supply_params};\n"
    },
    {
      "conditions": [],
      "in_bindings": [
        {
          "domain": "input",
          "query": "places.*{idx:place}"
        },
        {
          "domain": "resource",
          "query": "eda_supply[place.place_id][place.zone_id]{place_supply}"
        },
        {
          "domain": "resource",
          "query": "places_settings[place.place_id][place.zone_id].settings{place_settings}"
        },
        {
          "domain": "resource",
          "query": {
            "operations": [
              {
                "property_name": "taxi_surge"
              }
            ]
          }
        }
      ],
      "name": "calc_load_level",
      "optional": false,
      "out_bindings": [
        {
          "alias": "data",
          "query": "places_out[idx]"
        }
      ],
      "source_code": "function get_free(supply, supply_counter) {\n  for (let i = 0; i < supply.length; i++) {\n    let time_quant = supply[i];\n    if (time_quant.to == 0) {\n      let res = 0;\n      for (let j = 0; j < time_quant.values.length; j++) {\n        res += time_quant.values[j].value[supply_counter];\n      }\n      return res;\n    }\n  }\n  return 0;\n}\n\nfunction get_conditionally_free(supply, cond_free_threshold, supply_counter) {\n  let res = 0;\n  for (let i = 0; i < supply.length; i++) {\n    let time_quant = supply[i];\n    if (time_quant.to == 0) continue;\n\n    let avg_time = (time_quant.to + time_quant.from) / 2;\n    if (avg_time > cond_free_threshold) continue;\n\n    //let weight = (cond_free_threshold - avg_time) / cond_free_threshold;\n    let weight = 1.0;\n    for (let j = 0; j < time_quant.values.length; j++) {\n      res += time_quant.values[j].value[supply_counter] * weight;\n    }\n  }\n  return res;\n}\n\nfunction get_busy(demand, supply_counter) {\n  for (let i = 0; i < demand.length; i++) {\n    let time_quant = demand[i];\n    if (time_quant.to == 0) {\n      let res = 0;\n      for (let j = 0; j < time_quant.values.length; j++) {\n        res += time_quant.values[j].value[supply_counter];\n      }\n      return res;\n    }\n  }\n  return 0;\n}\n\nfunction get_conditionally_busy(demand, cond_busy_threshold, supply_counter) {\n  let res = 0;\n  for (let i = 0; i < demand.length; i++) {\n    let time_quant = demand[i];\n    if (time_quant.to == 0) continue;\n\n    let avg_time = (time_quant.to + time_quant.from) / 2;\n    if (avg_time > cond_busy_threshold) continue;\n\n    let weight = (cond_busy_threshold - avg_time) / cond_busy_threshold;\n    for (let j = 0; j < time_quant.values.length; j++) {\n      res += time_quant.values[j].value[supply_counter] * weight;\n    }\n  }\n  return res;\n}\n\nlet damper_x = place_settings.damper_x || 0;\nlet damper_y = place_settings.damper_y || 1;\nlet cond_free_threshold = place_settings.cond_free_threshold;\nlet cond_busy_threshold = place_settings.cond_busy_threshold;\nlet supply_counter = place_settings.supply_counter || 'total';\n\nlet supply_quantums = place_supply.supply;\nlet free = get_free(supply_quantums, supply_counter);\nlet conditionally_free =\n    get_conditionally_free(supply_quantums, cond_free_threshold, supply_counter);\n\nlet demand_quantums = place_supply.demand;\nlet busy = get_busy(demand_quantums, supply_counter);\nlet conditionally_busy =\n    get_conditionally_busy(demand_quantums, cond_busy_threshold, supply_counter);\n\nlet load_level = Math.round((busy + conditionally_busy + damper_x) /\n    (busy + free + conditionally_free + damper_y) * 100);\n\nlet add_load_level = place_settings.add_load_level || 0;\nload_level += add_load_level;\n\n\nlog.info_ex(JSON.stringify({\n  damper_x:  damper_x,\n  damper_y:  damper_y,\n  cond_free_threshold:  cond_free_threshold,\n  cond_busy_threshold:  cond_busy_threshold,\n  free:  free,\n  conditionally_free:  conditionally_free,\n  busy:  busy,\n  conditionally_busy:  conditionally_busy,\n  load_level:  load_level,\n  add_load_level: add_load_level\n}\n));\n\nlet taxi = {};\nif ((taxi_surge) && (taxi_surge[place.place_id])) {\n  taxi = taxi_surge[place.place_id];\n}\n\nlog.info_ex(JSON.stringify({\n  ab_name:'surge_switchback_thresholds_change_1',\n  ab_dt: taxi\n}));\n\n\nreturn {\n  data: {\n    place_id: place.place_id,\n    zone_id: place.zone_id,\n    result: {\n      load_level: load_level,\n      free: free,\n      busy: busy,\n      extra: {\n        conditionally_busy: conditionally_busy,\n        conditionally_free: conditionally_free,\n        damper_x: damper_x,\n        damper_y: damper_y,\n        add_load_level: add_load_level,\n        taxi_surge: taxi\n      }\n    }\n  }\n};\n"
    },
    {
      "conditions": [],
      "in_bindings": [
        {
          "domain": "input",
          "query": "places.*{idx:place}"
        },
        {
          "domain": "resource",
          "query": "places_settings[place.place_id][place.zone_id].settings{place_settings}"
        },
        {
          "domain": "resource",
          "query": "places_settings[place.place_id][place.zone_id].region_id{region_id}"
        },
        {
          "domain": "output",
          "query": "places_out[idx].result.load_level"
        },
        {
          "domain": "output",
          "query": "places_out[idx].result.free"
        },
        {
          "domain": "output",
          "query": "places_out[idx].result.busy"
        },
        {
          "domain": "output",
          "query": "places_out[idx].result.extra.taxi_surge"
        }
      ],
      "name": "calc_surge_level",
      "optional": false,
      "out_bindings": [
        {
          "alias": "surge_level",
          "query": "places_out[idx].result.surge_level"
        },
        {
          "alias": "ab_group",
          "query": "places_out[idx].result.extra.ab_group"
        },
        {
          "alias": "show_radius",
          "query": "places_out[idx].result.extra.show_radius"
        },
        {
          "alias": "taxi_surge_data",
          "query": "places_out[idx].result.extra.taxi_surge_data"
        }
      ],
      "source_code": "// let low_density_surge_regions = [7, 13, 17, 37, 29, 5, 15, 39, 21, 1616, 1577, 57, 1607, 63, 1598, 101, 45, 225, 580, 80, 66, 515];\n\nlet low_density_off_regions = [9, 13, 15, 17, 19, 21, 27, 33, 35, 37, 45, 48, 54, 60, 66, 69, 77, 83, 90, 93, 96, 101, 104, 110, 119, 122, 134, 160, 165, 200, 305, 430, 465, 475, 500, 565, 580, 590, 610, 1589, 1598, 1607];\n\nlet taxi_surge_off_regions = [1, 3, 9, 31];\nlet taxi_surge_normal_treshhold = 180;\nlet taxi_surge_low_density_treshhold = 160;\nlet taxi_add_load_level = 5;\n\nlet minimal_courier_count = place_settings.minimal_courier_count;\nlet is_surge_active = place_settings.is_surge_active;\nlet is_experiment_active = place_settings.is_experiment_active;\nlet is_low_dens_surge_radius = place_settings.is_low_dens_surge_radius || 0;\n\n\nfunction is_in_test_group() {\n  let utc_shifted_now_dttm = Date.now() + 3 * 60 * 1000;\n  let period_timestamp = Math.floor(utc_shifted_now_dttm / (45 * 60 * 1000));\n  let date_timestamp = Math.floor(utc_shifted_now_dttm / (24 * 60 * 60 * 1000));\n  return period_timestamp % 2 === date_timestamp % 2\n}\n\nlet is_test_group = is_in_test_group();\nlet group = is_test_group ? 'test' : 'control';\n\n// Load experiment-dependent settings\nlet c1 = place_settings.c1;\nlet c2 = place_settings.c2;\nlet number_of_thresholds = place_settings.number_of_thresholds;\nlet show_radius_levels = place_settings.show_radius_coef;\nlet show_radius_distance = place_settings.show_radius_distance;\n\nif (group === 'test' && is_experiment_active == 1) {\n  c1 = place_settings.test_c1;\n  c2 = place_settings.test_c2;\n  \n  number_of_thresholds = place_settings.test_number_of_thresholds;\n}\n\nlet taxi_surge_level = 0;\nif (taxi_surge && (\"courier\" in taxi_surge) && (\"express\" in taxi_surge)) {\n  let taxi_surge_courier_surge = taxi_surge.courier.surge || 0.9;\n  let taxi_surge_courier_weight = taxi_surge.courier.weight || 1.0;\n  let taxi_surge_express_surge = taxi_surge.express.surge || 0.9;\n  let taxi_surge_express_weight = taxi_surge.express.weight || 1.0;\n  taxi_surge_level= Math.round(100 * (2 * taxi_surge_courier_surge * taxi_surge_courier_weight + taxi_surge_express_surge * taxi_surge_express_weight) / 3);\n}\n\nlet taxi_surge_data = {\n  low_density_surge_taxi_flg: ((taxi_surge_level > taxi_surge_low_density_treshhold) && is_test_group && !taxi_surge_off_regions.includes(region_id)),\n  normal_surge_taxi_flg: !((taxi_surge_level < taxi_surge_normal_treshhold) || (!is_test_group) || taxi_surge_off_regions.includes(region_id)),\n  taxi_surge_level: taxi_surge_level\n}\n\n// Default result\nlet result = {\n  surge_level: 0,\n  ab_group: group,\n  show_radius: 50000,\n  taxi_surge_data: taxi_surge_data\n};\n\n\n\n\n// Check if we should apply surge\nif (is_surge_active != 1) {\n  return result;\n}\n\n// spb marketing surge-price disabled, but surge-radius applied\n// if (region_id && region_id == 3) {\n//   let dttm_begin = Date.parse('2021-10-16T06:00:00+03:00');\n//   let dttm_end = Date.parse('2021-10-17T23:59:59+03:00');\n//   let dttm_now = Date.now();\n//   if(dttm_now > dttm_begin && dttm_now < dttm_end){\n//     result.surge_level = 0;\n\n//     // Calculate surge radius\n//     for (let i = 0; i < show_radius_levels.length; i++) {\n//     if (load_level >= show_radius_levels[i]) {\n//         result.show_radius = show_radius_distance[i];\n//     }\n//     }\n//     return result;\n//   }\n// }\n\n\n// Calculate surge radius\nlet show_radius = result[\"show_radius\"];\nfor (let i = 0; i < show_radius_levels.length; i++) {\n   if (load_level >= show_radius_levels[i]) {\n      show_radius = show_radius_distance[i];\n   }\n}\n\n//Low density\nif ((free + busy) < minimal_courier_count) {\n  // Low density surge\n  // if (region_id && low_density_surge_regions.includes(region_id)) {}\n  if (region_id && !(low_density_off_regions.includes(region_id))) {\n    if ((free < 2) && (busy != 0 || free != 1)) {\n      result.surge_level = 1;\n    }\n  }\n  if (region_id && low_density_off_regions.includes(region_id)) {\n    if ((free == 0 ) && (busy == 0 || busy == 1 || busy == 2)) {\n      result.surge_level = 1;\n    }\n  }\n  \n  if ((taxi_surge_level > taxi_surge_low_density_treshhold) && is_test_group && !taxi_surge_off_regions.includes(region_id)) {\n    result.surge_level = result.surge_level + 1;\n  }\n  \n  if (is_low_dens_surge_radius) {\n    result.show_radius = show_radius;\n  }\n  return result;\n}\n\n\n// Calculate surge level\nresult.surge_level = number_of_thresholds;\n\nfor (let i = 0; i < number_of_thresholds; i++) {\n  let l = 100 * (c2[i] + (c1[i] / (free + busy)));\n  if ((taxi_surge_level < taxi_surge_normal_treshhold) || (!is_test_group) || taxi_surge_off_regions.includes(region_id)) {\n    taxi_add_load_level = 0;\n  }\n  if (load_level < l - taxi_add_load_level) {\n    result.surge_level = i;\n    break;\n  }\n}\n\n// Apply surge radius\nresult.show_radius = show_radius;\n\n// Return result\nreturn result;"
    },
    {
      "conditions": [],
      "in_bindings": [
        {
          "domain": "input",
          "query": "places.*{idx:place}"
        },
        {
          "domain": "resource",
          "query": "places_settings[place.place_id][place.zone_id].settings{place_settings}"
        },
        {
          "domain": "output",
          "query": "places_out[idx].result.surge_level"
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "children": [
                        {
                          "query": {
                            "operations": [
                              {
                                "property_name": "ab_group"
                              }
                            ]
                          }
                        }
                      ],
                      "query": {
                        "operations": [
                          {
                            "property_name": "extra"
                          }
                        ]
                      }
                    }
                  ],
                  "query": {
                    "operations": [
                      {
                        "property_name": "result"
                      }
                    ]
                  }
                }
              ],
              "query": {
                "operations": [
                  {
                    "expression": "idx"
                  }
                ]
              }
            }
          ],
          "domain": "output",
          "query": {
            "operations": [
              {
                "property_name": "places_out"
              }
            ]
          }
        }
      ],
      "name": "surge_reaction",
      "optional": false,
      "out_bindings": [
        {
          "alias": "delivery_fee",
          "query": "places_out[idx].result.delivery_fee"
        },
        {
          "alias": "ab_name",
          "query": "places_out[idx].result.extra.ab_name"
        }
      ],
      "source_code": "let group = ab_group;\n\nlet time = place_settings.additional_time_percents[surge_level];\nlet test_min_df = place_settings.test_min_delivery_fee;\nlet is_experiment_active = place_settings.is_experiment_active;\n\nlet d_f = 0;\n\nif (group === 'test' && is_experiment_active == 1) {\n  d_f = place_settings.test_delivery_fee[surge_level];\n}\nelse {\n  d_f = place_settings.delivery_fee[surge_level];\n}\n\nlog.info_ex(JSON.stringify({\n  delivery_fee:d_f,\n  additional_time_percents:time,\n  ab_name:'surge_switchback_thresholds_change_1'\n}));\n\nreturn{\n  delivery_fee:d_f,\n  // additional_time_percents:time,   commented to have marketplace surge as 0\n  ab_name:'surge_switchback_thresholds_change_1'\n};\n"
    }
  ]
}
