/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s):
// taxi/schemas/schemas/configs/declarations/metrix/METRIX_AGGREGATION.yaml

#pragma once

#include <userver/dynamic_config/fwd.hpp>
#include <userver/dynamic_config/snapshot.hpp>
#include <userver/dynamic_config/value.hpp>

#include <array>
#include <boost/type_traits/has_equal_to.hpp>
#include <codegen/convert_to_json_optional.hpp>
#include <codegen/format.hpp>
#include <codegen/parsing_flags.hpp>
#include <optional>
#include <string>
#include <unordered_set>
#include <userver/formats/json/inline.hpp>
#include <userver/formats/json/string_builder_fwd.hpp>
#include <userver/formats/json/value_builder.hpp>
#include <userver/logging/log_helper_fwd.hpp>
#include <variant>
#include <vector>

namespace taxi_config::metrix_aggregation {

struct Whitelist {
  ::std::string label_name{};
  ::std::optional<::std::string> rule_type{};
  bool use_others{};
  ::std::vector<std::string> values{};
};

Whitelist Parse(const formats::json::Value& elem,
                formats::parse::To<Whitelist>);

template <typename U>
std::enable_if_t<std::is_same<U, Whitelist>::value, bool> operator==(
    const U& lhs, const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(
      boost::has_equal_to<decltype(lhs.label_name)>::value,
      "No operator==() defined for field 'label_name' of type '::std::string'");
  static_assert(boost::has_equal_to<decltype(lhs.rule_type)>::value,
                "No operator==() defined for field 'rule_type' of type "
                "'::std::optional<::std::string>'");
  static_assert(
      boost::has_equal_to<decltype(lhs.use_others)>::value,
      "No operator==() defined for field 'use_others' of type 'bool'");
  static_assert(boost::has_equal_to<decltype(lhs.values)>::value,
                "No operator==() defined for field 'values' of type "
                "'::std::vector<std::string>'");

  return std::tie(lhs.label_name, lhs.rule_type, lhs.use_others, lhs.values) ==
         std::tie(rhs.label_name, rhs.rule_type, rhs.use_others, rhs.values);
}

template <typename U>
std::enable_if_t<std::is_same<U, Whitelist>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

}

namespace taxi_config::metrix_aggregation {

struct SubsetOfRule {
  ::std::unordered_set<std::string> subset_of{};
};

SubsetOfRule Parse(const formats::json::Value& elem,
                   formats::parse::To<SubsetOfRule>);

template <typename U>
std::enable_if_t<std::is_same<U, SubsetOfRule>::value, bool> operator==(
    const U& lhs, const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(boost::has_equal_to<decltype(lhs.subset_of)>::value,
                "No operator==() defined for field 'subset_of' of type "
                "'::std::unordered_set<std::string>'");

  return std::tie(lhs.subset_of) == std::tie(rhs.subset_of);
}

template <typename U>
std::enable_if_t<std::is_same<U, SubsetOfRule>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

}

namespace taxi_config::metrix_aggregation {

struct Group {
  ::std::string group_name{};
  ::std::vector<std::string> values{};
};

Group Parse(const formats::json::Value& elem, formats::parse::To<Group>);

template <typename U>
std::enable_if_t<std::is_same<U, Group>::value, bool> operator==(const U& lhs,
                                                                 const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(
      boost::has_equal_to<decltype(lhs.group_name)>::value,
      "No operator==() defined for field 'group_name' of type '::std::string'");
  static_assert(boost::has_equal_to<decltype(lhs.values)>::value,
                "No operator==() defined for field 'values' of type "
                "'::std::vector<std::string>'");

  return std::tie(lhs.group_name, lhs.values) ==
         std::tie(rhs.group_name, rhs.values);
}

template <typename U>
std::enable_if_t<std::is_same<U, Group>::value, bool> operator!=(const U& lhs,
                                                                 const U& rhs)
{
  return !(lhs == rhs);
}

}

namespace taxi_config::metrix_aggregation {

struct Grouping {
  ::std::vector<taxi_config::metrix_aggregation::Group> groups{};
  ::std::string label_name{};
  ::std::optional<::std::string> rule_type{};
  bool use_others{};
};

Grouping Parse(const formats::json::Value& elem, formats::parse::To<Grouping>);

template <typename U>
std::enable_if_t<std::is_same<U, Grouping>::value, bool> operator==(
    const U& lhs, const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(boost::has_equal_to<decltype(lhs.groups)>::value,
                "No operator==() defined for field 'groups' of type "
                "'::std::vector<taxi_config::metrix_aggregation::Group>'");
  static_assert(
      boost::has_equal_to<decltype(lhs.label_name)>::value,
      "No operator==() defined for field 'label_name' of type '::std::string'");
  static_assert(boost::has_equal_to<decltype(lhs.rule_type)>::value,
                "No operator==() defined for field 'rule_type' of type "
                "'::std::optional<::std::string>'");
  static_assert(
      boost::has_equal_to<decltype(lhs.use_others)>::value,
      "No operator==() defined for field 'use_others' of type 'bool'");

  return std::tie(lhs.groups, lhs.label_name, lhs.rule_type, lhs.use_others) ==
         std::tie(rhs.groups, rhs.label_name, rhs.rule_type, rhs.use_others);
}

template <typename U>
std::enable_if_t<std::is_same<U, Grouping>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

}

namespace taxi_config::metrix_aggregation {

class AggRule {
 public:
  using Variant = std::variant<taxi_config::metrix_aggregation::Whitelist,
                               taxi_config::metrix_aggregation::Grouping>;

  AggRule() = default;

  template <
      class T,
      class = std::enable_if_t<
          std::is_same<std::decay_t<T>, Variant>::value ||
          std::is_same<std::decay_t<T>,
                       taxi_config::metrix_aggregation::Whitelist>::value ||
          std::is_same<std::decay_t<T>,
                       taxi_config::metrix_aggregation::Grouping>::value>>
  explicit AggRule(T&& value)
      : data_(std::forward<T>(value))
  {}

  template <
      class T,
      class = std::enable_if_t<
          std::is_same<std::decay_t<T>, Variant>::value ||
          std::is_same<std::decay_t<T>,
                       taxi_config::metrix_aggregation::Whitelist>::value ||
          std::is_same<std::decay_t<T>,
                       taxi_config::metrix_aggregation::Grouping>::value>>
  AggRule& operator=(T&& value) {
    data_ = std::forward<T>(value);
    return *this;
  }

  template <class Target>
  Target& As() {
    return std::get<Target>(data_);
  }

  template <class Target>
  const Target& As() const {
    return std::get<Target>(data_);
  }

  Variant& AsVariant() { return data_; }
  const Variant& AsVariant() const { return data_; }

 private:
  Variant data_{};
};

AggRule Parse(const formats::json::Value& elem, formats::parse::To<AggRule>);

template <typename U>
std::enable_if_t<std::is_same<U, AggRule>::value, bool> operator==(
    const U& lhs, const U& rhs) {
  return lhs.AsVariant() == rhs.AsVariant();
}

template <typename U>
std::enable_if_t<std::is_same<U, AggRule>::value, bool> operator!=(
    const U& lhs, const U& rhs) {
  return !(lhs.data_ == rhs.data_);
}

}

namespace taxi_config::metrix_aggregation {

struct AllOfRule {
  ::std::unordered_set<std::string> all_of{};
};

AllOfRule Parse(const formats::json::Value& elem,
                formats::parse::To<AllOfRule>);

template <typename U>
std::enable_if_t<std::is_same<U, AllOfRule>::value, bool> operator==(
    const U& lhs, const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(boost::has_equal_to<decltype(lhs.all_of)>::value,
                "No operator==() defined for field 'all_of' of type "
                "'::std::unordered_set<std::string>'");

  return std::tie(lhs.all_of) == std::tie(rhs.all_of);
}

template <typename U>
std::enable_if_t<std::is_same<U, AllOfRule>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

}

namespace taxi_config::metrix_aggregation {

struct AnyOfRule {
  ::std::unordered_set<std::string> any_of{};
};

AnyOfRule Parse(const formats::json::Value& elem,
                formats::parse::To<AnyOfRule>);

template <typename U>
std::enable_if_t<std::is_same<U, AnyOfRule>::value, bool> operator==(
    const U& lhs, const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(boost::has_equal_to<decltype(lhs.any_of)>::value,
                "No operator==() defined for field 'any_of' of type "
                "'::std::unordered_set<std::string>'");

  return std::tie(lhs.any_of) == std::tie(rhs.any_of);
}

template <typename U>
std::enable_if_t<std::is_same<U, AnyOfRule>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

}

namespace taxi_config::metrix_aggregation {

struct NoneOfRule {
  ::std::unordered_set<std::string> none_of{};
};

NoneOfRule Parse(const formats::json::Value& elem,
                 formats::parse::To<NoneOfRule>);

template <typename U>
std::enable_if_t<std::is_same<U, NoneOfRule>::value, bool> operator==(
    const U& lhs, const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(boost::has_equal_to<decltype(lhs.none_of)>::value,
                "No operator==() defined for field 'none_of' of type "
                "'::std::unordered_set<std::string>'");

  return std::tie(lhs.none_of) == std::tie(rhs.none_of);
}

template <typename U>
std::enable_if_t<std::is_same<U, NoneOfRule>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

}

namespace taxi_config::metrix_aggregation {

struct AndRule {
  ::std::vector<std::variant<taxi_config::metrix_aggregation::NoneOfRule,
                             taxi_config::metrix_aggregation::AllOfRule,
                             taxi_config::metrix_aggregation::AnyOfRule,
                             taxi_config::metrix_aggregation::SubsetOfRule>>
      and_{};
};

AndRule Parse(const formats::json::Value& elem, formats::parse::To<AndRule>);

template <typename U>
std::enable_if_t<std::is_same<U, AndRule>::value, bool> operator==(const U& lhs,
                                                                   const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(boost::has_equal_to<decltype(lhs.and_)>::value,
                "No operator==() defined for field 'and_' of type "
                "'::std::vector<std::variant<taxi_config::metrix_aggregation::"
                "NoneOfRule,taxi_config::metrix_aggregation::AllOfRule,taxi_"
                "config::metrix_aggregation::AnyOfRule,taxi_config::metrix_"
                "aggregation::SubsetOfRule>>'");

  return std::tie(lhs.and_) == std::tie(rhs.and_);
}

template <typename U>
std::enable_if_t<std::is_same<U, AndRule>::value, bool> operator!=(const U& lhs,
                                                                   const U& rhs)
{
  return !(lhs == rhs);
}

}

namespace taxi_config::metrix_aggregation {

struct NotRule {
  ::std::variant<taxi_config::metrix_aggregation::NoneOfRule,
                 taxi_config::metrix_aggregation::AllOfRule,
                 taxi_config::metrix_aggregation::AnyOfRule,
                 taxi_config::metrix_aggregation::SubsetOfRule>
      not_{};
};

NotRule Parse(const formats::json::Value& elem, formats::parse::To<NotRule>);

template <typename U>
std::enable_if_t<std::is_same<U, NotRule>::value, bool> operator==(const U& lhs,
                                                                   const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(
      boost::has_equal_to<decltype(lhs.not_)>::value,
      "No operator==() defined for field 'not_' of type "
      "'::std::variant<taxi_config::metrix_aggregation::NoneOfRule,taxi_config:"
      ":metrix_aggregation::AllOfRule,taxi_config::metrix_aggregation::"
      "AnyOfRule,taxi_config::metrix_aggregation::SubsetOfRule>'");

  return std::tie(lhs.not_) == std::tie(rhs.not_);
}

template <typename U>
std::enable_if_t<std::is_same<U, NotRule>::value, bool> operator!=(const U& lhs,
                                                                   const U& rhs)
{
  return !(lhs == rhs);
}

}

namespace taxi_config::metrix_aggregation {

struct OrRule {
  ::std::vector<std::variant<taxi_config::metrix_aggregation::NoneOfRule,
                             taxi_config::metrix_aggregation::AllOfRule,
                             taxi_config::metrix_aggregation::AnyOfRule,
                             taxi_config::metrix_aggregation::SubsetOfRule>>
      or_{};
};

OrRule Parse(const formats::json::Value& elem, formats::parse::To<OrRule>);

template <typename U>
std::enable_if_t<std::is_same<U, OrRule>::value, bool> operator==(const U& lhs,
                                                                  const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(boost::has_equal_to<decltype(lhs.or_)>::value,
                "No operator==() defined for field 'or_' of type "
                "'::std::vector<std::variant<taxi_config::metrix_aggregation::"
                "NoneOfRule,taxi_config::metrix_aggregation::AllOfRule,taxi_"
                "config::metrix_aggregation::AnyOfRule,taxi_config::metrix_"
                "aggregation::SubsetOfRule>>'");

  return std::tie(lhs.or_) == std::tie(rhs.or_);
}

template <typename U>
std::enable_if_t<std::is_same<U, OrRule>::value, bool> operator!=(const U& lhs,
                                                                  const U& rhs)
{
  return !(lhs == rhs);
}

}

namespace taxi_config::metrix_aggregation {

struct RuleWithValue {
  ::std::variant<taxi_config::metrix_aggregation::NoneOfRule,
                 taxi_config::metrix_aggregation::AllOfRule,
                 taxi_config::metrix_aggregation::AnyOfRule,
                 taxi_config::metrix_aggregation::SubsetOfRule,
                 taxi_config::metrix_aggregation::NotRule,
                 taxi_config::metrix_aggregation::AndRule,
                 taxi_config::metrix_aggregation::OrRule>
      rule{};
  ::std::vector<taxi_config::metrix_aggregation::AggRule> value{};
};

RuleWithValue Parse(const formats::json::Value& elem,
                    formats::parse::To<RuleWithValue>);

template <typename U>
std::enable_if_t<std::is_same<U, RuleWithValue>::value, bool> operator==(
    const U& lhs, const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(
      boost::has_equal_to<decltype(lhs.rule)>::value,
      "No operator==() defined for field 'rule' of type "
      "'::std::variant<taxi_config::metrix_aggregation::NoneOfRule,taxi_config:"
      ":metrix_aggregation::AllOfRule,taxi_config::metrix_aggregation::"
      "AnyOfRule,taxi_config::metrix_aggregation::SubsetOfRule,taxi_config::"
      "metrix_aggregation::NotRule,taxi_config::metrix_aggregation::AndRule,"
      "taxi_config::metrix_aggregation::OrRule>'");
  static_assert(boost::has_equal_to<decltype(lhs.value)>::value,
                "No operator==() defined for field 'value' of type "
                "'::std::vector<taxi_config::metrix_aggregation::AggRule>'");

  return std::tie(lhs.rule, lhs.value) == std::tie(rhs.rule, rhs.value);
}

template <typename U>
std::enable_if_t<std::is_same<U, RuleWithValue>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

}

namespace taxi_config::metrix_aggregation {
using Values = std::unordered_set<std::string>;
}

namespace taxi_config::metrix_aggregation {
using Rule = std::variant<taxi_config::metrix_aggregation::NoneOfRule,
                          taxi_config::metrix_aggregation::AllOfRule,
                          taxi_config::metrix_aggregation::AnyOfRule,
                          taxi_config::metrix_aggregation::SubsetOfRule,
                          taxi_config::metrix_aggregation::NotRule,
                          taxi_config::metrix_aggregation::AndRule,
                          taxi_config::metrix_aggregation::OrRule>;
}

namespace taxi_config::metrix_aggregation {

using VariableType =
    ::std::vector<taxi_config::metrix_aggregation::RuleWithValue>;

VariableType ParseVariable(const dynamic_config::DocsMap&);

}

namespace taxi_config {

/// Набор применяемых правил
inline constexpr dynamic_config::Key<metrix_aggregation::ParseVariable>
    METRIX_AGGREGATION;

}
