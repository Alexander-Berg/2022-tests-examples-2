/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s):
// taxi/schemas/schemas/configs/declarations/metrix/METRIX_AGGREGATION.yaml

#include <codegen/impl/convert.hpp>
#include <codegen/impl/get_validation_length.hpp>
#include <codegen/impl/optional_convert.hpp>
#include <codegen/impl/parsers.hpp>
#include <cstring>
#include <taxi_config/variables/METRIX_AGGREGATION.hpp>
#include <unordered_set>
#include <userver/dynamic_config/value.hpp>
#include <userver/formats/common/meta.hpp>
#include <userver/formats/json/serialize_container.hpp>
#include <userver/formats/json/serialize_variant.hpp>
#include <userver/formats/json/string_builder.hpp>
#include <userver/formats/parse/common_containers.hpp>
#include <userver/formats/parse/variant.hpp>
#include <userver/logging/log.hpp>
#include <userver/utils/assert.hpp>
#include <userver/utils/datetime/from_string_saturating.hpp>
#include <userver/utils/underlying_value.hpp>

namespace taxi_config::metrix_aggregation {

taxi_config::metrix_aggregation::Whitelist Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<taxi_config::metrix_aggregation::Whitelist>) {
  taxi_config::metrix_aggregation::Whitelist result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.label_name = elem["label_name"].As<std::string>();
  result.rule_type = elem["rule_type"].As<std::optional<::std::string>>();
  result.use_others = elem["use_others"].As<bool>();
  result.values =
      [](const formats::json::Value& array) -> std::vector<std::string> {
    std::vector<std::string> result;
    array.CheckArrayOrNull();
    result.reserve(array.GetSize());
    for (const auto& item : array) {
      result.insert(result.end(), item.As<std::string>());
    }

    return result;
  }(elem["values"]);

  return result;
}

}
namespace taxi_config::metrix_aggregation {

taxi_config::metrix_aggregation::SubsetOfRule Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<taxi_config::metrix_aggregation::SubsetOfRule>) {
  taxi_config::metrix_aggregation::SubsetOfRule result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.subset_of =
      [](const formats::json::Value& array) -> std::unordered_set<std::string> {
    std::unordered_set<std::string> result;
    array.CheckArrayOrNull();
    for (const auto& item : array) {
      result.insert(result.end(), item.As<std::string>());
    }

    return result;
  }(elem["subset_of"]);

  return result;
}

}
namespace taxi_config::metrix_aggregation {

taxi_config::metrix_aggregation::Group Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<taxi_config::metrix_aggregation::Group>) {
  taxi_config::metrix_aggregation::Group result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.group_name = elem["group_name"].As<std::string>();
  result.values =
      [](const formats::json::Value& array) -> std::vector<std::string> {
    std::vector<std::string> result;
    array.CheckArrayOrNull();
    result.reserve(array.GetSize());
    for (const auto& item : array) {
      result.insert(result.end(), item.As<std::string>());
    }

    return result;
  }(elem["values"]);

  return result;
}

}
namespace taxi_config::metrix_aggregation {

taxi_config::metrix_aggregation::Grouping Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<taxi_config::metrix_aggregation::Grouping>) {
  taxi_config::metrix_aggregation::Grouping result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.groups = [](const formats::json::Value& array)
      -> std::vector<taxi_config::metrix_aggregation::Group> {
    std::vector<taxi_config::metrix_aggregation::Group> result;
    array.CheckArrayOrNull();
    result.reserve(array.GetSize());
    for (const auto& item : array) {
      result.insert(result.end(),
                    item.As<taxi_config::metrix_aggregation::Group>());
    }

    return result;
  }(elem["groups"]);
  result.label_name = elem["label_name"].As<std::string>();
  result.rule_type = elem["rule_type"].As<std::optional<::std::string>>();
  result.use_others = elem["use_others"].As<bool>();

  return result;
}

}
namespace taxi_config::metrix_aggregation {

taxi_config::metrix_aggregation::AggRule Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<taxi_config::metrix_aggregation::AggRule>) {
  const auto discriminator = elem["rule_type"].As<std::string>();
  if (discriminator == "grouping") {
    return taxi_config::metrix_aggregation::AggRule{
        elem.As<taxi_config::metrix_aggregation::Grouping>(),
    };
  } else if (discriminator == "whitelist") {
    return taxi_config::metrix_aggregation::AggRule{
        elem.As<taxi_config::metrix_aggregation::Whitelist>(),
    };
  } else {
    throw formats::json::Value::ParseException(
        "Value of discriminator '" + discriminator + "' for path '" +
        elem.GetPath() +
        "' does not match any known mapping from ['grouping', 'whitelist']");
  }
}

}
namespace taxi_config::metrix_aggregation {

taxi_config::metrix_aggregation::AllOfRule Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<taxi_config::metrix_aggregation::AllOfRule>) {
  taxi_config::metrix_aggregation::AllOfRule result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.all_of =
      [](const formats::json::Value& array) -> std::unordered_set<std::string> {
    std::unordered_set<std::string> result;
    array.CheckArrayOrNull();
    for (const auto& item : array) {
      result.insert(result.end(), item.As<std::string>());
    }

    return result;
  }(elem["all_of"]);

  return result;
}

}
namespace taxi_config::metrix_aggregation {

taxi_config::metrix_aggregation::AnyOfRule Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<taxi_config::metrix_aggregation::AnyOfRule>) {
  taxi_config::metrix_aggregation::AnyOfRule result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.any_of =
      [](const formats::json::Value& array) -> std::unordered_set<std::string> {
    std::unordered_set<std::string> result;
    array.CheckArrayOrNull();
    for (const auto& item : array) {
      result.insert(result.end(), item.As<std::string>());
    }

    return result;
  }(elem["any_of"]);

  return result;
}

}
namespace taxi_config::metrix_aggregation {

taxi_config::metrix_aggregation::NoneOfRule Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<taxi_config::metrix_aggregation::NoneOfRule>) {
  taxi_config::metrix_aggregation::NoneOfRule result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.none_of =
      [](const formats::json::Value& array) -> std::unordered_set<std::string> {
    std::unordered_set<std::string> result;
    array.CheckArrayOrNull();
    for (const auto& item : array) {
      result.insert(result.end(), item.As<std::string>());
    }

    return result;
  }(elem["none_of"]);

  return result;
}

}
namespace taxi_config::metrix_aggregation {

taxi_config::metrix_aggregation::AndRule Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<taxi_config::metrix_aggregation::AndRule>) {
  taxi_config::metrix_aggregation::AndRule result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.and_ = [](const formats::json::Value& array)
      -> std::vector<
          std::variant<taxi_config::metrix_aggregation::NoneOfRule,
                       taxi_config::metrix_aggregation::AllOfRule,
                       taxi_config::metrix_aggregation::AnyOfRule,
                       taxi_config::metrix_aggregation::SubsetOfRule>> {
    std::vector<std::variant<taxi_config::metrix_aggregation::NoneOfRule,
                             taxi_config::metrix_aggregation::AllOfRule,
                             taxi_config::metrix_aggregation::AnyOfRule,
                             taxi_config::metrix_aggregation::SubsetOfRule>>
        result;
    array.CheckArrayOrNull();
    result.reserve(array.GetSize());
    for (const auto& item : array) {
      result.insert(
          result.end(),
          [](const formats::json::Value& value)
              -> std::variant<taxi_config::metrix_aggregation::NoneOfRule,
                              taxi_config::metrix_aggregation::AllOfRule,
                              taxi_config::metrix_aggregation::AnyOfRule,
                              taxi_config::metrix_aggregation::SubsetOfRule> {
            std::optional<
                std::variant<taxi_config::metrix_aggregation::NoneOfRule,
                             taxi_config::metrix_aggregation::AllOfRule,
                             taxi_config::metrix_aggregation::AnyOfRule,
                             taxi_config::metrix_aggregation::SubsetOfRule>>
                result;
            int parse_successes = 0;

            try {
              result = value.As<taxi_config::metrix_aggregation::NoneOfRule>();
              ++parse_successes;
            } catch (const std::exception&) {
            }
            try {
              result = value.As<taxi_config::metrix_aggregation::AllOfRule>();
              ++parse_successes;
            } catch (const std::exception&) {
            }
            try {
              result = value.As<taxi_config::metrix_aggregation::AnyOfRule>();
              ++parse_successes;
            } catch (const std::exception&) {
            }
            try {
              result =
                  value.As<taxi_config::metrix_aggregation::SubsetOfRule>();
              ++parse_successes;
            } catch (const std::exception&) {
            }

            if (parse_successes > 1) {
              throw ::formats::json::ParseException(
                  "Value of '" + value.GetPath() +
                  "' is ambiguous, it is parseable into multiple types");
            }

            if (!result) {
              throw ::formats::json::ParseException(
                  "Value of '" + value.GetPath() +
                  "' cannot be parsed as a variant");
            }
            return std::move(*result);
          }(item)

      );
    }

    return result;
  }(elem["and"]);

  return result;
}

}
namespace taxi_config::metrix_aggregation {

taxi_config::metrix_aggregation::NotRule Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<taxi_config::metrix_aggregation::NotRule>) {
  taxi_config::metrix_aggregation::NotRule result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.not_ = [](const formats::json::Value& value)
      -> std::variant<taxi_config::metrix_aggregation::NoneOfRule,
                      taxi_config::metrix_aggregation::AllOfRule,
                      taxi_config::metrix_aggregation::AnyOfRule,
                      taxi_config::metrix_aggregation::SubsetOfRule> {
    std::optional<std::variant<taxi_config::metrix_aggregation::NoneOfRule,
                               taxi_config::metrix_aggregation::AllOfRule,
                               taxi_config::metrix_aggregation::AnyOfRule,
                               taxi_config::metrix_aggregation::SubsetOfRule>>
        result;
    int parse_successes = 0;

    try {
      result = value.As<taxi_config::metrix_aggregation::NoneOfRule>();
      ++parse_successes;
    } catch (const std::exception&) {
    }
    try {
      result = value.As<taxi_config::metrix_aggregation::AllOfRule>();
      ++parse_successes;
    } catch (const std::exception&) {
    }
    try {
      result = value.As<taxi_config::metrix_aggregation::AnyOfRule>();
      ++parse_successes;
    } catch (const std::exception&) {
    }
    try {
      result = value.As<taxi_config::metrix_aggregation::SubsetOfRule>();
      ++parse_successes;
    } catch (const std::exception&) {
    }

    if (parse_successes > 1) {
      throw ::formats::json::ParseException(
          "Value of '" + value.GetPath() +
          "' is ambiguous, it is parseable into multiple types");
    }

    if (!result) {
      throw ::formats::json::ParseException("Value of '" + value.GetPath() +
                                            "' cannot be parsed as a variant");
    }
    return std::move(*result);
  }(elem["not"])

      ;

  return result;
}

}
namespace taxi_config::metrix_aggregation {

taxi_config::metrix_aggregation::OrRule Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<taxi_config::metrix_aggregation::OrRule>) {
  taxi_config::metrix_aggregation::OrRule result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.or_ = [](const formats::json::Value& array)
      -> std::vector<
          std::variant<taxi_config::metrix_aggregation::NoneOfRule,
                       taxi_config::metrix_aggregation::AllOfRule,
                       taxi_config::metrix_aggregation::AnyOfRule,
                       taxi_config::metrix_aggregation::SubsetOfRule>> {
    std::vector<std::variant<taxi_config::metrix_aggregation::NoneOfRule,
                             taxi_config::metrix_aggregation::AllOfRule,
                             taxi_config::metrix_aggregation::AnyOfRule,
                             taxi_config::metrix_aggregation::SubsetOfRule>>
        result;
    array.CheckArrayOrNull();
    result.reserve(array.GetSize());
    for (const auto& item : array) {
      result.insert(
          result.end(),
          [](const formats::json::Value& value)
              -> std::variant<taxi_config::metrix_aggregation::NoneOfRule,
                              taxi_config::metrix_aggregation::AllOfRule,
                              taxi_config::metrix_aggregation::AnyOfRule,
                              taxi_config::metrix_aggregation::SubsetOfRule> {
            std::optional<
                std::variant<taxi_config::metrix_aggregation::NoneOfRule,
                             taxi_config::metrix_aggregation::AllOfRule,
                             taxi_config::metrix_aggregation::AnyOfRule,
                             taxi_config::metrix_aggregation::SubsetOfRule>>
                result;
            int parse_successes = 0;

            try {
              result = value.As<taxi_config::metrix_aggregation::NoneOfRule>();
              ++parse_successes;
            } catch (const std::exception&) {
            }
            try {
              result = value.As<taxi_config::metrix_aggregation::AllOfRule>();
              ++parse_successes;
            } catch (const std::exception&) {
            }
            try {
              result = value.As<taxi_config::metrix_aggregation::AnyOfRule>();
              ++parse_successes;
            } catch (const std::exception&) {
            }
            try {
              result =
                  value.As<taxi_config::metrix_aggregation::SubsetOfRule>();
              ++parse_successes;
            } catch (const std::exception&) {
            }

            if (parse_successes > 1) {
              throw ::formats::json::ParseException(
                  "Value of '" + value.GetPath() +
                  "' is ambiguous, it is parseable into multiple types");
            }

            if (!result) {
              throw ::formats::json::ParseException(
                  "Value of '" + value.GetPath() +
                  "' cannot be parsed as a variant");
            }
            return std::move(*result);
          }(item)

      );
    }

    return result;
  }(elem["or"]);

  return result;
}

}
namespace taxi_config::metrix_aggregation {

taxi_config::metrix_aggregation::RuleWithValue Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<taxi_config::metrix_aggregation::RuleWithValue>) {
  taxi_config::metrix_aggregation::RuleWithValue result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.rule = [](const formats::json::Value& value)
      -> std::variant<taxi_config::metrix_aggregation::NoneOfRule,
                      taxi_config::metrix_aggregation::AllOfRule,
                      taxi_config::metrix_aggregation::AnyOfRule,
                      taxi_config::metrix_aggregation::SubsetOfRule,
                      taxi_config::metrix_aggregation::NotRule,
                      taxi_config::metrix_aggregation::AndRule,
                      taxi_config::metrix_aggregation::OrRule> {
    std::optional<std::variant<taxi_config::metrix_aggregation::NoneOfRule,
                               taxi_config::metrix_aggregation::AllOfRule,
                               taxi_config::metrix_aggregation::AnyOfRule,
                               taxi_config::metrix_aggregation::SubsetOfRule,
                               taxi_config::metrix_aggregation::NotRule,
                               taxi_config::metrix_aggregation::AndRule,
                               taxi_config::metrix_aggregation::OrRule>>
        result;
    int parse_successes = 0;

    try {
      result = value.As<taxi_config::metrix_aggregation::NoneOfRule>();
      ++parse_successes;
    } catch (const std::exception&) {
    }
    try {
      result = value.As<taxi_config::metrix_aggregation::AllOfRule>();
      ++parse_successes;
    } catch (const std::exception&) {
    }
    try {
      result = value.As<taxi_config::metrix_aggregation::AnyOfRule>();
      ++parse_successes;
    } catch (const std::exception&) {
    }
    try {
      result = value.As<taxi_config::metrix_aggregation::SubsetOfRule>();
      ++parse_successes;
    } catch (const std::exception&) {
    }
    try {
      result = value.As<taxi_config::metrix_aggregation::NotRule>();
      ++parse_successes;
    } catch (const std::exception&) {
    }
    try {
      result = value.As<taxi_config::metrix_aggregation::AndRule>();
      ++parse_successes;
    } catch (const std::exception&) {
    }
    try {
      result = value.As<taxi_config::metrix_aggregation::OrRule>();
      ++parse_successes;
    } catch (const std::exception&) {
    }

    if (parse_successes > 1) {
      throw ::formats::json::ParseException(
          "Value of '" + value.GetPath() +
          "' is ambiguous, it is parseable into multiple types");
    }

    if (!result) {
      throw ::formats::json::ParseException("Value of '" + value.GetPath() +
                                            "' cannot be parsed as a variant");
    }
    return std::move(*result);
  }(elem["rule"])

      ;
  result.value = [](const formats::json::Value& array)
      -> std::vector<taxi_config::metrix_aggregation::AggRule> {
    std::vector<taxi_config::metrix_aggregation::AggRule> result;
    array.CheckArrayOrNull();
    result.reserve(array.GetSize());
    for (const auto& item : array) {
      result.insert(result.end(),
                    item.As<taxi_config::metrix_aggregation::AggRule>());
    }

    return result;
  }(elem["value"]);

  return result;
}

}

namespace taxi_config::metrix_aggregation {

VariableType ParseVariable(const dynamic_config::DocsMap& docs_map) {
  return [](const formats::json::Value& array)
             -> std::vector<taxi_config::metrix_aggregation::RuleWithValue> {
    std::vector<taxi_config::metrix_aggregation::RuleWithValue> result;
    array.CheckArrayOrNull();
    result.reserve(array.GetSize());
    for (const auto& item : array) {
      result.insert(result.end(),
                    item.As<taxi_config::metrix_aggregation::RuleWithValue>());
    }

    return result;
  }(docs_map.Get("METRIX_AGGREGATION"));
}

}
