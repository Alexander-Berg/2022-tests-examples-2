/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

#include <clients/client-test-service/requests.hpp>
#include <userver/http/content_type.hpp>

#include <userver/formats/json/serialize_container.hpp>
#include <userver/formats/parse/common_containers.hpp>

#include <fmt/format.h>
#include <userver/formats/json/serialize.hpp>
#include <userver/formats/json/value_builder.hpp>
#include <userver/http/common_headers.hpp>
#include <userver/utils/assert.hpp>

#include <boost/algorithm/string/join.hpp>
#include <boost/uuid/uuid_io.hpp>
#include <codegen/impl/convert.hpp>
#include <codegen/impl/parsers.hpp>
#include <userver/utils/datetime/from_string_saturating.hpp>

#include <codegen/impl/convert.hpp>
#include <codegen/impl/get_validation_length.hpp>
#include <codegen/impl/optional_convert.hpp>
#include <codegen/impl/parsers.hpp>
#include <cstring>
#include <unordered_set>
#include <userver/formats/common/meta.hpp>
#include <userver/formats/json/string_builder.hpp>
#include <userver/logging/log.hpp>
#include <userver/utils/assert.hpp>
#include <userver/utils/datetime/from_string_saturating.hpp>
#include <userver/utils/underlying_value.hpp>

#include <codegen/impl/convert.hpp>

namespace clients::client_test_service {

namespace v1_my_arg_smth::get {

::clients::http::Headers Request::GetHeaders() const {
  ::clients::http::Headers headers(2);

  headers[::http::headers::kContentType] =
      ::http::content_type::kApplicationJson.ToString();

  if (this->x_test_header) headers["X-Test-Header"] = *this->x_test_header;

  return headers;
}

::http::Args Request::GetQuery() const {
  ::http::Args query(2);

  return query;
}

std::string Request::GetPath() const {
  return fmt::format("/v1/{my_arg}/smth", fmt::arg("my_arg", my_arg));
}

}

namespace v1_my_arg_smth::post {

::clients::http::Headers Request::GetHeaders() const {
  ::clients::http::Headers headers(3);

  headers[::http::headers::kContentType] = "application/json";

  if (this->x_test_header) headers["X-Test-Header"] = *this->x_test_header;

  return headers;
}

::http::Args Request::GetQuery() const {
  ::http::Args query(3);

  return query;
}

std::string Request::GetBody() const {
  formats::json::StringBuilder sw;
  WriteToStream(body, sw);
  return sw.GetString();
}

std::string Request::GetPath() const {
  return fmt::format("/v1/{my_arg}/smth", fmt::arg("my_arg", my_arg));
}

formats::json::Value Serialize(
    [[maybe_unused]] const clients::client_test_service::v1_my_arg_smth::post::
        Body& value, ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  if (value.array) builder.EmplaceNocheck("array", *value.array);
  builder.EmplaceNocheck("id", value.id);
  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const clients::client_test_service::
                       v1_my_arg_smth::post::Body& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);

  if (!hide_field_name || std::strcmp(hide_field_name, "array"))
  {
    if (value.array)
    {
      sw.Key("array");

      WriteToStream(*value.array, sw);
    }
  }
  if (!hide_field_name || std::strcmp(hide_field_name, "id"))
  {
    sw.Key("id");

    WriteToStream(value.id, sw);
  }
}

clients::client_test_service::v1_my_arg_smth::post::Body Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<
        clients::client_test_service::v1_my_arg_smth::post::Body>) {
  clients::client_test_service::v1_my_arg_smth::post::Body result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.array = [](const formats::json::Value& array)
      -> ::std::optional<::std::vector<std::string>> {
    if (array.IsMissing() || array.IsNull()) return std::nullopt;

    std::vector<std::string> result;
    array.CheckArrayOrNull();
    result.reserve(array.GetSize());
    for (const auto& item : array) {
      result.insert(result.end(), item.As<std::string>());
    }

    if (!(1 <= result.size())) {
      auto msg = "incorrect size, must be 1 (limit) <= " +
                 std::to_string(result.size()) + " (value)";
      throw formats::json::Value::ParseException("Value of '" +
                                                 array.GetPath() + "': " + msg);
    }

    return ::codegen::impl::Convert<
        ::std::optional<::std::vector<std::string>>::value_type,
        std::vector<std::string>>(std::move(result));
  }(elem["array"]);
  result.id = [](const formats::json::Value& value) -> int {
    auto tmp = value.As<int>();

    if (!(0 <= tmp)) {
      auto msg = "out of bounds, must be 0 (limit) <= " + std::to_string(tmp) +
                 " (value)";
      throw formats::json::Value::ParseException("Value of '" +
                                                 value.GetPath() + "': " + msg);
    }

    return tmp;
  }(elem["id"])

      ;

  return result;
}

namespace parser {
template <class To>
template <class From>
To PBody::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PBody::ParserLocalDomToType<To>::Convert(::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PBody::PBody()
{
  null_array_.Subscribe(sink_array_);

  f_array_.Subscribe(sink_array_);

  f_id_.Subscribe(sink_id_);
}

void PBody::Reset()
{
  state_ = State::kStart;
  result_ = {};

  s_array_ = false;
  s_id_ = false;
}

void PBody::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PBody::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else if (key == "array") {
    s_array_ = true;
    f_array_.Reset();

    parser_state_->PushParser(null_array_.GetParser());
  }

  else if (key == "id") {
    s_id_ = true;
    f_id_.Reset();

    parser_state_->PushParser(f_id_.GetParser());
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PBody::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      if (!s_array_) {
        result_.array = {};
      }
      if (!s_id_) {
        throw ::formats::json::parser::InternalParseError(
            "missing required field 'id'");
      }

      SetResult(std::move(result_));
      break;
  }
}

std::string PBody::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PBody::GetPathItem() const { return key_; }
}

}

namespace v2_smth::get {

::clients::http::Headers Request::GetHeaders() const {
  ::clients::http::Headers headers(0);

  headers[::http::headers::kContentType] =
      ::http::content_type::kApplicationJson.ToString();

  return headers;
}

::http::Args Request::GetQuery() const {
  ::http::Args query(0);

  return query;
}

}

namespace v2_smth::post {

::clients::http::Headers Request::GetHeaders() const {
  ::clients::http::Headers headers(1);

  headers[::http::headers::kContentType] = "application/json";

  return headers;
}

::http::Args Request::GetQuery() const {
  ::http::Args query(1);

  return query;
}

std::string Request::GetBody() const {
  formats::json::StringBuilder sw;
  WriteToStream(body, sw);
  return sw.GetString();
}

formats::json::Value Serialize(
    [[maybe_unused]] const clients::client_test_service::v2_smth::post::Body&
        value, ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  return builder.ExtractValue();
}

void WriteToStream(
    [[maybe_unused]] const clients::client_test_service::v2_smth::post::Body&
        value, formats::json::StringBuilder& sw,
    [[maybe_unused]] bool hide_brackets,
    [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);
}

clients::client_test_service::v2_smth::post::Body Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<clients::client_test_service::v2_smth::post::Body>) {
  clients::client_test_service::v2_smth::post::Body result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PBody::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PBody::ParserLocalDomToType<To>::Convert(::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PBody::PBody()
{}

void PBody::Reset()
{
  state_ = State::kStart;
  result_ = {};
}

void PBody::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PBody::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PBody::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      SetResult(std::move(result_));
      break;
  }
}

std::string PBody::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PBody::GetPathItem() const { return key_; }
}

}

namespace v3_smth::get {

::clients::http::Headers Request::GetHeaders() const {
  ::clients::http::Headers headers(0);

  headers[::http::headers::kContentType] =
      ::http::content_type::kApplicationJson.ToString();

  return headers;
}

::http::Args Request::GetQuery() const {
  ::http::Args query(0);

  return query;
}

}

namespace v3_smth::post {

::clients::http::Headers Request::GetHeaders() const {
  ::clients::http::Headers headers(1);

  headers[::http::headers::kContentType] = "application/json";

  return headers;
}

::http::Args Request::GetQuery() const {
  ::http::Args query(1);

  return query;
}

std::string Request::GetBody() const {
  formats::json::StringBuilder sw;
  WriteToStream(body, sw);
  return sw.GetString();
}

formats::json::Value Serialize(
    [[maybe_unused]] const clients::client_test_service::v3_smth::post::Body&
        value, ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  return builder.ExtractValue();
}

void WriteToStream(
    [[maybe_unused]] const clients::client_test_service::v3_smth::post::Body&
        value, formats::json::StringBuilder& sw,
    [[maybe_unused]] bool hide_brackets,
    [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);
}

clients::client_test_service::v3_smth::post::Body Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<clients::client_test_service::v3_smth::post::Body>) {
  clients::client_test_service::v3_smth::post::Body result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PBody::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PBody::ParserLocalDomToType<To>::Convert(::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PBody::PBody()
{}

void PBody::Reset()
{
  state_ = State::kStart;
  result_ = {};
}

void PBody::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PBody::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PBody::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      SetResult(std::move(result_));
      break;
  }
}

std::string PBody::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PBody::GetPathItem() const { return key_; }
}

}

namespace root_::get {

::clients::http::Headers Request::GetHeaders() const {
  ::clients::http::Headers headers(2);

  headers[::http::headers::kContentType] =
      ::http::content_type::kApplicationJson.ToString();

  if (this->x_test_header) headers["X-Test-Header"] = *this->x_test_header;

  return headers;
}

::http::Args Request::GetQuery() const {
  ::http::Args query(2);

  if (this->secret) query["secret"] = *this->secret;

  return query;
}

}

namespace root_::post {

::clients::http::Headers Request::GetHeaders() const {
  ::clients::http::Headers headers(2);

  headers[::http::headers::kContentType] =
      ::http::content_type::kApplicationJson.ToString();

  if (this->x_test_header) headers["X-Test-Header"] = *this->x_test_header;

  return headers;
}

::http::Args Request::GetQuery() const {
  ::http::Args query(2);

  return query;
}

std::string Request::GetBody() const {
  formats::json::StringBuilder sw;
  WriteToStream(body, sw);
  return sw.GetString();
}

formats::json::Value Serialize(
    [[maybe_unused]] const clients::client_test_service::root_::post::Body&
        value, ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  if (value.array) builder.EmplaceNocheck("array", *value.array);
  builder.EmplaceNocheck("id", value.id);
  return builder.ExtractValue();
}

void WriteToStream(
    [[maybe_unused]] const clients::client_test_service::root_::post::Body&
        value, formats::json::StringBuilder& sw,
    [[maybe_unused]] bool hide_brackets,
    [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);

  if (!hide_field_name || std::strcmp(hide_field_name, "array"))
  {
    if (value.array)
    {
      sw.Key("array");

      WriteToStream(*value.array, sw);
    }
  }
  if (!hide_field_name || std::strcmp(hide_field_name, "id"))
  {
    sw.Key("id");

    WriteToStream(value.id, sw);
  }
}

clients::client_test_service::root_::post::Body Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<clients::client_test_service::root_::post::Body>) {
  clients::client_test_service::root_::post::Body result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.array = [](const formats::json::Value& array)
      -> ::std::optional<::std::vector<std::string>> {
    if (array.IsMissing() || array.IsNull()) return std::nullopt;

    std::vector<std::string> result;
    array.CheckArrayOrNull();
    result.reserve(array.GetSize());
    for (const auto& item : array) {
      result.insert(result.end(), item.As<std::string>());
    }

    if (!(1 <= result.size())) {
      auto msg = "incorrect size, must be 1 (limit) <= " +
                 std::to_string(result.size()) + " (value)";
      throw formats::json::Value::ParseException("Value of '" +
                                                 array.GetPath() + "': " + msg);
    }

    return ::codegen::impl::Convert<
        ::std::optional<::std::vector<std::string>>::value_type,
        std::vector<std::string>>(std::move(result));
  }(elem["array"]);
  result.id = [](const formats::json::Value& value) -> int {
    auto tmp = value.As<int>();

    if (!(0 <= tmp)) {
      auto msg = "out of bounds, must be 0 (limit) <= " + std::to_string(tmp) +
                 " (value)";
      throw formats::json::Value::ParseException("Value of '" +
                                                 value.GetPath() + "': " + msg);
    }

    return tmp;
  }(elem["id"])

      ;

  return result;
}

namespace parser {
template <class To>
template <class From>
To PBody::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PBody::ParserLocalDomToType<To>::Convert(::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PBody::PBody()
{
  null_array_.Subscribe(sink_array_);

  f_array_.Subscribe(sink_array_);

  f_id_.Subscribe(sink_id_);
}

void PBody::Reset()
{
  state_ = State::kStart;
  result_ = {};

  s_array_ = false;
  s_id_ = false;
}

void PBody::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PBody::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else if (key == "array") {
    s_array_ = true;
    f_array_.Reset();

    parser_state_->PushParser(null_array_.GetParser());
  }

  else if (key == "id") {
    s_id_ = true;
    f_id_.Reset();

    parser_state_->PushParser(f_id_.GetParser());
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PBody::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      if (!s_array_) {
        result_.array = {};
      }
      if (!s_id_) {
        throw ::formats::json::parser::InternalParseError(
            "missing required field 'id'");
      }

      SetResult(std::move(result_));
      break;
  }
}

std::string PBody::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PBody::GetPathItem() const { return key_; }
}

}

}
