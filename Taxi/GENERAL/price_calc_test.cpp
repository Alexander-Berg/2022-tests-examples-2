#include <gtest/gtest.h>

#include <unordered_map>

#include <build/scripts/c_templates/svnversion.h>
#include <library/cpp/string_utils/base64/base64.h>

#include <taxi/uservices/libraries/price-calc/bindings/c/lib/price_calc.h>

const uint8_t PRICE_1[] = {
    0x40, 0x5b, 0xc6, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08,
    0x67, 0x65, 0x6f, 0x61, 0x72, 0x65, 0x61, 0x31, 0x00, 0x00, 0x00, 0x01,
    0x40, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3f, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x40, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xb4, 0x7a, 0xe1,
    0x47, 0xae, 0x14, 0x7b, 0x00, 0x00, 0x00, 0x08, 0x67, 0x65, 0x6f, 0x61,
    0x72, 0x65, 0x61, 0x32, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3f, 0xe6, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x03,
    0x40, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x4e, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3f, 0xec, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcd,
    0x40, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x59, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3f, 0xe9, 0x99, 0x99, 0x99, 0x99, 0x99, 0x9a,
    0x40, 0x5b, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x5e, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3f, 0xe3, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
    0x00, 0x00, 0x00, 0x06, 0x73, 0x75, 0x62, 0x75, 0x72, 0x62, 0x00, 0x00,
    0x00, 0x02, 0x40, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x67,
    0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xd3, 0x33, 0x33, 0x33, 0x33,
    0x33, 0x33, 0x40, 0x67, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc9, 0x99, 0x99, 0x99, 0x99,
    0x99, 0x9a, 0x00, 0x00, 0x00, 0x00};

const uint8_t PRICE_2[] = {
    0x40, 0x5b, 0xc6, 0x66, 0x66, 0x66, 0x66, 0x66, 0x40, 0x89, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08,
    0x67, 0x65, 0x6f, 0x61, 0x72, 0x65, 0x61, 0x31, 0x00, 0x00, 0x00, 0x01,
    0x40, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3f, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x40, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xb4, 0x7a, 0xe1,
    0x47, 0xae, 0x14, 0x7b, 0x00, 0x00, 0x00, 0x08, 0x67, 0x65, 0x6f, 0x61,
    0x72, 0x65, 0x61, 0x32, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3f, 0xe6, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x03,
    0x40, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x4e, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3f, 0xec, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcd,
    0x40, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x59, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3f, 0xe9, 0x99, 0x99, 0x99, 0x99, 0x99, 0x9a,
    0x40, 0x5b, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x5e, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3f, 0xe3, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
    0x00, 0x00, 0x00, 0x06, 0x73, 0x75, 0x62, 0x75, 0x72, 0x62, 0x00, 0x00,
    0x00, 0x02, 0x40, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x67,
    0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xd3, 0x33, 0x33, 0x33, 0x33,
    0x33, 0x33, 0x40, 0x67, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc9, 0x99, 0x99, 0x99, 0x99,
    0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x40, 0x74, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x40, 0x97, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x40, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xdc, 0xcc, 0xcc, 0xcc, 0xcc,
    0xcc, 0xcd, 0x00, 0x00, 0x00, 0x01, 0x40, 0x2e, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xd5,
    0x1e, 0xb8, 0x51, 0xeb, 0x85, 0x1f};

const uint8_t PRICE_HELSINKI[] = {
    0x40, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08,
    0x68, 0x65, 0x6c, 0x73, 0x69, 0x6e, 0x6b, 0x69, 0x00, 0x00, 0x00, 0x01,
    0x40, 0x8f, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3f, 0x52, 0x05, 0xbc, 0x01, 0xa3, 0x6e, 0x2f,
    0x00, 0x00, 0x00, 0x02, 0x40, 0x66, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x80, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x6b, 0x4e, 0x81,
    0xb4, 0xe8, 0x1b, 0x4f, 0x40, 0x80, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x77, 0xe4, 0xb1,
    0x7e, 0x4b, 0x17, 0xe4, 0x00, 0x00, 0x00, 0x06, 0x73, 0x75, 0x62, 0x75,
    0x72, 0x62, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x55,
    0x4c, 0x98, 0x5f, 0x06, 0xf6, 0x94, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x80, 0xe0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3f, 0x6b, 0x4e, 0x81, 0xb4, 0xe8, 0x1b, 0x4f, 0x40, 0x80,
    0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3f, 0x77, 0xe4, 0xb1, 0x7e, 0x4b, 0x17, 0xe4};

const uint8_t POLYGON_1[] = {
    0x00, 0x00, 0x00, 0x08, 0x67, 0x65, 0x6f, 0x61, 0x72, 0x65, 0x61, 0x32,
    0x00, 0x00, 0x00, 0x03, 0x40, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x24, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

const uint8_t POLYGON_2[] = {
    0x00, 0x00, 0x00, 0x08, 0x67, 0x65, 0x6f, 0x61, 0x72, 0x65, 0x61,
    0x31, 0x00, 0x00, 0x00, 0x04, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x22,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x40, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

const uint8_t POLYGON_HELSINKI[] = {
    0x00, 0x00, 0x00, 0x08, 0x68, 0x65, 0x6c, 0x73, 0x69, 0x6e, 0x6b, 0x69,
    0x00, 0x00, 0x00, 0x23, 0x40, 0x38, 0xa5, 0xbb, 0x5f, 0xf2, 0xef, 0x6c,
    0x40, 0x4e, 0x13, 0xb1, 0xea, 0xa7, 0x66, 0xf2, 0x40, 0x38, 0xa1, 0x2a,
    0xed, 0x1d, 0x4b, 0x4f, 0x40, 0x4e, 0x1d, 0x89, 0x4a, 0x49, 0x86, 0x96,
    0x40, 0x38, 0xc8, 0xbf, 0xaf, 0x4f, 0x05, 0x6d, 0x40, 0x4e, 0x1d, 0x8b,
    0xdd, 0x80, 0x71, 0x12, 0x40, 0x38, 0xd1, 0x91, 0x71, 0x80, 0xbf, 0x64,
    0x40, 0x4e, 0x1f, 0xce, 0x91, 0x2b, 0x39, 0x2f, 0x40, 0x38, 0xcd, 0x98,
    0xad, 0x1d, 0x4b, 0x5f, 0x40, 0x4e, 0x23, 0x74, 0x75, 0xf0, 0xba, 0x6e,
    0x40, 0x38, 0xdd, 0x66, 0x68, 0xb9, 0xd7, 0x65, 0x40, 0x4e, 0x25, 0xdb,
    0x4e, 0x61, 0x85, 0x3e, 0x40, 0x38, 0xe7, 0x95, 0x18, 0x8e, 0x6c, 0xc3,
    0x40, 0x4e, 0x1f, 0x9f, 0xc1, 0x45, 0xcb, 0x36, 0x40, 0x38, 0xe7, 0x2a,
    0xdf, 0xa1, 0xdc, 0x5e, 0x40, 0x4e, 0x1d, 0xff, 0xf8, 0xab, 0x74, 0xc9,
    0x40, 0x38, 0xe8, 0x99, 0x26, 0xb5, 0x4c, 0x15, 0x40, 0x4e, 0x1d, 0x61,
    0x6f, 0xc1, 0x1d, 0x5e, 0x40, 0x38, 0xe9, 0x1d, 0xaa, 0x3f, 0x03, 0xdd,
    0x40, 0x4e, 0x1c, 0x41, 0xb4, 0x05, 0x14, 0x7b, 0x40, 0x38, 0xe8, 0x67,
    0x2d, 0xc8, 0xbb, 0xb5, 0x40, 0x4e, 0x1b, 0x21, 0xe4, 0x7c, 0x9c, 0x26,
    0x40, 0x38, 0xea, 0x0d, 0x45, 0x3a, 0x90, 0xdd, 0x40, 0x4e, 0x18, 0x6e,
    0xa3, 0x25, 0x16, 0x29, 0x40, 0x38, 0xec, 0x23, 0xdc, 0xac, 0x66, 0x07,
    0x40, 0x4e, 0x18, 0xcb, 0x69, 0x20, 0xb3, 0x3a, 0x40, 0x38, 0xea, 0xcb,
    0x46, 0xa0, 0x74, 0xa1, 0x40, 0x4e, 0x1a, 0xde, 0xed, 0xe5, 0x9d, 0x70,
    0x40, 0x38, 0xec, 0x15, 0xb0, 0x94, 0x83, 0x53, 0x40, 0x4e, 0x1c, 0x98,
    0xa5, 0xe2, 0xe3, 0x7b, 0x40, 0x38, 0xe9, 0xa3, 0xda, 0x88, 0x91, 0xf7,
    0x40, 0x4e, 0x1f, 0x39, 0x11, 0xbe, 0xf6, 0x20, 0x40, 0x38, 0xeb, 0x45,
    0x25, 0x05, 0x95, 0x9a, 0x40, 0x4e, 0x20, 0xec, 0xbd, 0x23, 0xcd, 0x00,
    0x40, 0x38, 0xf1, 0xa5, 0x6f, 0x82, 0x99, 0x44, 0x40, 0x4e, 0x22, 0x9a,
    0xa4, 0x87, 0x12, 0xa7, 0x40, 0x38, 0xf5, 0xec, 0xc7, 0xec, 0x6d, 0x60,
    0x40, 0x4e, 0x24, 0x73, 0xeb, 0x27, 0x05, 0x81, 0x40, 0x38, 0xff, 0xc5,
    0xef, 0x2e, 0x91, 0xf8, 0x40, 0x4e, 0x26, 0xac, 0x27, 0x32, 0xe1, 0x23,
    0x40, 0x39, 0x00, 0x0a, 0x96, 0x70, 0xb6, 0x96, 0x40, 0x4e, 0x29, 0x48,
    0x84, 0x52, 0xfe, 0xe2, 0x40, 0x39, 0x0e, 0xb9, 0x3d, 0xb2, 0xdb, 0x37,
    0x40, 0x4e, 0x2c, 0x38, 0x18, 0x6a, 0x5f, 0x7e, 0x40, 0x39, 0x20, 0x37,
    0xe4, 0xf4, 0xff, 0xe2, 0x40, 0x4e, 0x2c, 0x15, 0x49, 0x26, 0x07, 0xef,
    0x40, 0x39, 0x16, 0xa0, 0xa5, 0xae, 0xf3, 0xaf, 0x40, 0x4e, 0x22, 0xbe,
    0x8d, 0x86, 0x3a, 0x87, 0x40, 0x39, 0x25, 0xf6, 0x7b, 0x6c, 0x6e, 0xdf,
    0x40, 0x4e, 0x1f, 0x76, 0x63, 0x28, 0xf4, 0x6f, 0x40, 0x39, 0x33, 0x03,
    0x51, 0x29, 0xea, 0x06, 0x40, 0x4e, 0x1b, 0xb2, 0x6c, 0xa9, 0x6a, 0x19,
    0x40, 0x39, 0x31, 0xa6, 0x1f, 0x5f, 0x04, 0x55, 0x40, 0x4e, 0x18, 0x90,
    0x7d, 0x5e, 0xcc, 0x51, 0x40, 0x39, 0x18, 0x4a, 0x41, 0x24, 0x5c, 0x87,
    0x40, 0x4e, 0x14, 0x71, 0xb6, 0x22, 0x16, 0x69, 0x40, 0x39, 0x0e, 0x7e,
    0x20, 0xbe, 0x8d, 0x96, 0x40, 0x4e, 0x14, 0x37, 0x64, 0x21, 0x1d, 0xf2,
    0x40, 0x38, 0xf8, 0x37, 0x00, 0x58, 0xbe, 0x83, 0x40, 0x4e, 0x14, 0x08,
    0x48, 0x7a, 0x20, 0x56, 0x40, 0x38, 0xec, 0xdd, 0xd8, 0x3f, 0x4a, 0xbb,
    0x40, 0x4e, 0x12, 0x79, 0x7f, 0xf3, 0x20, 0x86, 0x40, 0x38, 0xe4, 0x54,
    0xb0, 0x25, 0xd6, 0xfc, 0x40, 0x4e, 0x12, 0x7e, 0x8c, 0x2b, 0x30, 0x42,
    0x40, 0x38, 0xcb, 0x18, 0x88, 0x0c, 0x63, 0x37, 0x40, 0x4e, 0x13, 0x80,
    0x00, 0xff, 0x1d, 0xbb, 0x40, 0x38, 0xb4, 0x52, 0x5f, 0xf2, 0xef, 0x75,
    0x40, 0x4e, 0x12, 0x3a, 0x1a, 0xa3, 0x5f, 0x96, 0x40, 0x38, 0xa5, 0xbb,
    0x5f, 0xf2, 0xef, 0x6c, 0x40, 0x4e, 0x13, 0xb1, 0xea, 0xa7, 0x66, 0xf2,
    0x3f, 0xb0, 0x33, 0xbb, 0x77, 0xb0, 0x83, 0x9c};

/*
bytecode for:

return price * 0.9;
*/
const uint8_t BYTECODE_return_price_x_0_9[] = {
    0x13, 0x11, 0x3f, 0xec, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcd, 0x22, 0x80};

const uint8_t BYTECODE_with_emit[] = {0x13, 0x82, 0x00, 0x01, 0x15, 0x01,
                                      0x83, 0x00, 0x01, 0x15, 0x01, 0x80};

/*
bytecode for:

return {
    requirements = ("paid_option" in ride.ride.user_options)
                       ? ride.ride.user_options["paid_option"] * 42
                       : ride.price.requirements
    };
*/

const uint8_t BYTECODE_if_paid_option_in_user_options[] = {
    0x14, 0x00, 0x14, 0x01, 0x14, 0x02, 0x14, 0x03, 0x16, 0x00, 0x0b, 0x70,
    0x61, 0x69, 0x64, 0x5f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x05,
    0x90, 0x12, 0x05, 0x16, 0x00, 0x0b, 0x70, 0x61, 0x69, 0x64, 0x5f, 0x6f,
    0x70, 0x74, 0x69, 0x6f, 0x6e, 0x91, 0x11, 0x40, 0x45, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x22, 0x14, 0x04, 0x00, 0x14, 0x05, 0x14, 0x06, 0x81};

/*
bytecode to test user_meta:

let k = ("foo" in ride.ride.user_meta) ? ride.ride.user_meta["foo"] : 1.0;
if ("foo" in ride.ride.user_meta) {
  emit("foo", 2.0);
} else {
  emit("foo", 1.2);
}
return {boarding=k*ride.price.boarding};

*/
const std::string BYTECODE_check_user_meta = Base64Decode(
    "FgADZm9vEgaQEgYWAANmb2+RET/wAAAAAAAAAIIAABYAA2ZvbxIGkBYAA2ZvbxIGkBFAAAAAA"
    "AAAABE/8zMzMzMzMwAWAANmb28SBpARQAAAAAAAAAARP/MzMzMzMzMAAIMAAhYAA2ZvbxIGkB"
    "UAFAAiFQAUACIAFAEUAhQDFAQUBRQGgQ==");

namespace impl {
using BinaryData = std::vector<uint8_t>;

struct CalculateBaseTestData {
  const std::vector<MovementPoint> route;
  const std::vector<BinaryData> tariff_geoareas;
  const BinaryData category_prices;

  const CompositePrice expected_price;

  static std::vector<MovementPoint> GetRouteSimple();
  static std::vector<BinaryData> GetTariffGeoareasSimple();

  static std::vector<MovementPoint> GetRouteHelsinki();
  static std::vector<BinaryData> GetTariffGeoareasHelsinki();
};

}  // namespace impl

namespace {

class CalculateBaseTest
    : public ::testing::TestWithParam<impl::CalculateBaseTestData> {};

MovementPoints* ToMovementPoints(const std::vector<MovementPoint>& route) {
  auto res = CreateMovementPoints(route.size());
  if (res != nullptr) {
    for (size_t i = 0; i < route.size(); ++i) {
      const auto& point = route[i];
      res->points[i] =
          CreateMovementPoint(point.lon, point.lat, point.distance, point.time);
    }
  }
  return res;
}

Bytecode* ToBytecode(const impl::BinaryData& binary_data) {
  return CreateBytecode(binary_data.size(), &(*binary_data.begin()));
}

TariffGeoareas* ToTariffGeoareas(
    const std::vector<impl::BinaryData>& tariff_geoareas) {
  auto res = CreateTariffGeoareas(tariff_geoareas.size());
  if (res != nullptr) {
    for (size_t i = 0; i < tariff_geoareas.size(); ++i) {
      res->bytecodes[i] = ToBytecode(tariff_geoareas[i]);
    }
  }
  return res;
}

void ExpectEq(const CompositePrice& lhs, const CompositePrice& rhs) {
  EXPECT_DOUBLE_EQ(lhs.boarding, rhs.boarding);
  EXPECT_DOUBLE_EQ(lhs.distance, rhs.distance);
  EXPECT_DOUBLE_EQ(lhs.time, rhs.time);
  EXPECT_DOUBLE_EQ(lhs.waiting, rhs.waiting);
  EXPECT_DOUBLE_EQ(lhs.requirements, rhs.requirements);
  EXPECT_DOUBLE_EQ(lhs.transit_waiting, rhs.transit_waiting);
  EXPECT_DOUBLE_EQ(lhs.destination_waiting, rhs.destination_waiting);
}

}  // namespace

TEST_P(CalculateBaseTest, CalculateBase) {
  const auto& param = GetParam();

  auto route_ptr = ToMovementPoints(param.route);
  EXPECT_TRUE(route_ptr != nullptr);
  auto tariff_geoareas_ptr = ToTariffGeoareas(param.tariff_geoareas);
  EXPECT_TRUE(tariff_geoareas_ptr != nullptr);
  auto category_prices_ptr = ToBytecode(param.category_prices);
  EXPECT_TRUE(category_prices_ptr != nullptr);

  auto composite_price_ptr =
      CalculateBase(route_ptr, tariff_geoareas_ptr, category_prices_ptr);
  EXPECT_TRUE(composite_price_ptr != nullptr);

  ExpectEq(*composite_price_ptr, param.expected_price);

  FreeMovementPoints(route_ptr);
  FreeTariffGeoareas(tariff_geoareas_ptr);
  FreeBytecode(category_prices_ptr);
  FreeCompositePrice(composite_price_ptr);
}

INSTANTIATE_TEST_SUITE_P(
    CalculateBaseTest, CalculateBaseTest,
    ::testing::Values(
        impl::CalculateBaseTestData{
            impl::CalculateBaseTestData::GetRouteSimple(),
            impl::CalculateBaseTestData::GetTariffGeoareasSimple(),
            impl::BinaryData(PRICE_1,
                             PRICE_1 + (sizeof(PRICE_1) / sizeof(uint8_t))),
            {111.1, 154.75, 53.1, 0.0, 0.0, 0.0, 0.0}},
        impl::CalculateBaseTestData{
            impl::CalculateBaseTestData::GetRouteSimple(),
            impl::CalculateBaseTestData::GetTariffGeoareasSimple(),
            impl::BinaryData(PRICE_2,
                             PRICE_2 + (sizeof(PRICE_2) / sizeof(uint8_t))),
            {278.664367455714, 388.14861263520925, 133.18701990907664, 0.0, 0.0,
             0.0, 0.0}},
        impl::CalculateBaseTestData{
            impl::CalculateBaseTestData::GetRouteHelsinki(),
            impl::CalculateBaseTestData::GetTariffGeoareasHelsinki(),
            impl::BinaryData(PRICE_HELSINKI,
                             PRICE_HELSINKI +
                                 (sizeof(PRICE_HELSINKI) / sizeof(uint8_t))),
            {3.0, 1.1, 0.2, 0.0, 0.0, 0.0, 0.0}}));

namespace impl {

std::vector<MovementPoint> CalculateBaseTestData::GetRouteSimple() {
  return {{4.0, 6.0, 0.0, 0.0},     {5.0, 4.0, 30.0, 3.0},
          {7.0, 6.0, 60.0, 6.0},    {8.0, 5.0, 80.0, 8.0},
          {11.0, 5.0, 100.0, 10.0}, {10.0, 7.0, 150.0, 50.0},
          {8.0, 8.0, 160.0, 51.0},  {16.0, 7.0, 200.0, 80.0},
          {8.5, 5.5, 202.0, 83.0},  {3.0, 7.0, 275.0, 130.0},
          {7.0, 4.0, 400.0, 200.0}};
}

std::vector<BinaryData> CalculateBaseTestData::GetTariffGeoareasSimple() {
  return {
      BinaryData(POLYGON_1, POLYGON_1 + (sizeof(POLYGON_1) / sizeof(uint8_t))),
      BinaryData(POLYGON_2, POLYGON_2 + (sizeof(POLYGON_2) / sizeof(uint8_t)))};
}

std::vector<MovementPoint> CalculateBaseTestData::GetRouteHelsinki() {
  return {{24.935541, 60.162660, 0.0, 0.0},
          {24.935541, 60.162660, 2000.0, 240.0}};
}

std::vector<BinaryData> CalculateBaseTestData::GetTariffGeoareasHelsinki() {
  return {BinaryData(
      POLYGON_HELSINKI,
      POLYGON_HELSINKI + (sizeof(POLYGON_HELSINKI) / sizeof(uint8_t)))};
}

}  // namespace impl

namespace impl {

struct TripDetails {
  const double total_distance = 0.0;
  const int64_t total_time = 0;
  const int64_t waiting_time = 0;
  const int64_t waiting_in_transit_time = 0;
  const int64_t waiting_in_destination_time = 0;
  const std::unordered_map<std::string, double> user_options{};
};

struct RunInterpreterTestData {
  const CompositePrice user_input_price;
  const CompositePrice driver_input_price;
  const TripDetails trip_details;
  const BinaryData user_bytecode;
  const BinaryData driver_bytecode;
  const std::unordered_map<std::string, uint16_t> metadata_mapping;
  const double rounding_factor = 0.01;

  const CompositePrice expected_user_price;
  const std::unordered_map<uint16_t, double> expected_user_metadata;
  const CompositePrice expected_driver_price;
  const std::unordered_map<uint16_t, double> expected_driver_metadata;
};

}  // namespace impl

namespace {

class RunInterpreterTest
    : public ::testing::TestWithParam<impl::RunInterpreterTestData> {};

TripDetails* ToTripDetails(const impl::TripDetails& trip_details) {
  auto user_options = CreateUserOptions(trip_details.user_options.size());
  if (user_options != nullptr) {
    size_t i = 0;
    for (const auto& [key, value] : trip_details.user_options) {
      user_options->options[i++] = CreateUserOption(key.c_str(), value);
    }
  }
  auto res = CreateTripDetails(
      trip_details.total_distance, trip_details.total_time,
      trip_details.waiting_time, trip_details.waiting_in_transit_time,
      trip_details.waiting_in_destination_time, user_options);
  if (res == nullptr) {
    FreeUserOptions(user_options);
  }
  return res;
}

InterpreterInput* ToInterpreterInput(const CompositePrice& price,
                                     const impl::TripDetails& trip_details,
                                     const impl::BinaryData& bytecode) {
  auto price_ptr = CreateCompositePrice(
      price.boarding, price.distance, price.time, price.waiting,
      price.requirements, price.transit_waiting, price.destination_waiting);
  EXPECT_TRUE(price_ptr != nullptr);
  auto trip_details_ptr = ToTripDetails(trip_details);
  EXPECT_TRUE(trip_details_ptr != nullptr);
  auto bytecode_ptr = ToBytecode(bytecode);
  EXPECT_TRUE(bytecode_ptr != nullptr);

  return CreateInterpreterInput(price_ptr, trip_details_ptr, bytecode_ptr);
}

MetadataMapping* ToMetadataMapping(
    const std::unordered_map<std::string, uint16_t>& metadata_mapping) {
  auto res = CreateMetadataMapping(metadata_mapping.size());
  if (res != nullptr) {
    size_t i = 0;
    for (const auto& [key, id] : metadata_mapping) {
      res->mapped[i++] = CreateMetadataMapped(key.c_str(), id);
    }
  }
  return res;
}

std::unordered_map<uint16_t, double> FromMetadata(const Metadatas& metadata) {
  std::unordered_map<uint16_t, double> res;
  std::transform(metadata.metadatas, metadata.metadatas + metadata.size,
                 std::inserter(res, res.end()), [](const Metadata* item) {
                   EXPECT_TRUE(item != nullptr);
                   return std::make_pair(item->id, item->value);
                 });
  return res;
}

}  // namespace

TEST(Version, Version) {
  EXPECT_NE(std::string(), GetArcadiaLastChange());
  EXPECT_EQ(GetVersion(), GetArcadiaLastChange());
}

TEST_P(RunInterpreterTest, RunInterpreter) {
  const auto& param = GetParam();

  auto user_input_ptr = ToInterpreterInput(
      param.user_input_price, param.trip_details, param.user_bytecode);
  EXPECT_TRUE(user_input_ptr != nullptr);
  auto driver_input_ptr = ToInterpreterInput(
      param.driver_input_price, param.trip_details, param.driver_bytecode);
  EXPECT_TRUE(driver_input_ptr != nullptr);
  auto metadata_mapping_ptr = ToMetadataMapping(param.metadata_mapping);
  EXPECT_TRUE(metadata_mapping_ptr != nullptr);

  auto interpreter_res_ptr =
      RunInterpreter(user_input_ptr, driver_input_ptr, metadata_mapping_ptr,
                     param.rounding_factor);
  EXPECT_TRUE(interpreter_res_ptr != nullptr);
  EXPECT_TRUE(interpreter_res_ptr->user != nullptr);
  EXPECT_TRUE(interpreter_res_ptr->driver != nullptr);

  ExpectEq(*interpreter_res_ptr->user->price, param.expected_user_price);
  ExpectEq(*interpreter_res_ptr->driver->price, param.expected_driver_price);
  EXPECT_EQ(FromMetadata(*interpreter_res_ptr->user->metadatas),
            param.expected_user_metadata);
  EXPECT_EQ(FromMetadata(*interpreter_res_ptr->driver->metadatas),
            param.expected_driver_metadata);

  FreeInterpreterInput(user_input_ptr);
  FreeInterpreterInput(driver_input_ptr);
  FreeMetadataMapping(metadata_mapping_ptr);
  FreeInterpreterResults(interpreter_res_ptr);
}

INSTANTIATE_TEST_SUITE_P(
    RunInterpreterTest, RunInterpreterTest,
    ::testing::Values(
        impl::RunInterpreterTestData{
            {10.3, 543.2, 457.44, 78.0, 0.0, 0.0, 0.0},          //
            {10.3, 543.2, 457.44, 78.0, 0.0, 0.0, 0.0},          //
            {11203.0, 6053, 430, 0, 0, {{"paid_option", 3.0}}},  //
            impl::BinaryData(BYTECODE_return_price_x_0_9,        //
                             BYTECODE_return_price_x_0_9 +
                                 (sizeof(BYTECODE_return_price_x_0_9) /
                                  sizeof(uint8_t))),  //
            impl::BinaryData(
                BYTECODE_if_paid_option_in_user_options,  //
                BYTECODE_if_paid_option_in_user_options +
                    (sizeof(BYTECODE_if_paid_option_in_user_options) /
                     sizeof(uint8_t))),  //
            {{"paid_option", 0x01}},     //
            0.01,                        //
            {10.3 * 0.9, 543.2 * 0.9, 457.44 * 0.9, 78.0 * 0.9, 0.0, 0.0,
             0.0},                                            //
            {},                                               //
            {10.3, 543.2, 457.44, 78.0, 3 * 42.0, 0.0, 0.0},  //
            {}                                                //
        },                                                    //
        impl::RunInterpreterTestData{
            {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0},    //
            {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0},    //
            {2800, 1, 1, 0, 0, {{"u_opt1", 0.1}}},  //
            impl::BinaryData(BYTECODE_with_emit,    //
                             BYTECODE_with_emit + sizeof(BYTECODE_with_emit) /
                                                      sizeof(uint8_t)),  //
            impl::BinaryData(BYTECODE_with_emit,                         //
                             BYTECODE_with_emit + sizeof(BYTECODE_with_emit) /
                                                      sizeof(uint8_t)),  //
            {{"u_opt1", 0x01}},                                          //
            0.01,                                                        //
            {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0},                         //
            {{0x01, 28.0}},                                              //
            {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0},                         //
            {{0x01, 28.0}}                                               //
        },                                                               //
        impl::RunInterpreterTestData{
            {10.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},               //
            {10.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},               //
            {2800, 1, 1, 0, 0, {}},                             //
            impl::BinaryData(BYTECODE_check_user_meta.begin(),  //
                             BYTECODE_check_user_meta.end()),   //
            impl::BinaryData(BYTECODE_check_user_meta.begin(),  //
                             BYTECODE_check_user_meta.end()),   //
            {{"foo", 0x02}},                                    //
            1.0,                                                //
            {10.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},               //
            {{0x02, 1.2}},                                      //
            {12.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},               //
            {{0x02, 2.0}}                                       //
        }                                                       //
        ));
