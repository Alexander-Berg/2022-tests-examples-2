# pylint: disable=too-many-lines
# pylint: disable=invalid-string-quote
# pylint: disable=wildcard-import
# pylint: disable=ungrouped-imports
# pylint: disable=unused-wildcard-import
# pylint: disable=redefined-builtin
# pylint: disable=unused-variable
# pylint: disable=redefined-outer-name
# pylint: disable=invalid-name
# pylint: disable=unnecessary-lambda

# pylint: disable=bad-whitespace
# flake8: noqa

import datetime
import json
import orjson
import re
import typing
import uuid as uuid_module

from taxi.codegen import swaggen_serialization as utils
from taxi.util import dates as dates_utils
import logging

from aiohttp import web


from example_service.generated.web import middlewares_context as middlewares_module

logger = logging.getLogger(__name__)

class _AllOfTestAdditionalPropertiesLeakPostBody0Inner:
    """ 

    Autogenerated. Do not edit the class manually.
    """
    __slots__: typing.Tuple[str, ...] = (
        '_name',
    )
    _use_py3_isoformat: bool = True

    _name: typing.Optional[str]

    def __init__(
        self,
        name: typing.Union[typing.Optional[str], utils.Sentinel] = utils.SENTINEL,
    ) -> None:
        """Autogenerated."""
        use_py3_isoformat = self._use_py3_isoformat

        if isinstance(name, utils.Sentinel):
            self.name = None
        else:
            self.name = name

    @classmethod
    def deserialize(
            cls,
            data: dict,
            *,
            allow_extra: bool = False,
            use_py3_isoformat: bool = False,
    ) -> '_AllOfTestAdditionalPropertiesLeakPostBody0Inner':
        if not isinstance(data, dict):
            raise utils.ValidationError(
                'Invalid value to deserialize _AllOfTestAdditionalPropertiesLeakPostBody0Inner: '
                '%.1024r is not instance of dict' % data,
            )
        data = data.copy()
        use_py3_isoformat = use_py3_isoformat or cls._use_py3_isoformat
        name_ = data.pop('name', utils.SENTINEL)
        if data and not allow_extra:
            raise utils.ValidationError(
                'Unexpected fields: %s' % list(data.keys()),
            )

        return cls(
            name=name_,
        )

    def serialize(self, use_py3_isoformat: bool = False) -> dict:
        self.validate_mutable_fields()
        use_py3_isoformat = use_py3_isoformat or self._use_py3_isoformat
        data: typing.Dict[str, typing.Any] = {
        }
        if self._name is not None:
            data['name'] = self._name
        return data

    def validate_mutable_fields(self) -> None:
        """Validate fields that can be changed bypassing calling setters."""

    @property
    def name(self) -> typing.Optional[str]:
        return self._name

    @name.setter
    def name(self, value: typing.Optional[str]) -> None:
        if value is None or value is utils.SENTINEL:
            self._name = None
            return
        if not isinstance(value, str):
            raise utils.ValidationError(
                'Invalid value for name: '
                '%.1024r is not instance of str' % value,
            )


        self._name = value

    def __repr__(self) -> str:
        return (
            '_AllOfTestAdditionalPropertiesLeakPostBody0Inner('
            'name=%r'
            ')' % (
                self.name,
            )
        )

    def __eq__(self, other) -> bool:
        return (
            isinstance(other, _AllOfTestAdditionalPropertiesLeakPostBody0Inner) and
            self.name == other.name
        )

    def __hash__(self) -> int:
        return hash((
            self.name
        ))


class AllOfTestAdditionalPropertiesLeakPostBody:
    """ 

    Autogenerated. Do not edit the class manually.
    """
    __slots__: typing.Tuple[str, ...] = (
        '_inner',
    )
    _use_py3_isoformat: bool = True
    Inner = _AllOfTestAdditionalPropertiesLeakPostBody0Inner

    _inner: '_AllOfTestAdditionalPropertiesLeakPostBody0Inner'

    def __init__(
        self,
        inner: '_AllOfTestAdditionalPropertiesLeakPostBody0Inner',
    ) -> None:
        """Autogenerated."""
        use_py3_isoformat = self._use_py3_isoformat
        self.inner = inner

    @classmethod
    def deserialize(
            cls,
            data: dict,
            *,
            allow_extra: bool = False,
            use_py3_isoformat: bool = False,
    ) -> 'AllOfTestAdditionalPropertiesLeakPostBody':
        if not isinstance(data, dict):
            raise utils.ValidationError(
                'Invalid value to deserialize AllOfTestAdditionalPropertiesLeakPostBody: '
                '%.1024r is not instance of dict' % data,
            )
        data = data.copy()
        use_py3_isoformat = use_py3_isoformat or cls._use_py3_isoformat
        inner_ = data.pop('inner', utils.SENTINEL)
        if inner_ not in (utils.SENTINEL, None):
            inner_ = _AllOfTestAdditionalPropertiesLeakPostBody0Inner.deserialize(
                inner_,
                allow_extra=allow_extra,
                use_py3_isoformat=use_py3_isoformat,
            )
        return cls(
            inner=inner_,
        )

    def serialize(self, use_py3_isoformat: bool = False) -> dict:
        self.validate_mutable_fields()
        use_py3_isoformat = use_py3_isoformat or self._use_py3_isoformat
        data: typing.Dict[str, typing.Any] = {
            'inner': self._inner.serialize(
                use_py3_isoformat=use_py3_isoformat,
            ),
        }
        return data

    def validate_mutable_fields(self) -> None:
        """Validate fields that can be changed bypassing calling setters."""

    @property
    def inner(self) -> '_AllOfTestAdditionalPropertiesLeakPostBody0Inner':
        return self._inner

    @inner.setter
    def inner(self, value: '_AllOfTestAdditionalPropertiesLeakPostBody0Inner') -> None:
        if value is None or value is utils.SENTINEL:
            raise utils.ValidationError(
                'inner is required property',
            )
        if not isinstance(value, _AllOfTestAdditionalPropertiesLeakPostBody0Inner):
            raise utils.ValidationError(
                'Invalid value for inner: '
                '%.1024r is not instance of _AllOfTestAdditionalPropertiesLeakPostBody0Inner' % value,
            )


        self._inner = value

    def __repr__(self) -> str:
        return (
            'AllOfTestAdditionalPropertiesLeakPostBody('
            'inner=%r'
            ')' % (
                self.inner,
            )
        )

    def __eq__(self, other) -> bool:
        return (
            isinstance(other, AllOfTestAdditionalPropertiesLeakPostBody) and
            self.inner == other.inner
        )

    def __hash__(self) -> int:
        return hash((
            utils.generic_hash(self.inner)
        ))


class AllOfTestAdditionalPropertiesLeakPost:
    log_extra: dict
    middlewares: middlewares_module.Middlewares
    body: 'AllOfTestAdditionalPropertiesLeakPostBody'
    _use_py3_isoformat: bool = True

    def __init__(
        self,
        log_extra,
        middlewares,
        body,
    ) -> None:
        self.log_extra = log_extra
        self.middlewares = middlewares
        self.body = body

    @classmethod
    async def create(cls, request: web.Request) -> 'AllOfTestAdditionalPropertiesLeakPost':
        use_py3_isoformat: bool = cls._use_py3_isoformat
        body = await request.read()
        if not body:
            raise utils.ValidationError(
                'body is required'
            )
        else:
            allow_extra: bool = True
            try:
                data = orjson.loads(body)
                request['raw_body'] = data

            except orjson.JSONDecodeError as exc:
                logger.warning(
                    'Failed to decode json: %s',
                    exc,
                    extra=request.get('log_extra'),
                )
                raise utils.ValidationError(
                    'Failed to decode json'
                ) from None
            else:
                body_ = AllOfTestAdditionalPropertiesLeakPostBody.deserialize(
                    data,
                    allow_extra=allow_extra,
                    use_py3_isoformat=use_py3_isoformat,
                )
            
        return cls(
            request['log_extra'],
            request['_middlewares'],
            body_,
        )
