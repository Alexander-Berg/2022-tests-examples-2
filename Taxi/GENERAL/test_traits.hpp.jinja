#pragma once

#include <geobus/test/comparison_precision.hpp>
#include "lowlevel.hpp"
#include <test/data_type_test_traits.hpp>
#include <types/data_type_traits.hpp>
#include <channels/{{channel_dir}}/traits.hpp>

namespace geobus::test {

/// Traits for {{cpp_name}}
template <>
struct DataTypeTestTraits<types::{{name}}>
    : public types::DataTypeTraits<types::{{name}}> {
  using Base = types::DataTypeTraits<types::{{name}}>;
  using typename Base::Element;
  using typename Base::Elements;
  using typename Base::Generator;
  using typename Base::Span;
  using typename Base::ParseInvalidStats;
  using typename Base::Payload;
  using typename Base::RandomGenerator;

  template <typename Iterator>
  static void TestElementsAreEqual(
      Iterator start1, Iterator end1, Iterator start2, Iterator end2,
      [[maybe_unused]] test::ComparisonPrecision requestedPrecision =
          test::ComparisonPrecision::FullPrecision);
};

template <typename Iterator>
void DataTypeTestTraits<types::{{name}}>::TestElementsAreEqual(
    Iterator start1, Iterator end1, Iterator start2, Iterator end2,
    [[maybe_unused]] test::ComparisonPrecision requestedPrecision) {
    static_assert(false, "Implement it");

    /* Example
  SCOPED_TRACE(__FUNCTION__);
  using namespace ::testing;
  for (size_t iteration = 0; start1 != end1 && start2 != end2;
       ++start1, ++start2, ++iteration) {
    SCOPED_TRACE(std::string("element: ") + std::to_string(iteration));
    TestMultiPositionsAreEqual(*start1, *start2, requestedPrecision);
  }

  EXPECT_EQ((start1 == end1), (start2 == end2));
  */
}
}  // namespace geobus::test
