# pylint: disable=too-many-lines
# pylint: disable=invalid-string-quote
# pylint: disable=wildcard-import
# pylint: disable=ungrouped-imports
# pylint: disable=unused-wildcard-import
# pylint: disable=redefined-builtin
# pylint: disable=unused-variable
# pylint: disable=redefined-outer-name
# pylint: disable=invalid-name
# pylint: disable=unnecessary-lambda

# pylint: disable=bad-whitespace
# flake8: noqa

import datetime
import json
import orjson
import re
import typing
import uuid as uuid_module

from taxi.codegen import swaggen_serialization as utils
from taxi.util import dates as dates_utils

from aiohttp import web
import multidict

import example_service.generated.service.swagger.models.api as api_module

class _AllOfTestComplexInlineResponsePostResponse200Inline1Day:
    """ 

    Autogenerated. Do not edit the class manually.
    """
    __slots__: typing.Tuple[str, ...] = (
        '_number',
        '_week',
    )
    _use_py3_isoformat: bool = True

    _number: int
    _week: str

    def __init__(
        self,
        number: int,
        week: str,
    ) -> None:
        """Autogenerated."""
        use_py3_isoformat = self._use_py3_isoformat
        self.number = number
        self.week = week

    @classmethod
    def deserialize(
            cls,
            data: dict,
            *,
            allow_extra: bool = False,
            use_py3_isoformat: bool = False,
    ) -> '_AllOfTestComplexInlineResponsePostResponse200Inline1Day':
        if not isinstance(data, dict):
            raise utils.ValidationError(
                'Invalid value to deserialize _AllOfTestComplexInlineResponsePostResponse200Inline1Day: '
                '%.1024r is not instance of dict' % data,
            )
        data = data.copy()
        use_py3_isoformat = use_py3_isoformat or cls._use_py3_isoformat
        number_ = data.pop('number', utils.SENTINEL)
        week_ = data.pop('week', utils.SENTINEL)
        return cls(
            number=number_,
            week=week_,
        )

    def serialize(self, use_py3_isoformat: bool = False) -> dict:
        self.validate_mutable_fields()
        use_py3_isoformat = use_py3_isoformat or self._use_py3_isoformat
        data: typing.Dict[str, typing.Any] = {
            'number': self._number,
            'week': self._week,
        }
        return data

    def validate_mutable_fields(self) -> None:
        """Validate fields that can be changed bypassing calling setters."""

    @property
    def number(self) -> int:
        return self._number

    @number.setter
    def number(self, value: int) -> None:
        if value is None or value is utils.SENTINEL:
            raise utils.ValidationError(
                'number is required property',
            )
        if not isinstance(value, int) or isinstance(value, bool):
            raise utils.ValidationError(
                'Invalid value for number: '
                '%.1024r is not instance of int' % value,
            )


        self._number = value

    @property
    def week(self) -> str:
        return self._week

    @week.setter
    def week(self, value: str) -> None:
        if value is None or value is utils.SENTINEL:
            raise utils.ValidationError(
                'week is required property',
            )
        if not isinstance(value, str):
            raise utils.ValidationError(
                'Invalid value for week: '
                '%.1024r is not instance of str' % value,
            )


        self._week = value

    def __repr__(self) -> str:
        return (
            '_AllOfTestComplexInlineResponsePostResponse200Inline1Day('
            'number=%r'
            ', '
            'week=%r'
            ')' % (
                self.number,
                self.week,
            )
        )

    def __eq__(self, other) -> bool:
        return (
            isinstance(other, _AllOfTestComplexInlineResponsePostResponse200Inline1Day) and
            self.number == other.number and 
            self.week == other.week
        )

    def __hash__(self) -> int:
        return hash((
            self.number, 
            self.week
        ))


class _AllOfTestComplexInlineResponsePostResponse200Inline:
    """ 

    Autogenerated. Do not edit the class manually.
    """
    __slots__: typing.Tuple[str, ...] = (
        '_age',
        '_name',
        '_day',
    )
    _use_py3_isoformat: bool = True
    Day = _AllOfTestComplexInlineResponsePostResponse200Inline1Day

    _age: int
    _name: str
    _day: '_AllOfTestComplexInlineResponsePostResponse200Inline1Day'

    def __init__(
        self,
        age: int,
        day: '_AllOfTestComplexInlineResponsePostResponse200Inline1Day',
        name: str,
    ) -> None:
        """Autogenerated."""
        use_py3_isoformat = self._use_py3_isoformat
        self.age = age
        self.day = day
        self.name = name

    @classmethod
    def deserialize(
            cls,
            data: dict,
            *,
            allow_extra: bool = False,
            use_py3_isoformat: bool = False,
    ) -> '_AllOfTestComplexInlineResponsePostResponse200Inline':
        if not isinstance(data, dict):
            raise utils.ValidationError(
                'Invalid value to deserialize _AllOfTestComplexInlineResponsePostResponse200Inline: '
                '%.1024r is not instance of dict' % data,
            )
        data = data.copy()
        use_py3_isoformat = use_py3_isoformat or cls._use_py3_isoformat
        age_ = data.pop('age', utils.SENTINEL)
        day_ = data.pop('day', utils.SENTINEL)
        if day_ not in (utils.SENTINEL, None):
            day_ = _AllOfTestComplexInlineResponsePostResponse200Inline1Day.deserialize(
                day_,
                allow_extra=allow_extra,
                use_py3_isoformat=use_py3_isoformat,
            )
        name_ = data.pop('name', utils.SENTINEL)
        return cls(
            age=age_,
            name=name_,
            day=day_,
        )

    def serialize(self, use_py3_isoformat: bool = False) -> dict:
        self.validate_mutable_fields()
        use_py3_isoformat = use_py3_isoformat or self._use_py3_isoformat
        data: typing.Dict[str, typing.Any] = {
            'age': self._age,
            'name': self._name,
            'day': self._day.serialize(
                use_py3_isoformat=use_py3_isoformat,
            ),
        }
        return data

    def validate_mutable_fields(self) -> None:
        """Validate fields that can be changed bypassing calling setters."""

    @property
    def age(self) -> int:
        return self._age

    @age.setter
    def age(self, value: int) -> None:
        if value is None or value is utils.SENTINEL:
            raise utils.ValidationError(
                'age is required property',
            )
        if not isinstance(value, int) or isinstance(value, bool):
            raise utils.ValidationError(
                'Invalid value for age: '
                '%.1024r is not instance of int' % value,
            )


        self._age = value

    @property
    def name(self) -> str:
        return self._name

    @name.setter
    def name(self, value: str) -> None:
        if value is None or value is utils.SENTINEL:
            raise utils.ValidationError(
                'name is required property',
            )
        if not isinstance(value, str):
            raise utils.ValidationError(
                'Invalid value for name: '
                '%.1024r is not instance of str' % value,
            )


        self._name = value

    @property
    def day(self) -> '_AllOfTestComplexInlineResponsePostResponse200Inline1Day':
        return self._day

    @day.setter
    def day(self, value: '_AllOfTestComplexInlineResponsePostResponse200Inline1Day') -> None:
        if value is None or value is utils.SENTINEL:
            raise utils.ValidationError(
                'day is required property',
            )
        if not isinstance(value, _AllOfTestComplexInlineResponsePostResponse200Inline1Day):
            raise utils.ValidationError(
                'Invalid value for day: '
                '%.1024r is not instance of _AllOfTestComplexInlineResponsePostResponse200Inline1Day' % value,
            )


        self._day = value

    def __repr__(self) -> str:
        return (
            '_AllOfTestComplexInlineResponsePostResponse200Inline('
            'age=%r'
            ', '
            'name=%r'
            ', '
            'day=%r'
            ')' % (
                self.age,
                self.name,
                self.day,
            )
        )

    def __eq__(self, other) -> bool:
        return (
            isinstance(other, _AllOfTestComplexInlineResponsePostResponse200Inline) and
            self.age == other.age and 
            self.name == other.name and 
            self.day == other.day
        )

    def __hash__(self) -> int:
        return hash((
            self.age, 
            self.name, 
            utils.generic_hash(self.day)
        ))




class AllOfTestComplexInlineResponsePostResponse200:
    """ 

    Autogenerated. Do not edit the class manually.
    """
    __slots__: typing.Tuple[str, ...] = (
        '_inline',
    )
    _use_py3_isoformat: bool = True

    _inline: '_AllOfTestComplexInlineResponsePostResponse200Inline'

    def __init__(
        self,
        inline: '_AllOfTestComplexInlineResponsePostResponse200Inline',
    ) -> None:
        """Autogenerated."""
        use_py3_isoformat = self._use_py3_isoformat
        self.inline = inline

    @classmethod
    def deserialize(
            cls,
            data: dict,
            *,
            allow_extra: bool = False,
            use_py3_isoformat: bool = False,
    ) -> 'AllOfTestComplexInlineResponsePostResponse200':
        if not isinstance(data, dict):
            raise utils.ValidationError(
                'Invalid value to deserialize AllOfTestComplexInlineResponsePostResponse200: '
                '%.1024r is not instance of dict' % data,
            )
        data = data.copy()
        use_py3_isoformat = use_py3_isoformat or cls._use_py3_isoformat
        inline_ = data.pop('inline', utils.SENTINEL)
        if inline_ not in (utils.SENTINEL, None):
            inline_ = _AllOfTestComplexInlineResponsePostResponse200Inline.deserialize(
                inline_,
                allow_extra=allow_extra,
                use_py3_isoformat=use_py3_isoformat,
            )
        if data and not allow_extra:
            raise utils.ValidationError(
                'Unexpected fields: %s' % list(data.keys()),
            )

        return cls(
            inline=inline_,
        )

    def serialize(self, use_py3_isoformat: bool = False) -> dict:
        self.validate_mutable_fields()
        use_py3_isoformat = use_py3_isoformat or self._use_py3_isoformat
        data: typing.Dict[str, typing.Any] = {
            'inline': self._inline.serialize(
                use_py3_isoformat=use_py3_isoformat,
            ),
        }
        return data

    def validate_mutable_fields(self) -> None:
        """Validate fields that can be changed bypassing calling setters."""

    @property
    def inline(self) -> '_AllOfTestComplexInlineResponsePostResponse200Inline':
        return self._inline

    @inline.setter
    def inline(self, value: '_AllOfTestComplexInlineResponsePostResponse200Inline') -> None:
        if value is None or value is utils.SENTINEL:
            raise utils.ValidationError(
                'inline is required property',
            )
        if not isinstance(value, _AllOfTestComplexInlineResponsePostResponse200Inline):
            raise utils.ValidationError(
                'Invalid value for inline: '
                '%.1024r is not instance of _AllOfTestComplexInlineResponsePostResponse200Inline' % value,
            )


        self._inline = value

    def __repr__(self) -> str:
        return (
            'AllOfTestComplexInlineResponsePostResponse200('
            'inline=%r'
            ')' % (
                self.inline,
            )
        )

    def __eq__(self, other) -> bool:
        return (
            isinstance(other, AllOfTestComplexInlineResponsePostResponse200) and
            self.inline == other.inline
        )

    def __hash__(self) -> int:
        return hash((
            utils.generic_hash(self.inline)
        ))

    # inline models
    Inline = _AllOfTestComplexInlineResponsePostResponse200Inline


class AllOfTestComplexInlineResponsePost200:
    Body = AllOfTestComplexInlineResponsePostResponse200
    _use_py3_isoformat: bool = True

    @property
    def status(self):
        return 200

    def __init__(
        self,
        data: 'AllOfTestComplexInlineResponsePostResponse200',
    ) -> None:
        super().__init__()
        self._data = data
        self._json: typing.Union[None, typing.List, typing.Dict] = None
        self._dumped_data: typing.Union[None, str, bytes, bytearray] = None
        self._content_type = 'application/json; charset=utf-8'

    def serialize(self) -> web.Response:
        use_py3_isoformat: bool = self._use_py3_isoformat
        serialized_data_ = self.data
        if not isinstance(serialized_data_, AllOfTestComplexInlineResponsePostResponse200):
            raise utils.ValidationError(
                'Invalid value for body: '
                '%.1024r is not instance of AllOfTestComplexInlineResponsePostResponse200' % serialized_data_,
            )


        serialized_data = serialized_data_.serialize(
            use_py3_isoformat=use_py3_isoformat,
        )
        self._json = serialized_data
        self._dumped_data = orjson.dumps(serialized_data)
        formatted_headers: multidict.CIMultiDict = multidict.CIMultiDict({
            'Content-Type': self._content_type,
        })
        return web.Response(
            status=self.status,
            headers=formatted_headers,
            body=self._dumped_data,
        )


    @property
    def json_data(self):
        return self._json


    @property
    def dumped_data(self):
        return self._dumped_data


    @property
    def data(self):
        return self._data


    @property
    def content_type(self):
        return self._content_type
