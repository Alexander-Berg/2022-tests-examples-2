#ifndef USERVER_CODEGEN_IPP_INSTANTIATION_GUARD
#error DO NOT INCLUDE THIS FILE! INCLUDE THE FILE WITH *.hpp EXTENSION!
#endif

/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s):
// taxi/uservices/services/test-service/docs/yaml/api/api.yaml,
// taxi/uservices/services/test-service/docs/yaml/api/openapi.yaml

#include <handlers/handler/post/request.hpp>

#include <codegen/impl/convert.hpp>
#include <codegen/impl/get_validation_length.hpp>
#include <codegen/impl/optional_convert.hpp>
#include <codegen/impl/parsers.hpp>
#include <cstring>
#include <unordered_set>
#include <userver/formats/common/meta.hpp>
#include <userver/formats/json/string_builder.hpp>
#include <userver/logging/log.hpp>
#include <userver/utils/assert.hpp>
#include <userver/utils/datetime/from_string_saturating.hpp>
#include <userver/utils/underlying_value.hpp>

#include <codegen/impl/convert.hpp>

#include <boost/algorithm/string/join.hpp>
#include <boost/uuid/uuid_io.hpp>
#include <codegen/impl/convert.hpp>
#include <codegen/impl/parsers.hpp>
#include <userver/utils/datetime/from_string_saturating.hpp>

#include <userver/formats/json/serialize.hpp>
#include <userver/formats/json/value.hpp>
#include <userver/http/common_headers.hpp>
#include <userver/http/content_type.hpp>
#include <userver/server/handlers/exceptions.hpp>
#include <userver/server/http/http_request.hpp>
#include <userver/tracing/span.hpp>
#include <userver/utils/assert.hpp>

#include <codegen/impl/split_by.hpp>
#include <codegen/prepare_json.hpp>
#include <userver/formats/parse/common_containers.hpp>

namespace handlers::handler::post {

Request::Request([[maybe_unused]] const server::http::HttpRequest& http_request,
                 [[maybe_unused]] ::server::request::RequestContext& context)
{
  this->body = http_request.RequestBody();

  static const http::ContentType kAllowedContentType[] = {
      "application/flatbuffer",
  };
  try {
    const http::ContentType request_content_type =
        http_request.GetHeader(http::headers::kContentType);
    if (std::find_if(
            std::begin(kAllowedContentType), std::end(kAllowedContentType),
            [&request_content_type](const http::ContentType& allowed_range) {
              return allowed_range.DoesAccept(request_content_type);
            }) == std::end(kAllowedContentType)) {
      auto msg = std::string("Invalid ") + http::headers::kContentType +
                 ", must be one of ['application/flatbuffer'], got '" +
                 request_content_type.ToString() + "'";
      throw server::handlers::ClientError(
          server::handlers::ExternalBody{msg},
          server::handlers::InternalMessage{msg});
    }
  } catch (const http::MalformedContentType& ex) {
    throw server::handlers::ClientError(
        server::handlers::ExternalBody{std::string("Malformed ") +
                                       http::headers::kContentType},
        server::handlers::InternalMessage{ex.what()});
  }
}

void Request::SetSpanTags() const {}

}
