
/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s):
// taxi/uservices/services/test-service/docs/yaml/api/api.yaml,
// taxi/uservices/services/test-service/docs/yaml/api/openapi.yaml

#pragma once

#include <variant>

#include <array>
#include <boost/type_traits/has_equal_to.hpp>
#include <codegen/convert_to_json_optional.hpp>
#include <codegen/format.hpp>
#include <codegen/parsing_flags.hpp>
#include <userver/formats/json/inline.hpp>
#include <userver/formats/json/serialize_container.hpp>
#include <userver/formats/json/string_builder_fwd.hpp>
#include <userver/formats/json/value.hpp>
#include <userver/formats/json/value_builder.hpp>
#include <userver/logging/log_helper_fwd.hpp>
#include <userver/server/http/http_response.hpp>

#include <codegen/parser/datetime_parser.hpp>
#include <codegen/parser/dummy_parser.hpp>  // TODO: for debug only
#include <codegen/parser/enum_parser.hpp>
#include <codegen/parser/extra_helper.hpp>
#include <codegen/parser/null_swallow.hpp>
#include <codegen/parser/nullable_helper.hpp>
#include <codegen/parser/parser_converter.hpp>
#include <codegen/parser/parser_dom.hpp>
#include <codegen/parser/parser_empty.hpp>
#include <codegen/parser/parser_non_null_ptr.hpp>
#include <codegen/parser/validator.hpp>
#include <codegen/parser/value_builder_helper.hpp>
#include <userver/formats/json/parser/parser.hpp>

#include <array>
#include <boost/type_traits/has_equal_to.hpp>
#include <codegen/convert_to_json_optional.hpp>
#include <codegen/format.hpp>
#include <codegen/parsing_flags.hpp>
#include <userver/formats/json/inline.hpp>
#include <userver/formats/json/string_builder_fwd.hpp>
#include <userver/formats/json/value_builder.hpp>
#include <userver/logging/log_helper_fwd.hpp>

#include <defs/api/api.hpp>
#include <optional>
#include <string>
#include <vector>

namespace handlers::v1_run::post {

/// In place schema object for success response
struct Response200 {
  ::std::vector<handlers::Response> discounts;
};

::formats::json::Value Serialize(
    const Response200& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const Response200& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

Response200 Parse(const formats::json::Value& elem,
                  formats::parse::To<Response200>);

namespace parser {
class PResponse200 final: public ::formats::json::parser::TypedParser<
                              handlers::v1_run::post::Response200> {
 public:
  PResponse200();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  handlers::v1_run::post::Response200 result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  // discounts
  // .cpp_type: handlers::Response
  // .optional_subtype: None
  // cpp_type: handlers::Response
  handlers::parser::PResponse f_discounts_i_;

  ::formats::json::parser::ArrayParser<handlers::Response,
                                       decltype(f_discounts_i_),
                                       std::vector<handlers::Response>>
      f_discounts_{f_discounts_i_};

  ::formats::json::parser::SubscriberSink<std::vector<handlers::Response>>
      sink_discounts_{result_.discounts};

  bool s_discounts_{false};

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

void FillHttpResponse(::server::http::HttpResponse& http_response,
                      const Response200& response);

/// Strong typedef for a handlers::BadRequest
struct Response400: public std::exception, public handlers::BadRequest {
  Response400() = default;
  explicit Response400(handlers::BadRequest other)
      : handlers::BadRequest(std::move(other)) {}
};

template <typename StringBuilder>
void WriteToStream(const Response400& value, StringBuilder& sw) {
  WriteToStream(static_cast<const handlers::BadRequest&>(value), sw);
}

void FillHttpResponse(::server::http::HttpResponse& http_response,
                      const Response400& response);

using Response = std::variant<Response200, Response400>;

void FillHttpResponse(::server::http::HttpResponse& http_response,
                      const Response& response);

std::string ToString(const Response& response);

}
