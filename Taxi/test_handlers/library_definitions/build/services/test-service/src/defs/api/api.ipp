#ifndef USERVER_CODEGEN_IPP_INSTANTIATION_GUARD
#error DO NOT INCLUDE THIS FILE! INCLUDE THE FILE WITH *.hpp EXTENSION!
#endif

/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s): api.yaml

#include <defs/api/api.hpp>

#include <userver/formats/json/value_builder.hpp>
#include <userver/formats/parse/common_containers.hpp>
#include <userver/formats/parse/variant.hpp>

#include <codegen/impl/convert.hpp>
#include <codegen/impl/get_validation_length.hpp>
#include <codegen/impl/optional_convert.hpp>
#include <codegen/impl/parsers.hpp>
#include <cstring>
#include <unordered_set>
#include <userver/formats/common/meta.hpp>
#include <userver/formats/json/string_builder.hpp>
#include <userver/logging/log.hpp>
#include <userver/utils/assert.hpp>
#include <userver/utils/datetime/from_string_saturating.hpp>
#include <userver/utils/underlying_value.hpp>

#include <codegen/impl/convert.hpp>

namespace handlers {

handlers::Response Parse([[maybe_unused]] const formats::json::Value& elem,
                         formats::parse::To<handlers::Response>) {
  return handlers::Response{Parse(
      elem, formats::parse::To<handlers::libraries::new_lib::NewExtra>())};
}

formats::json::Value Serialize([[maybe_unused]] const handlers::Response& value,
                               ::formats::serialize::To<formats::json::Value>)
{
  return formats::json::ValueBuilder(
             static_cast<const handlers::libraries::new_lib::NewExtra&>(value))
      .ExtractValue();
}

void WriteToStream([[maybe_unused]] const handlers::Response& value,
                   formats::json::StringBuilder& sw)
{
  WriteToStream(
      static_cast<const handlers::libraries::new_lib::NewExtra&>(value), sw);
}

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const handlers::Response& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

handlers::Request Parse([[maybe_unused]] const formats::json::Value& elem,
                        formats::parse::To<handlers::Request>) {
  handlers::Request result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.data = elem["data"].As<std::optional<::std::string>>();
  result.id = elem["id"].As<double>();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PRequest::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PRequest::ParserLocalDomToType<To>::Convert(::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PRequest::PRequest()
{
  null_data_.Subscribe(sink_data_);

  f_data_.Subscribe(sink_data_);

  f_id_.Subscribe(sink_id_);
}

void PRequest::Reset()
{
  state_ = State::kStart;
  result_ = {};

  s_data_ = false;
  s_id_ = false;
}

void PRequest::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PRequest::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else if (key == "data") {
    s_data_ = true;
    f_data_.Reset();

    parser_state_->PushParser(null_data_.GetParser());
  }

  else if (key == "id") {
    s_id_ = true;
    f_id_.Reset();

    parser_state_->PushParser(f_id_.GetParser());
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PRequest::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      if (!s_data_) {
        result_.data = {};
      }
      if (!s_id_) {
        throw ::formats::json::parser::InternalParseError(
            "missing required field 'id'");
      }

      SetResult(std::move(result_));
      break;
  }
}

std::string PRequest::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PRequest::GetPathItem() const { return key_; }
}

formats::json::Value Serialize([[maybe_unused]] const handlers::Request& value,
                               ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  if (value.data) builder.EmplaceNocheck("data", *value.data);
  builder.EmplaceNocheck("id", value.id);
  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const handlers::Request& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);

  if (!hide_field_name || std::strcmp(hide_field_name, "data"))
  {
    if (value.data)
    {
      sw.Key("data");

      WriteToStream(*value.data, sw);
    }
  }
  if (!hide_field_name || std::strcmp(hide_field_name, "id"))
  {
    sw.Key("id");

    WriteToStream(value.id, sw);
  }
}

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const handlers::Request& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

handlers::BadRequest Parse([[maybe_unused]] const formats::json::Value& elem,
                           formats::parse::To<handlers::BadRequest>) {
  handlers::BadRequest result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.message = elem["message"].As<std::optional<::std::string>>();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PBadRequest::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PBadRequest::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PBadRequest::PBadRequest()
{
  null_message_.Subscribe(sink_message_);

  f_message_.Subscribe(sink_message_);
}

void PBadRequest::Reset()
{
  state_ = State::kStart;
  result_ = {};

  s_message_ = false;
}

void PBadRequest::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PBadRequest::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else if (key == "message") {
    s_message_ = true;
    f_message_.Reset();

    parser_state_->PushParser(null_message_.GetParser());
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PBadRequest::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      if (!s_message_) {
        result_.message = {};
      }

      SetResult(std::move(result_));
      break;
  }
}

std::string PBadRequest::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PBadRequest::GetPathItem() const { return key_; }
}

formats::json::Value Serialize(
    [[maybe_unused]] const handlers::BadRequest& value,
    ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  if (value.message) builder.EmplaceNocheck("message", *value.message);
  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const handlers::BadRequest& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);

  if (!hide_field_name || std::strcmp(hide_field_name, "message"))
  {
    if (value.message)
    {
      sw.Key("message");

      WriteToStream(*value.message, sw);
    }
  }
}

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const handlers::BadRequest& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

}
