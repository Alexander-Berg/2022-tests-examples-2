{
  "comment": "copied from production at 28.10.2020",
  "consumer": "taxi-surge",
  "name": "default_min_delta_weighted_adjustment",
  "stages": [
    {
      "args": [
        {
          "description": "Проверяемое значение",
          "name": "value"
        }
      ],
      "in_bindings": [],
      "name": "is_true",
      "optional": false,
      "source_code": "return value === true;"
    },
    {
      "args": [
        {
          "description": "Проверяемое значение",
          "name": "value"
        }
      ],
      "in_bindings": [],
      "name": "is_present",
      "optional": false,
      "source_code": "return value !== null && value !== undefined;"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "resource",
          "optional": false,
          "query": "zone"
        }
      ],
      "name": "is_in_zone",
      "optional": false,
      "source_code": "return Boolean(zone);"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment"
        }
      ],
      "name": "is_in_zone_experiment",
      "optional": false,
      "source_code": "return Boolean(experiment);"
    },
    {
      "args": [
        {
          "description": "Название эксперимента",
          "name": "name"
        }
      ],
      "in_bindings": [],
      "name": "is_in_experiment3",
      "optional": false,
      "source_code": "return name in experiments3;"
    },
    {
      "args": [
        {
          "description": "Название тарифа",
          "name": "category"
        }
      ],
      "in_bindings": [
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.rules"
        }
      ],
      "name": "has_rules",
      "optional": false,
      "source_code": "return rules && category in rules && rules[category];"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "input",
          "optional": false,
          "query": "layer_meta"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.smooth_surge.enable"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.smooth_surge.max_jump_up"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.smooth_surge.max_jump_down"
        }
      ],
      "name": "is_smoothing_active",
      "optional": false,
      "source_code": "return layer_meta && enable && max_jump_up !== undefined && max_jump_up !== null && max_jump_down !== undefined && max_jump_down !== null;"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "resource",
          "optional": false,
          "query": "config.surge_apply_bounds_to_linear_dependency_with_base_table{enabled}"
        }
      ],
      "name": "is_linear_dependency_with_base_table_bounds_enabled",
      "optional": false,
      "source_code": "return enabled === true;"
    },
    {
      "args": [
        {
          "description": "Название тарифа",
          "name": "category"
        }
      ],
      "in_bindings": [
        {
          "domain": "input",
          "optional": false,
          "query": "request.fixed_price_classes"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "config.surge_enable_antisurge{enabled_in_config}"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.antisurge_discount_enabled{enabled_in_experiment}"
        }
      ],
      "name": "is_antisurge_disabled",
      "optional": false,
      "source_code": "return enabled_in_config !== true || enabled_in_experiment !== true || (fixed_price_classes && Object.values(fixed_price_classes).indexOf(category) < 0);"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "resource",
          "optional": false,
          "query": "config.surge_enable_explicit_antisurge{enabled_in_config}"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.explicit_antisurge_enabled{enabled_in_experiment}"
        }
      ],
      "name": "is_explicit_antisurge_enabled",
      "optional": false,
      "source_code": "return enabled_in_config === true && enabled_in_experiment === true;"
    },
    {
      "args": [
        {
          "description": "Сглаженное значение сурджа",
          "name": "value"
        }
      ],
      "in_bindings": [
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.explicit_antisurge_threshold{threshold}"
        }
      ],
      "name": "is_explicit_antisurge_satisfied",
      "optional": false,
      "source_code": "return threshold && value && value < threshold;"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "input",
          "optional": false,
          "query": "request.due"
        }
      ],
      "name": "is_not_due",
      "optional": false,
      "source_code": "return due === null || due === undefined;"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "resource",
          "optional": false,
          "query": "config.surge_enable_surcharge{enabled_in_config}"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.surcharge_enabled{enabled_in_experiment}"
        }
      ],
      "name": "is_surcharge_enabled",
      "optional": false,
      "source_code": "return enabled_in_config === true && enabled_in_experiment === true;"
    },
    {
      "conditions": [],
      "in_bindings": [
        {
          "domain": "input",
          "optional": false,
          "query": "required_categories.*{:category}"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.rules[category].surge_value{fixed_surge_value}"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.rules[category].reason{fixed_reason}"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.rules[category].time_rules"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.rules[category].linear_dependency_formula.enabled{linear_dependency_enabled}"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.balance"
        }
      ],
      "name": "initialize",
      "optional": false,
      "out_bindings": [
        {
          "alias": "class_info",
          "optional": false,
          "query": "classes[category]"
        }
      ],
      "source_code": "    if (linear_dependency_enabled) {\n        return {\n            class_info: {\n                name: category,\n                surge: {\n                    value: 1.0,\n                },\n                value_raw: 1.0,\n                calculation_meta: {\n                    reason: \"linear_dependency\",\n                },\n            },\n        };\n    }\n\n    if (fixed_surge_value) {\n        return {\n            class_info: {\n                name: category,\n                surge: {\n                    value: 1.0,\n                },\n                value_raw: fixed_surge_value,\n                calculation_meta: {\n                    reason: fixed_reason || \"no\",\n                },\n            },\n        };\n    }\n\n    if (time_rules) {\n        const now = new Date();\n        const hour_now = (now.getUTCHours() + 3) % 24; // Moscow +3\n        const mins_now = now.getMinutes();\n        for (let time_rule of time_rules) {\n            const hour_from = time_rule.time_from.hour;\n            const mins_from = time_rule.time_from.minute;\n            const hour_to = time_rule.time_to.hour;\n            const mins_to = time_rule.time_to.minute;\n\n            const gt_from = hour_now > hour_from || (hour_now == hour_from && mins_now >= mins_from);\n            const lt_to = hour_now < hour_to || (hour_now == hour_to && mins_now <= mins_to);\n\n            if (gt_from && lt_to) {\n                if (time_rule.surge_value) {\n                    return {\n                        class_info: {\n                            name: category,\n                            surge: {\n                                value: 1.0,\n                            },\n                            value_raw: time_rule.surge_value,\n                            calculation_meta: {\n                                reason: \"time\",\n                            },\n                        },\n                    };\n                } else if (balance) {\n                    return {\n                        class_info: {\n                            name: category,\n                            surge: {\n                                value: 1.0,\n                            },\n                            value_raw: 1.0,\n                            calculation_meta: {\n                                reason: \"pins_free\",\n                            },\n                        },\n                    };\n                } else {\n                    log.info(\"balance not active: no params\");\n                    break;\n                }\n            }\n        }\n    }\n\n    return {\n        class_info: {\n            name: category,\n            surge: {\n                value: 1.0,\n            },\n            value_raw: 1.0,\n            calculation_meta: {\n                reason: \"no\",\n            },\n        },\n    };\n"
    },
    {
      "conditions": [],
      "in_bindings": [
        {
          "domain": "input",
          "optional": false,
          "query": "request.point_a"
        },
        {
          "domain": "output",
          "optional": false,
          "query": "classes"
        },
        {
          "domain": "input",
          "optional": false,
          "query": "layer_meta"
        },
        {
          "children": [
            {
              "query": {
                "operations": [
                  {
                    "property_name": "base_class"
                  }
                ]
              }
            }
          ],
          "domain": "resource",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "zone"
              }
            ]
          }
        }
      ],
      "name": "fetch_point_a_map_info",
      "optional": true,
      "resources": [
        {
          "field": "point_a_map_info",
          "name": "surge_value_map"
        }
      ],
      "source_code": "function map_object_to_array(object, fn, fn_if) {\n    let result = [];\n    for (let value of Object.values(object)) {\n        if (typeof fn_if !== 'function' || fn_if(value)) {\n            result.push(fn(value));\n        }\n    }\n    return result;\n}\n\nconst kBaseClassAlias = '__default__';\n\nfunction process_class_info(class_info) {\n  if (class_info.name === base_class) {\n    return kBaseClassAlias;\n  }\n  return class_info.name;\n}\n\nfunction filter_class_info(class_info) {\n  return class_info.calculation_meta.reason === 'pins_free';\n}\n\nreturn {\n    point_a_map_info: {\n        point: point_a,\n        layer_meta: layer_meta,\n        categories: map_object_to_array(classes, process_class_info, filter_class_info),\n    }\n}\n"
    },
    {
      "conditions": [],
      "in_bindings": [
        {
          "children": [
            {
              "query": {
                "operations": [
                  {
                    "property_name": "intent"
                  }
                ]
              }
            }
          ],
          "domain": "input",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "request"
              }
            ]
          }
        },
        {
          "children": [
            {
              "query": {
                "operations": [
                  {
                    "alias": "base_class_surge",
                    "expression": "\"__default__\""
                  }
                ]
              }
            }
          ],
          "domain": "resource",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "point_a_map_info"
              }
            ]
          }
        },
        {
          "children": [
            {
              "children": [
                {
                  "query": {
                    "operations": [
                      {
                        "alias": "surge_by_points_enabled",
                        "property_name": "value"
                      }
                    ]
                  }
                }
              ],
              "query": {
                "operations": [
                  {
                    "property_name": "surge_by_points_enabled"
                  }
                ]
              }
            }
          ],
          "domain": "resource",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "dynamic_config"
              }
            ]
          }
        },
        {
          "children": [
            {
              "children": [
                {
                  "query": {
                    "operations": [
                      {
                        "alias": "force_balance",
                        "property_name": "value"
                      }
                    ]
                  }
                }
              ],
              "query": {
                "operations": [
                  {
                    "property_name": "force_balance_calculation"
                  }
                ]
              }
            }
          ],
          "domain": "resource",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "experiments3"
              }
            ]
          }
        }
      ],
      "name": "determine_calculation_type",
      "optional": false,
      "out_bindings": [
        {
          "alias": "calculation_type",
          "optional": false,
          "query": "calculation_type"
        }
      ],
      "source_code": "if (intent === \"surge_sampling\") {\n  return {calculation_type: \"fixed_point\"};\n}\n\nif (intent === \"price_calculation\") {\n  if (force_balance) {\n    return {calculation_type: \"user_balance\"};  \n  } else if (surge_by_points_enabled && base_class_surge) {\n    return {calculation_type: \"user_light\"};\n  }\n}\n\nreturn {calculation_type: \"default\"};"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "output",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "calculation_type"
              }
            ]
          }
        }
      ],
      "name": "is_lightweight_calculation",
      "optional": false,
      "source_code": "return calculation_type === \"user_light\";"
    },
    {
      "args": [
        {
          "description": "Причина сурджа",
          "name": "reason"
        }
      ],
      "in_bindings": [],
      "name": "is_balance_equation",
      "optional": false,
      "source_code": "return reason === 'pins_free';"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "output",
          "optional": false,
          "query": "classes"
        },
        {
          "domain": "output",
          "query": {
            "operations": [
              {
                "property_name": "calculation_type"
              }
            ]
          }
        }
      ],
      "name": "is_balance_equation_needed",
      "optional": false,
      "source_code": "if (calculation_type === \"user_light\") {\n  return false;\n}\n\nfor (let class_info of Object.values(classes)) {\n  if (class_info.calculation_meta.reason === 'pins_free') return true;\n}\nreturn false;\n"
    },
    {
      "args": [
        {
          "description": "Причина сурджа",
          "name": "reason"
        }
      ],
      "in_bindings": [],
      "name": "is_linear_dependency",
      "optional": false,
      "source_code": "return reason === 'linear_dependency';"
    },
    {
      "conditions": [
        {
          "predicate": "is_lightweight_calculation",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "children": [
            {
              "query": {
                "operations": [
                  {
                    "key_alias": "category",
                    "type": "iteration"
                  }
                ]
              }
            }
          ],
          "domain": "output",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "classes"
              }
            ]
          }
        },
        {
          "children": [
            {
              "query": {
                "operations": [
                  {
                    "property_name": "base_class"
                  }
                ]
              }
            }
          ],
          "domain": "resource",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "zone"
              }
            ]
          }
        },
        {
          "children": [
            {
              "query": {
                "operations": [
                  {
                    "alias": "value_from_map",
                    "expression": "category === base_class ? \"__default__\" : category"
                  }
                ]
              }
            }
          ],
          "domain": "resource",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "point_a_map_info"
              }
            ]
          }
        }
      ],
      "name": "set_value_raw_lightweight",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value_raw",
          "optional": false,
          "query": "classes[category].value_raw"
        }
      ],
      "source_code": "return value_from_map ? {value_raw: value_from_map} : null;"
    },
    {
      "conditions": [
        {
          "predicate": "is_lightweight_calculation",
          "type": "predicate"
        },
        {
          "args": [
            {
              "name": "reason",
              "value": "reason"
            }
          ],
          "predicate": "is_balance_equation",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "query": {
                        "operations": [
                          {
                            "property_name": "reason"
                          }
                        ]
                      }
                    }
                  ],
                  "query": {
                    "operations": [
                      {
                        "property_name": "calculation_meta"
                      }
                    ]
                  }
                }
              ],
              "query": {
                "operations": [
                  {
                    "key_alias": "category",
                    "type": "iteration"
                  }
                ]
              }
            }
          ],
          "domain": "output",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "classes"
              }
            ]
          }
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "query": {
                                "operations": [
                                  {
                                    "alias": "weighted_adjustment_enabled",
                                    "property_name": "enabled"
                                  }
                                ]
                              }
                            }
                          ],
                          "query": {
                            "operations": [
                              {
                                "property_name": "weighted_surge_adjustment"
                              }
                            ]
                          }
                        }
                      ],
                      "query": {
                        "operations": [
                          {
                            "expression": "category"
                          }
                        ]
                      }
                    }
                  ],
                  "query": {
                    "operations": [
                      {
                        "property_name": "rules"
                      }
                    ]
                  }
                }
              ],
              "query": {
                "operations": [
                  {
                    "property_name": "experiment"
                  }
                ]
              }
            },
            {
              "query": {
                "operations": [
                  {
                    "property_name": "base_class"
                  }
                ]
              }
            }
          ],
          "domain": "resource",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "zone"
              }
            ]
          }
        },
        {
          "children": [
            {
              "query": {
                "operations": [
                  {
                    "alias": "value_from_map",
                    "expression": "category === base_class ? \"__default__\" : category"
                  }
                ]
              }
            }
          ],
          "domain": "resource",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "point_a_map_info"
              }
            ]
          }
        }
      ],
      "name": "fallback_to_linear_dependency",
      "optional": false,
      "out_bindings": [
        {
          "alias": "reason",
          "optional": false,
          "query": "classes[category].calculation_meta.reason"
        }
      ],
      "source_code": "// https://st.yandex-team.ru/EFFICIENCYALT-266 \nif (!value_from_map && !weighted_adjustment_enabled) {\n  return {reason: \"linear_dependency\"};\n}\n\nreturn null;"
    },
    {
      "conditions": [
        {
          "args": [],
          "predicate": "is_balance_equation_needed",
          "type": "predicate"
        }
      ],
      "name": "value_raw_calculation",
      "stages": [
        {
          "conditions": [],
          "name": "group_1",
          "stages": [
            {
              "conditions": [],
              "in_bindings": [
                {
                  "domain": "output",
                  "optional": false,
                  "query": {
                    "operations": [
                      {
                        "property_name": "classes"
                      }
                    ]
                  }
                },
                {
                  "children": [
                    {
                      "query": {
                        "operations": [
                          {
                            "property_name": "point_a"
                          }
                        ]
                      }
                    },
                    {
                      "query": {
                        "operations": [
                          {
                            "property_name": "tariff_zone"
                          }
                        ]
                      }
                    }
                  ],
                  "domain": "input",
                  "optional": false,
                  "query": {
                    "operations": [
                      {
                        "property_name": "request"
                      }
                    ]
                  }
                },
                {
                  "domain": "input",
                  "optional": false,
                  "query": {
                    "operations": [
                      {
                        "property_name": "layer_meta"
                      }
                    ]
                  }
                },
                {
                  "children": [
                    {
                      "query": {
                        "operations": [
                          {
                            "property_name": "base_class"
                          }
                        ]
                      }
                    }
                  ],
                  "domain": "resource",
                  "optional": false,
                  "query": {
                    "operations": [
                      {
                        "property_name": "zone"
                      }
                    ]
                  }
                }
              ],
              "name": "fetch_drivers_info",
              "optional": false,
              "resources": [
                {
                  "field": "drivers_info",
                  "name": "count_by_categories"
                }
              ],
              "source_code": "function map_object_to_array(object, fn, fn_if) {\n    let result = [];\n    for (let key in object) {\n        let item = object[key];\n        if (typeof fn_if !== 'function' || fn_if(item)) {\n            result.push(fn(item));\n        }\n    }\n    return result.sort();\n}\n\nlet request = {\n    allowed_classes: map_object_to_array(\n        classes,\n        info => info.name,\n        info => info.calculation_meta.reason === \"pins_free\" || info.name === base_class\n    ),\n    limit: 400,\n    max_distance: 2500,\n    point: point_a,\n};\n\nif (tariff_zone) {\n  request.zone_id = tariff_zone;\n}\n\nreturn {\n    drivers_info: {\n        layer_meta: layer_meta,\n        request: request,\n    }\n};\n"
            },
            {
              "conditions": [],
              "in_bindings": [
                {
                  "domain": "output",
                  "optional": false,
                  "query": {
                    "operations": [
                      {
                        "property_name": "classes"
                      }
                    ]
                  }
                },
                {
                  "children": [
                    {
                      "query": {
                        "operations": [
                          {
                            "property_name": "point_a"
                          }
                        ]
                      }
                    }
                  ],
                  "domain": "input",
                  "optional": false,
                  "query": {
                    "operations": [
                      {
                        "property_name": "request"
                      }
                    ]
                  }
                },
                {
                  "children": [
                    {
                      "query": {
                        "operations": [
                          {
                            "property_name": "radius"
                          }
                        ]
                      }
                    }
                  ],
                  "domain": "resource",
                  "optional": false,
                  "query": {
                    "operations": [
                      {
                        "property_name": "drivers_info"
                      }
                    ]
                  }
                },
                {
                  "domain": "input",
                  "optional": false,
                  "query": {
                    "operations": [
                      {
                        "property_name": "layer_meta"
                      }
                    ]
                  }
                },
                {
                  "children": [
                    {
                      "query": {
                        "operations": [
                          {
                            "property_name": "base_class"
                          }
                        ]
                      }
                    }
                  ],
                  "domain": "resource",
                  "optional": false,
                  "query": {
                    "operations": [
                      {
                        "property_name": "zone"
                      }
                    ]
                  }
                }
              ],
              "name": "fetch_pins_info",
              "optional": false,
              "resources": [
                {
                  "field": "pins_info",
                  "name": "pin_stats"
                }
              ],
              "source_code": "function map_object_to_array(object, fn, fn_if) {\n    let result = [];\n    for (let key in object) {\n        let item = object[key];\n        if (typeof fn_if !== 'function' || fn_if(item)) {\n            result.push(fn(item));\n        }\n    }\n    return result.sort();\n}\n\nreturn {\n    pins_info: {\n        layer_meta: layer_meta,\n        request: {\n            categories: map_object_to_array(\n                classes,\n                info => info.name,\n                info => info.calculation_meta.reason === \"pins_free\" || info.name === base_class\n            ),\n            point: point_a,\n            radius: radius,\n        }\n    }\n};\n"
            },
            {
              "conditions": [
                {
                  "args": [
                    {
                      "name": "value",
                      "value": "counts"
                    }
                  ],
                  "predicate": "is_present",
                  "type": "predicate"
                },
                {
                  "args": [
                    {
                      "name": "reason",
                      "value": "reason"
                    }
                  ],
                  "predicate": "is_balance_equation",
                  "type": "predicate"
                }
              ],
              "in_bindings": [
                {
                  "domain": "output",
                  "optional": false,
                  "query": "classes.*{category:}.calculation_meta.reason"
                },
                {
                  "domain": "resource",
                  "optional": false,
                  "query": "config.surge_latest_pins_delta_time"
                },
                {
                  "domain": "resource",
                  "optional": false,
                  "query": "zone.base_class"
                },
                {
                  "domain": "resource",
                  "optional": false,
                  "query": "zone.experiment.rules[category].surge_rules"
                },
                {
                  "domain": "resource",
                  "optional": false,
                  "query": "zone.experiment.balance.min_pins"
                },
                {
                  "domain": "resource",
                  "optional": false,
                  "query": "zone.experiment.balance.min_total"
                },
                {
                  "domain": "resource",
                  "optional": false,
                  "query": "zone.experiment.balance.f_init"
                },
                {
                  "domain": "resource",
                  "optional": false,
                  "query": "zone.experiment.balance.f_equal"
                },
                {
                  "domain": "resource",
                  "optional": false,
                  "query": "zone.experiment.balance.f_delta_left"
                },
                {
                  "domain": "resource",
                  "optional": false,
                  "query": "zone.experiment.balance.f_delta_right"
                },
                {
                  "domain": "resource",
                  "optional": false,
                  "query": "zone.experiment.balance.add_free"
                },
                {
                  "domain": "resource",
                  "optional": false,
                  "query": "zone.experiment.balance.add_total"
                },
                {
                  "domain": "resource",
                  "optional": false,
                  "query": "zone.experiment.balance.fs_intercept"
                },
                {
                  "domain": "resource",
                  "optional": false,
                  "query": "zone.experiment.balance.fs_coef_chain"
                },
                {
                  "domain": "resource",
                  "optional": false,
                  "query": "zone.experiment.balance.fs_coef_total"
                },
                {
                  "domain": "resource",
                  "optional": false,
                  "query": "zone.experiment.balance.chain_factor"
                },
                {
                  "domain": "resource",
                  "optional": false,
                  "query": "zone.experiment.balance.reposition_discount"
                },
                {
                  "domain": "resource",
                  "optional": false,
                  "query": "zone.experiment.balance.utilization_for_non_econom{utilization_for_non_base}"
                },
                {
                  "domain": "resource",
                  "optional": false,
                  "query": "zone.experiment.balance.table_coef_ps"
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "query": {
                            "operations": [
                              {
                                "alias": "reposition_discount_default",
                                "property_name": "value"
                              }
                            ]
                          }
                        }
                      ],
                      "query": {
                        "operations": [
                          {
                            "property_name": "\t surge_reposition_discount_default"
                          }
                        ]
                      }
                    }
                  ],
                  "domain": "resource",
                  "optional": false,
                  "query": {
                    "operations": [
                      {
                        "property_name": "dynamic_config"
                      }
                    ]
                  }
                },
                {
                  "children": [
                    {
                      "query": {
                        "operations": [
                          {
                            "property_name": "radius"
                          }
                        ]
                      }
                    },
                    {
                      "children": [
                        {
                          "query": {
                            "operations": [
                              {
                                "alias": "counts",
                                "expression": "category"
                              }
                            ]
                          }
                        },
                        {
                          "query": {
                            "operations": [
                              {
                                "alias": "base_class_counts",
                                "expression": "base_class"
                              }
                            ]
                          }
                        }
                      ],
                      "query": {
                        "operations": [
                          {
                            "property_name": "generic"
                          }
                        ]
                      }
                    },
                    {
                      "children": [
                        {
                          "query": {
                            "operations": [
                              {
                                "alias": "reposition_counts",
                                "expression": "category"
                              }
                            ]
                          }
                        },
                        {
                          "query": {
                            "operations": [
                              {
                                "alias": "reposition_base_class_counts",
                                "expression": "base_class"
                              }
                            ]
                          }
                        }
                      ],
                      "query": {
                        "operations": [
                          {
                            "property_name": "reposition"
                          }
                        ]
                      }
                    }
                  ],
                  "domain": "resource",
                  "optional": false,
                  "query": {
                    "operations": [
                      {
                        "property_name": "drivers_info"
                      }
                    ]
                  }
                },
                {
                  "children": [
                    {
                      "query": {
                        "operations": [
                          {
                            "property_name": "pins"
                          }
                        ]
                      }
                    },
                    {
                      "query": {
                        "operations": [
                          {
                            "property_name": "pins_with_b"
                          }
                        ]
                      }
                    },
                    {
                      "query": {
                        "operations": [
                          {
                            "property_name": "pins_with_order"
                          }
                        ]
                      }
                    },
                    {
                      "query": {
                        "operations": [
                          {
                            "property_name": "pins_with_driver"
                          }
                        ]
                      }
                    },
                    {
                      "query": {
                        "operations": [
                          {
                            "property_name": "prev_pins"
                          }
                        ]
                      }
                    },
                    {
                      "query": {
                        "operations": [
                          {
                            "alias": "pins_meta_by_category",
                            "property_name": "values_by_category"
                          }
                        ]
                      }
                    }
                  ],
                  "domain": "resource",
                  "optional": false,
                  "query": {
                    "operations": [
                      {
                        "property_name": "pins_info"
                      }
                    ]
                  }
                }
              ],
              "name": "balance_equation",
              "optional": false,
              "out_bindings": [
                {
                  "alias": "calculation_meta",
                  "optional": false,
                  "query": "classes[category].calculation_meta"
                },
                {
                  "alias": "value_raw",
                  "optional": false,
                  "query": "classes[category].value_raw"
                }
              ],
              "source_code": "\nfunction is_present(value) {\n  return value !== null && value !== undefined;\n}\n\nfunction value_or_number(value, default_value) {\n  return typeof value === 'number' ? value : default_value;\n}\n\nfunction require(value, description) {\n  if (!is_present(value)) {\n    throw 'no ' + description;\n  }\n}\n\nfunction map_object(object, fn, fn_if) {\n  let result = {}\n  for (let key in object) {\n    let item = object[key];\n    if (typeof fn_if !== 'function' || fn_if(item)) {\n      result[key] = (fn(item));\n    }\n  }\n  return result;\n}\n\nfunction in_epsilon_neighborhood_of_zero(value) {\n  return Math.abs(value) <= Number.EPSILON;\n}\n\nfunction get_category_specific_pin_meta(field_name, is_non_base) {\n  if (is_non_base) {\n    let result = {};\n    if (category in pins_meta_by_category) {\n      let meta = pins_meta_by_category[category];\n      if (field_name in meta) {\n        result[category] = meta[field_name];\n      }\n    }\n    return result;\n  } else {\n    return map_object(\n      pins_meta_by_category,\n      meta => meta[field_name],\n      meta => field_name in meta,\n    );\n  }\n}\n\nchain_factor = value_or_number(chain_factor, 1.0);\n\nrequire(category, 'category name');\nrequire(pins, 'pins info');\nrequire(counts, category + 'counts');\nrequire(base_class_counts, 'base class counts');\n\nconst kDefaultSurgeValue = 1.0;\nconst kReasonNo = 'no';\nconst kReasonPinsFree = 'pins_free';\nconst kMessageNotActive = 'balance equation is not active: ';\n\nconst is_non_base = category !== base_class;\nconst is_utilization = utilization_for_non_base && is_non_base;\n\nconst selected_counts = is_utilization ? counts : base_class_counts;\nconst selected_reposition_counts = is_utilization ? reposition_counts : reposition_base_class_counts;\n\nlet free = selected_counts.free;\nlet free_chain = selected_counts.free_chain;\nlet on_order = selected_counts.on_order;  // unused\nlet total = selected_counts.total;\n\nif (is_present(selected_reposition_counts)) {\n  free -= selected_reposition_counts.free;\n  free_chain -= selected_reposition_counts.free_chain;\n  total -= selected_reposition_counts.total;\n}\n\nif (!is_present(reposition_discount)) {\n  reposition_discount = reposition_discount_default;\n}\n\n// Доля свободных машин\nfunction get_ratio_balance() {\n  let corrected_total = total + add_total;\n  if (is_present(reposition_discount) && is_present(selected_reposition_counts)) {\n    // https://st.yandex-team.ru/EFFICIENCYDEV-20\n    corrected_total += reposition_discount * selected_reposition_counts.total;\n  }\n  if (in_epsilon_neighborhood_of_zero(corrected_total)) {\n    return 0.0;\n  }\n  let corrected_free = free + chain_factor * free_chain + add_free;\n  if (is_present(reposition_discount) && is_present(selected_reposition_counts)) {\n    // https://st.yandex-team.ru/EFFICIENCYDEV-20\n    corrected_free += reposition_discount *\n      (selected_reposition_counts.free + chain_factor * selected_reposition_counts.free_chain);\n  }\n  return corrected_free / corrected_total;\n}\n\nfunction make_result(\n  reason = kReasonNo,\n  value_raw = kDefaultSurgeValue,\n  ps = null,\n  f_derivative = null,\n) {\n  let cat_meta = pins_meta_by_category[category] || {};\n  let calculation_meta = {\n    counts: {\n      free: counts.free,\n      free_chain: counts.free_chain,\n      total: counts.total,\n      pins: pins,\n      radius: radius,\n    },\n    reason: reason,\n    pins_meta: {\n      pins_b: pins_with_b,\n      pins_order: pins_with_order,\n      pins_driver: pins_with_driver,\n      prev_pins: prev_pins,\n      eta_in_tariff: cat_meta.estimated_waiting || 0.0,\n      surge_in_tariff: cat_meta.surge || 0.0,\n      pins_order_in_tariff: cat_meta.pins_order_in_tariff || 0,\n      pins_driver_in_tariff: cat_meta.pins_driver_in_tariff || 0,\n    },\n  };\n\n  if (is_present(reposition_counts)) {\n    calculation_meta.reposition = {\n      free: reposition_counts.free,\n      free_chain: reposition_counts.free_chain,\n      total: reposition_counts.total,\n    };\n    calculation_meta.counts.free -= reposition_counts.free;\n    calculation_meta.counts.free_chain -= reposition_counts.free_chain;\n    calculation_meta.counts.total -= reposition_counts.total;\n  }\n\n  if (is_present(ps)) {\n    calculation_meta.ps = ps;\n  }\n\n  if (is_present(f_derivative)) {\n    calculation_meta.f_derivative = f_derivative;\n  }\n\n  return {\n    value_raw: value_raw,\n    calculation_meta: calculation_meta,\n  };\n}\n\nfunction make_result_by_ratio(ratio) {\n  let value_raw = kDefaultSurgeValue;\n  for (let rule of surge_rules) {\n    if (rule.min_coeff <= ratio) {\n      value_raw = rule.surge_value;\n    } else {\n      break;\n    }\n  }\n  return make_result(kReasonPinsFree, value_raw);\n}\n\nfunction make_result_by_ps(ps, f_derivative) {\n  let reason = kReasonNo;\n  let value_raw = kDefaultSurgeValue;\n\n  let ps_deviation = undefined;\n  for (let table_coef_item of table_coef_ps || []) {\n    let current_ps_deviation = Math.abs(ps - table_coef_item.ps);\n    if (!is_present(ps_deviation) || current_ps_deviation < ps_deviation) {\n      reason = kReasonPinsFree;\n      value_raw = table_coef_item.coeff;\n      ps_deviation = current_ps_deviation;\n    }\n  }\n  return make_result(reason, value_raw, ps, f_derivative);\n}\n\nif (pins < min_pins) {\n  log.info(kMessageNotActive + ': pins(' + pins + ') < min_pins(' + min_pins + ')');\n  return make_result();\n}\n\nconst ratio = get_ratio_balance();\n// Утилизация считается по тому же ратио, но по правилам для класса\n// https://st.yandex-team.ru/TAXIBACKEND-6549\nif (is_utilization) {\n  log.info(\n    'balance enabled but utilization formula is active for ' + category\n  );\n  if (total < min_total) {\n    log.info(\n      kMessageNotActive + ': total{' + total +\n      '} is less than min_total{' + min_total + '}'\n    );\n    return make_result();\n  }\n  return make_result_by_ratio(ratio);\n}\n// Порог, при котором не начинаем считать производную\nif (ratio >= f_init) {\n  log.info(\n    kMessageNotActive + ': ratio{' + ratio + '} >= f_init{' +\n    f_init + '}');\n  return make_result();\n}\n\nif (in_epsilon_neighborhood_of_zero(pins)) {\n  log.info(kMessageNotActive + ': zero pins (or too close to zero)');\n  return make_result();\n}\nconst window_minutes = surge_latest_pins_delta_time / 60;\n// Формула уравнения баланса https://st.yandex-team.ru/TAXIBACKEND-7194:\n// где  новая скорость = (fs_intercept + fs_coef_chain * free_chain +\n// fs_coef_total * total) / window\n//\n// f_derivative * total = (fs_intercept +\n// fs_coef_chain * free_chain + fs_coef_total * total) / window - p(s) * pins\n// / window\n//\n// =>\n//\n// f_derivative * total * window = (fs_intercept + fs_coef_chain * free_chain\n// + fs_coef_total * total) - p(s) * pins\n//\n// p(s) * pins = (fs_intercept +\n// fs_coef_chain * free_chain + fs_coef_total * total)\n// - f_derivative * total * window\n//\n// p(s) = (fs_intercept + fs_coef_chain * free_chain + fs_coef_total *\n// total - f_derivative * total * window) / pins\n\nlet f_delta =\n  ratio < f_equal ? f_delta_left : f_delta_right;\n// UPD: https://st.yandex-team.ru/TAXIBACKEND-6474\n// ratio' = f_delta * (f_equal - ratio(t))\nlet f_derivative = f_delta * (f_equal - ratio);\nif (is_present(reposition_discount) &&\n  is_present(selected_reposition_counts)\n) {\n  // https://st.yandex-team.ru/EFFICIENCYDEV-20\n  total += reposition_discount * selected_reposition_counts.total;\n  free_chain += reposition_discount * selected_reposition_counts.free_chain;\n}\n\nlet ps = (\n  fs_intercept + fs_coef_chain * free_chain + total * fs_coef_total -\n  f_derivative * total * window_minutes\n) / pins;\n\nif (!isFinite(ps)) {\n  log.error(\n    'fs_intercept: ' + fs_intercept +\n    'fs_coef_chain: ' + fs_coef_chain +\n    'free_chain: ' + free_chain +\n    'total: ' + total +\n    'fs_coef_total: ' + fs_coef_total +\n    'f_derivative: ' + f_derivative +\n    'f_delta: ' + f_delta +\n    'f_equal: ' + f_equal +\n    'add_total' + add_total\n  );\n}\n\nreturn make_result_by_ps(ps, f_derivative);\n"
            }
          ]
        }
      ]
    },
    {
      "conditions": [
        {
          "args": [],
          "predicate": "is_smoothing_active",
          "type": "predicate"
        }
      ],
      "name": "smooth_info_fetching",
      "stages": [
        {
          "conditions": [],
          "in_bindings": [
            {
              "domain": "input",
              "optional": false,
              "query": "request.point_a"
            },
            {
              "domain": "output",
              "optional": false,
              "query": "classes"
            },
            {
              "domain": "input",
              "optional": false,
              "query": "layer_meta"
            },
            {
              "children": [
                {
                  "query": {
                    "operations": [
                      {
                        "property_name": "base_class"
                      }
                    ]
                  }
                }
              ],
              "domain": "resource",
              "optional": false,
              "query": {
                "operations": [
                  {
                    "property_name": "zone"
                  }
                ]
              }
            }
          ],
          "name": "fetch_point_a_smoothing_info",
          "optional": false,
          "resources": [
            {
              "field": "point_a_smoothing_info",
              "name": "surge_value_map"
            }
          ],
          "source_code": "function map_object_to_array(object, fn, fn_if) {\n    let result = [];\n    for (let value of Object.values(object)) {\n        if (typeof fn_if !== 'function' || fn_if(value)) {\n            result.push(fn(value));\n        }\n    }\n    return result;\n}\n\nconst kBaseClassAlias = '__default__';\n\nfunction process_class_info(class_info) {\n  if (class_info.name === base_class) {\n    return kBaseClassAlias;\n  }\n  return class_info.name;\n}\n\nreturn {\n    point_a_smoothing_info: {\n        point: point_a,\n        layer_meta: layer_meta,\n        categories: map_object_to_array(classes, process_class_info),\n    }\n}\n"
        },
        {
          "conditions": [
            {
              "args": [
                {
                  "name": "value",
                  "value": "point_b"
                }
              ],
              "predicate": "is_present",
              "type": "predicate"
            }
          ],
          "in_bindings": [
            {
              "domain": "input",
              "optional": false,
              "query": "request.point_b"
            },
            {
              "domain": "output",
              "optional": false,
              "query": "classes"
            },
            {
              "domain": "input",
              "optional": false,
              "query": "layer_meta"
            },
            {
              "children": [
                {
                  "query": {
                    "operations": [
                      {
                        "property_name": "base_class"
                      }
                    ]
                  }
                }
              ],
              "domain": "resource",
              "optional": false,
              "query": {
                "operations": [
                  {
                    "property_name": "zone"
                  }
                ]
              }
            }
          ],
          "name": "fetch_point_b_smoothing_info",
          "optional": false,
          "resources": [
            {
              "field": "point_b_smoothing_info",
              "name": "surge_value_map"
            }
          ],
          "source_code": "function map_object_to_array(object, fn, fn_if) {\n    let result = [];\n    for (let value of Object.values(object)) {\n        if (typeof fn_if !== 'function' || fn_if(value)) {\n            result.push(fn(value));\n        }\n    }\n    return result;\n}\n    \nconst kBaseClassAlias = '__default__';\n\nfunction process_class_info(class_info) {\n  if (class_info.name === base_class) {\n    return kBaseClassAlias;\n  }\n  return class_info.name;\n}\n\nreturn {\n    point_b_smoothing_info: {\n        point: point_b,\n        layer_meta: layer_meta,\n        categories: map_object_to_array(classes, process_class_info),\n    }\n}\n"
        }
      ]
    },
    {
      "conditions": [],
      "in_bindings": [
        {
          "domain": "input",
          "optional": false,
          "query": "request.point_b"
        },
        {
          "domain": "output",
          "optional": false,
          "query": "classes.*{category:}.value_raw"
        },
        {
          "children": [
            {
              "query": {
                "operations": [
                  {
                    "alias": "zone_name",
                    "property_name": "name"
                  }
                ]
              }
            },
            {
              "children": [
                {
                  "children": [
                    {
                      "query": {
                        "operations": [
                          {
                            "property_name": "max_jump_up"
                          }
                        ]
                      }
                    },
                    {
                      "query": {
                        "operations": [
                          {
                            "property_name": "max_jump_down"
                          }
                        ]
                      }
                    },
                    {
                      "query": {
                        "operations": [
                          {
                            "property_name": "default_smooth_surge_b"
                          }
                        ]
                      }
                    },
                    {
                      "query": {
                        "operations": [
                          {
                            "alias": "smooth_enabled",
                            "property_name": "enable"
                          }
                        ]
                      }
                    }
                  ],
                  "query": {
                    "operations": [
                      {
                        "property_name": "smooth_surge"
                      }
                    ]
                  }
                }
              ],
              "query": {
                "operations": [
                  {
                    "property_name": "experiment"
                  }
                ]
              }
            },
            {
              "query": {
                "operations": [
                  {
                    "property_name": "base_class"
                  }
                ]
              }
            }
          ],
          "domain": "resource",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "zone"
              }
            ]
          }
        },
        {
          "children": [
            {
              "children": [
                {
                  "query": {
                    "operations": [
                      {
                        "alias": "use_default_surge_if_no_smoothing",
                        "expression": "zone_name"
                      }
                    ]
                  }
                }
              ],
              "query": {
                "operations": [
                  {
                    "property_name": "surge_use_default_surge_if_no_smoothing"
                  }
                ]
              }
            }
          ],
          "domain": "resource",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "config"
              }
            ]
          }
        },
        {
          "children": [
            {
              "query": {
                "operations": [
                  {
                    "alias": "value_smooth_a",
                    "expression": "category === base_class ? \"__default__\" : category"
                  }
                ]
              }
            }
          ],
          "domain": "resource",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "point_a_smoothing_info"
              }
            ]
          }
        },
        {
          "children": [
            {
              "query": {
                "operations": [
                  {
                    "alias": "value_smooth_b",
                    "expression": "category === base_class ? \"__default__\" : category"
                  }
                ]
              }
            }
          ],
          "domain": "resource",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "point_b_smoothing_info"
              }
            ]
          }
        }
      ],
      "name": "smooth_surge",
      "optional": false,
      "out_bindings": [
        {
          "alias": "smooth_a",
          "optional": false,
          "query": "classes[category].calculation_meta.smooth.point_a"
        },
        {
          "alias": "smooth_b",
          "optional": false,
          "query": "classes[category].calculation_meta.smooth.point_b"
        },
        {
          "alias": "value",
          "optional": false,
          "query": "classes[category].surge.value"
        }
      ],
      "source_code": "\nconst kDefaultSurgeValue = 1.0;\n\nlet smoothing_activated = smooth_enabled && max_jump_up && max_jump_down;\n\nlet smooth_a_default = use_default_surge_if_no_smoothing ? kDefaultSurgeValue : value_raw;\nlet result = {\n    smooth_a: {\n        value: value_smooth_a || smooth_a_default,\n        is_default: !value_smooth_a,\n    },\n    smooth_b: point_b ? {\n        value: value_smooth_b || default_smooth_surge_b || kDefaultSurgeValue,\n        is_default: !value_smooth_b\n    } : null\n};\n\nresult.value = smoothing_activated ? \n  Math.max(\n    Math.min(value_raw, result.smooth_a.value + max_jump_up),\n    result.smooth_a.value - max_jump_down\n  ) : smooth_a_default;\n\nreturn result;\n"
    },
    {
      "conditions": [
        {
          "args": [
            {
              "name": "category",
              "value": "category"
            }
          ],
          "predicate": "has_rules",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "domain": "output",
          "optional": false,
          "query": "classes.*{category:}.surge.value"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.rules[category].surge_min_bound"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.rules[category].surge_max_bound"
        }
      ],
      "name": "bound_coeffs_1",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "optional": false,
          "query": "classes[category].surge.value"
        }
      ],
      "source_code": "\n    function value_or_number(value, default_value) {\n        return typeof value === 'number' ? value : default_value;\n    }\n\n    let min_surge = value_or_number(surge_min_bound, 1.0);\n    let max_surge = value_or_number(surge_max_bound, 4.0);\n\n    return {\n        value: Math.max(Math.min(value, max_surge), min_surge)\n    };\n"
    },
    {
      "conditions": [
        {
          "args": [],
          "predicate": "is_in_zone_experiment",
          "type": "predicate"
        },
        {
          "args": [
            {
              "name": "value",
              "value": "enabled"
            }
          ],
          "predicate": "is_true",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.base_class"
        },
        {
          "domain": "output",
          "optional": false,
          "query": "classes[base_class].surge.value{base_value}"
        },
        {
          "domain": "output",
          "optional": false,
          "query": "classes.*{category:}"
        },
        {
          "domain": "output",
          "optional": false,
          "query": "classes[category].surge.value{dep_value}"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.rules[category].weighted_surge_adjustment.enabled"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.rules[category].weighted_surge_adjustment.settings"
        }
      ],
      "name": "weighted_adjustment",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "optional": false,
          "query": "classes[category].surge.value"
        }
      ],
      "source_code": "function require_setting(name) {\n    if (!(name in settings)) {\n        throw name + ' is not present in settings';\n    }\n    return settings[name];\n}\n\nlet mode = require_setting('mode');\nlet param_max_total = require_setting('max_total');\nlet param_min_delta_rel= require_setting('min_delta_rel'); // cost_delta/cost_econom\nlet param_elasticity = require_setting('adjustment_elasticity'); // cost_econom/cost_dep_class\n\nlet max_surge_res = 4.0;\nlet min_surge_res = 1 + (base_value-1)*param_elasticity; // дает одинаковый сурчардж в базовом и повышенном классе (линейная привязка)\n\n// cost_delta/cost_dep_class\n// max_adjustment = на сколько максимально можно уменьшить min_surge_res\nlet max_adjustment = param_elasticity*param_min_delta_rel; \n\nfunction get_weight(max_weight, max_value, value) {\n    if (value<=0){\n        return 0;\n    } else if (value>=max_value) {\n        return max_weight;\n    } else {\n        return Math.min(value/max_value, max_weight);\n    }\n}\n\nlet res = dep_value;\n\nif (mode == 'linear_dep_subtract_const') {\n    //игнорируем веса, тупо вычитаем константу, даже не умножая ее на эластичность\n    res = min_surge_res - param_min_delta_rel;\n}\nelse {\n    min_surge_res -= max_adjustment;\n    res = Math.min(Math.max(dep_value, min_surge_res), max_surge_res);\n}\n\nlog.warning(JSON.stringify({\n    dep_value: dep_value,\n    base_value: base_value,\n    mode: mode, \n    param_max_total: param_max_total,\n    param_min_delta_rel: param_min_delta_rel,\n    param_elasticity: param_elasticity,\n    min_surge_res: min_surge_res,\n    max_surge_res: max_surge_res,\n    res: res,\n    log_type: 'weighted_adjustment'\n})\n);\n\nreturn {value: res};\n"
    },
    {
      "conditions": [
        {
          "args": [
            {
              "name": "category",
              "value": "category"
            }
          ],
          "predicate": "has_rules",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "domain": "output",
          "optional": false,
          "query": "classes.*{category:}.surge.value"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.rules[category].surge_min_bound"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.rules[category].surge_max_bound"
        }
      ],
      "name": "bound_coeffs_2",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "optional": false,
          "query": "classes[category].surge.value"
        }
      ],
      "source_code": "\n    function value_or_number(value, default_value) {\n        return typeof value === 'number' ? value : default_value;\n    }\n\n    let min_surge = value_or_number(surge_min_bound, 1.0);\n    let max_surge = value_or_number(surge_max_bound, 4.0);\n\n    return {\n        value: Math.max(Math.min(value, max_surge), min_surge)\n    };\n"
    },
    {
      "conditions": [],
      "in_bindings": [
        {
          "domain": "output",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "classes"
              }
            ]
          }
        },
        {
          "children": [
            {
              "children": [
                {
                  "query": {
                    "operations": [
                      {
                        "property_name": "rules"
                      }
                    ]
                  }
                }
              ],
              "query": {
                "operations": [
                  {
                    "property_name": "experiment"
                  }
                ]
              }
            },
            {
              "query": {
                "operations": [
                  {
                    "property_name": "base_class"
                  }
                ]
              }
            }
          ],
          "domain": "resource",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "zone"
              }
            ]
          }
        }
      ],
      "name": "linear_dependent_topo_sort",
      "optional": false,
      "out_bindings": [
        {
          "alias": "dependent_sorted",
          "optional": false,
          "query": "extra.dependent_sorted"
        }
      ],
      "source_code": "let dependent_sorted = [];\nlet processed = new Set();\nlet not_processed = Object.keys(classes);\n\nfunction get_from_class_for(category) {\n  let settings = rules?.category?.[\"linear_dependency_formula\"];\n  let enabled = settings?.['enabled'];\n  return enabled ? settings.from_class : base_class;\n}\n\nwhile (not_processed.length > 0) {\n  let would_be_processed_later = [];\n  for (let category of not_processed) {\n    if (classes[category].calculation_meta.reason != 'linear_dependency') {\n      processed.add(category);\n      continue;\n    }\n    if (processed.has(get_from_class_for(category))) {\n      processed.add(category);\n      dependent_sorted.push(category);\n    } else {\n      would_be_processed_later.push(category);\n    }\n  }\n  if (would_be_processed_later.length == not_processed.length) {\n    throw 'Cyclic linear dependency among classes ' + would_be_processed_later.join(', ');\n  }\n  not_processed = would_be_processed_later;\n}\n\nreturn {\n  dependent_sorted: dependent_sorted\n};\n"
    },
    {
      "conditions": [],
      "in_bindings": [
        {
          "children": [
            {
              "children": [
                {
                  "query": {
                    "operations": [
                      {
                        "type": "iteration",
                        "value_alias": "category"
                      }
                    ]
                  }
                }
              ],
              "query": {
                "operations": [
                  {
                    "property_name": "dependent_sorted"
                  }
                ]
              }
            }
          ],
          "domain": "output",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "extra"
              }
            ]
          }
        },
        {
          "children": [
            {
              "children": [
                {
                  "children": [
                    {
                      "children": [
                        {
                          "children": [
                            {
                              "query": {
                                "operations": [
                                  {
                                    "property_name": "from_class"
                                  }
                                ]
                              }
                            },
                            {
                              "query": {
                                "operations": [
                                  {
                                    "property_name": "surge_linear_coeff"
                                  }
                                ]
                              }
                            },
                            {
                              "query": {
                                "operations": [
                                  {
                                    "property_name": "enabled"
                                  }
                                ]
                              }
                            }
                          ],
                          "query": {
                            "operations": [
                              {
                                "property_name": "linear_dependency_formula"
                              }
                            ]
                          }
                        }
                      ],
                      "query": {
                        "operations": [
                          {
                            "expression": "category"
                          }
                        ]
                      }
                    }
                  ],
                  "query": {
                    "operations": [
                      {
                        "property_name": "rules"
                      }
                    ]
                  }
                }
              ],
              "query": {
                "operations": [
                  {
                    "property_name": "experiment"
                  }
                ]
              }
            },
            {
              "query": {
                "operations": [
                  {
                    "property_name": "base_class"
                  }
                ]
              }
            }
          ],
          "domain": "resource",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "zone"
              }
            ]
          }
        },
        {
          "children": [
            {
              "children": [
                {
                  "query": {
                    "operations": [
                      {
                        "alias": "from_class_value_raw",
                        "property_name": "value_raw"
                      }
                    ]
                  }
                },
                {
                  "children": [
                    {
                      "query": {
                        "operations": [
                          {
                            "alias": "from_class_value",
                            "property_name": "value"
                          }
                        ]
                      }
                    }
                  ],
                  "query": {
                    "operations": [
                      {
                        "property_name": "surge"
                      }
                    ]
                  }
                },
                {
                  "children": [
                    {
                      "children": [
                        {
                          "query": {
                            "operations": [
                              {
                                "alias": "from_class_smooth_a",
                                "property_name": "point_a"
                              }
                            ]
                          }
                        },
                        {
                          "query": {
                            "operations": [
                              {
                                "alias": "from_class_smooth_b",
                                "property_name": "point_b"
                              }
                            ]
                          }
                        }
                      ],
                      "query": {
                        "operations": [
                          {
                            "property_name": "smooth"
                          }
                        ]
                      }
                    }
                  ],
                  "query": {
                    "operations": [
                      {
                        "property_name": "calculation_meta"
                      }
                    ]
                  }
                }
              ],
              "query": {
                "operations": [
                  {
                    "expression": "enabled ? from_class : base_class"
                  }
                ]
              }
            }
          ],
          "domain": "output",
          "optional": false,
          "query": {
            "operations": [
              {
                "property_name": "classes"
              }
            ]
          }
        }
      ],
      "name": "linear_dependency",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value_raw",
          "optional": false,
          "query": "classes[category].value_raw"
        },
        {
          "alias": "value",
          "optional": false,
          "query": "classes[category].surge.value"
        },
        {
          "alias": "smooth_a",
          "optional": false,
          "query": "classes[category].calculation_meta.smooth.point_a"
        },
        {
          "alias": "smooth_b",
          "optional": false,
          "query": "classes[category].calculation_meta.smooth.point_b"
        }
      ],
      "source_code": "function is_present(value) {\n    return value !== null && value !== undefined;\n}\n\nfunction require(value, description) {\n    if (!is_present(value)) {\n        throw 'no ' + description;\n    }\n}\n\nfunction normalized_smooth_b() {\n  let value = from_class_smooth_b;\n  if (value) {\n    if (typeof value === 'object' && 'value' in value && 'is_default' in value) {\n      return value;\n    } else {\n      log.warning('bad point_b value from bindings: ' + JSON.stringify({value: value}));\n    }\n  }\n  \n  return null;\n}\n\nconst kDefaultSurgeValue = 1.0;\n\nif (!enabled) {\n  // this is possible due to fallback_to_linear_dependency stage\n  from_class = base_class;\n  surge_linear_coeff = 1.0;\n}\n\nrequire(category, \"category\");\nrequire(from_class, \"from_class\");\nrequire(surge_linear_coeff, \"linear_coeff\");\nrequire(from_class_value_raw, \"from_class_value_raw\");\nrequire(from_class_value, \"from_class_value\");\nrequire(from_class_smooth_a, \"from_class_smooth_a\");\n\nif (category === from_class) {\n    throw \"Impossible to apply linear dependency from itself (\" + category + \")\";\n}\n\nreturn {\n    value_raw: from_class_value_raw,\n    value: kDefaultSurgeValue + surge_linear_coeff * (from_class_value - kDefaultSurgeValue),\n    smooth_a: from_class_smooth_a,\n    smooth_b: normalized_smooth_b(),\n};\n"
    },
    {
      "conditions": [
        {
          "args": [],
          "predicate": "is_linear_dependency_with_base_table_bounds_enabled",
          "type": "predicate"
        },
        {
          "args": [],
          "predicate": "is_in_zone_experiment",
          "type": "predicate"
        },
        {
          "args": [
            {
              "name": "value",
              "value": "use_base_class_table"
            }
          ],
          "predicate": "is_true",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "domain": "output",
          "optional": false,
          "query": "classes.*{category:}.surge.value"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.rules[category].linear_dependency_formula.use_base_class_table"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.rules[category].surge_min_bound"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.rules[category].surge_max_bound"
        }
      ],
      "name": "linear_dependency_with_base_table_bound_coeffs",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "optional": false,
          "query": "classes[category].surge.value"
        }
      ],
      "source_code": "function value_or_number(value, default_value) {\n    return typeof value === 'number' ? value : default_value;\n}\n\nlet min_surge = value_or_number(surge_min_bound, 1.0);\nlet max_surge = value_or_number(surge_max_bound, 4.0);\n\nreturn {value: Math.max(Math.min(value, max_surge), min_surge)};\n"
    },
    {
      "conditions": [
        {
          "args": [
            {
              "name": "category",
              "value": "category"
            }
          ],
          "predicate": "is_antisurge_disabled",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "domain": "output",
          "optional": false,
          "query": "classes.*{category:}.surge.value"
        }
      ],
      "name": "antisurge_bound_coeffs",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "optional": false,
          "query": "classes[category].surge.value"
        }
      ],
      "source_code": "\n    const kDefaultSurgeValue = 1.0;\n    return {value: Math.max(value, kDefaultSurgeValue)};\n"
    },
    {
      "conditions": [
        {
          "args": [],
          "predicate": "is_surcharge_enabled",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.base_class"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.rules"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.balance.table_coef_ps"
        },
        {
          "domain": "output",
          "optional": false,
          "query": "classes.*{category:}.surge.value"
        }
      ],
      "name": "fill_surcharge",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "optional": false,
          "query": "classes[category].surge.value"
        },
        {
          "alias": "surcharge",
          "optional": false,
          "query": "classes[category].surge.surcharge"
        }
      ],
      "source_code": "\n    const kDefaultSurge = 1.0;\n    const kDefaultSurcharge = {\n        alpha: 1.0,\n        beta: 0.0,\n        value: 0.0,\n    };\n\n    Object.freeze(kDefaultSurcharge);\n\n    function is_present(value) {\n        return value !== null && value !== undefined;\n    }\n\n    function is_number(value) {\n        return typeof value === 'number';\n    }\n\n    function find_closest(iterable, get_deviation) {\n        let selected_item = undefined;\n        let deviation = undefined;\n        for (let item of iterable) {\n            let current_deviation = Math.abs(get_deviation(item));\n            if (!is_present(deviation) || current_deviation < deviation) {\n                selected_item = item;\n                deviation = current_deviation;\n            }\n        }\n        return selected_item;\n    }\n\n    let seen_categories = new Set();\n\n    function get_surcharge_and_surge(current_category, recursive) {\n        seen_categories.add(current_category);\n\n        if (current_category === base_class) {\n            if (is_present(table_coef_ps)) {\n                let selected_table_coef_item = find_closest(table_coef_ps, item => item.coeff - value);\n                if (selected_table_coef_item) {\n                    return {\n                        value: selected_table_coef_item.coeff,\n                        surcharge: {\n                            alpha: selected_table_coef_item.alpha,\n                            beta: selected_table_coef_item.beta,\n                            value: selected_table_coef_item.surcharge,\n                        }\n                    };\n                }\n            }\n        } else {\n            let rule = rules[current_category];\n            if (rule) {\n                if (recursive) {\n                    let linear_dependency = rule.linear_dependency_formula;\n                    if (linear_dependency && linear_dependency.use_base_class_table) {\n                        // https://st.yandex-team.ru/EFFICIENCYDEV-3719\n                        if (linear_dependency.from_class !== base_class || value >= kDefaultSurge) {\n                            if (seen_categories.has(linear_dependency.from_class)) {\n                                log.error(\"cyclic linear dependency: rerunning with disabled recursive table lookup\");\n                                // degradation: get first seen category and\n                                // rerun function with recursive table lookup disabled\n                                return get_surcharge_and_surge(seen_categories.values().next().value, /*recursive=*/false);\n                            }\n                            return get_surcharge_and_surge(linear_dependency.from_class, recursive);\n                        }\n                    }\n                }\n\n                let selected_surge_rules_item = find_closest(rule.surge_rules, item => item.surge_value - value);\n                if (selected_surge_rules_item) {\n                    return {\n                        value: selected_surge_rules_item.surge_value,\n                        surcharge: {\n                            alpha: selected_surge_rules_item.alpha,\n                            beta: selected_surge_rules_item.beta,\n                            value: selected_surge_rules_item.surcharge,\n                        }\n                    };\n                }\n            }\n        }\n\n        return {value: value, surcharge: kDefaultSurcharge};\n    }\n\n    let result = get_surcharge_and_surge(category, /*recursive=*/true);\n\n    if (!is_number(result.value)) {\n        log.error('no surge value! default surcharge will be used');\n        return {value: value, surcharge: kDefaultSurcharge};\n    }\n\n    let surcharge_coeffs = Object.values(result.surcharge);\n\n    if (!surcharge_coeffs.some(is_number)) {\n        // no surcharge params at all - use default but keep value from table\n        result.surcharge = kDefaultSurcharge;\n    } else if (!surcharge_coeffs.every(is_number)) {\n        // incomplete surcharge params - considered ill formed - discard table\n        log.warning('inconsistent surcharge params! default surcharge will be used');\n        return {value: value, surcharge: kDefaultSurcharge};\n    }\n\n    return result;\n"
    },
    {
      "conditions": [],
      "in_bindings": [
        {
          "domain": "resource",
          "optional": false,
          "query": "config.surge_coefficient_precision{precision}"
        },
        {
          "domain": "output",
          "optional": false,
          "query": "classes.*{category:}.surge.value"
        }
      ],
      "name": "round_coeffs",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "optional": false,
          "query": "classes[category].surge.value"
        }
      ],
      "source_code": "\n    const factor = Math.pow(10, precision);\n    return {value: Math.round(value * factor) / factor};\n"
    },
    {
      "conditions": [
        {
          "args": [],
          "predicate": "is_not_due",
          "type": "predicate"
        },
        {
          "args": [],
          "predicate": "is_explicit_antisurge_enabled",
          "type": "predicate"
        },
        {
          "args": [
            {
              "name": "value",
              "value": "value"
            }
          ],
          "predicate": "is_explicit_antisurge_satisfied",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.explicit_antisurge_threshold{threshold}"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.base_class"
        },
        {
          "domain": "output",
          "optional": false,
          "query": "classes[base_class].surge.value"
        },
        {
          "domain": "output",
          "optional": false,
          "query": "classes[base_class].surge.surcharge"
        },
        {
          "domain": "output",
          "optional": false,
          "query": "classes[base_class].calculation_meta.smooth.point_b.is_default{point_b_smooth_is_default}"
        }
      ],
      "name": "segregate_explicit_antisurge",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "optional": false,
          "query": "classes[base_class].surge.value"
        },
        {
          "alias": "surcharge",
          "optional": false,
          "query": "classes[base_class].surge.surcharge"
        },
        {
          "alias": "explicit_antisurge",
          "optional": false,
          "query": "classes[base_class].explicit_antisurge"
        }
      ],
      "source_code": "\n    const has_actual_point_b_surge = point_b_smooth_is_default === false;\n\n    function copy_object(object) {\n        return Object.assign({}, object);\n    }\n\n    let result = {\n        value: value,\n        surcharge: surcharge,\n        explicit_antisurge: null,\n    };\n\n    if (has_actual_point_b_surge) {\n        result.explicit_antisurge = {\n            value: value,\n            // FIXME: surcharge object should be explicitly copied because\n            //  its copying and changing is done in single stage.\n            //  Otherwise out bindings order should be respected:\n            //  first - copy, second - change\n            surcharge: surcharge ? copy_object(surcharge) : null,\n        };\n    } else {\n        log.info(\"Explicit antisurge: hidden only - no actual point b surge\");\n    }\n\n    result.value = threshold;\n    result.surcharge = null;\n\n    return result;\n"
    },
    {
      "conditions": [
        {
          "args": [],
          "predicate": "is_surcharge_enabled",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.base_class"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.base_class{category}"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.rules"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.experiment.balance.table_coef_ps"
        },
        {
          "domain": "output",
          "optional": false,
          "query": "classes[category].surge.value"
        }
      ],
      "name": "fill_base_class_surcharge",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "optional": false,
          "query": "classes[category].surge.value"
        },
        {
          "alias": "surcharge",
          "optional": false,
          "query": "classes[category].surge.surcharge"
        }
      ],
      "source_code": "\n    const kDefaultSurge = 1.0;\n    const kDefaultSurcharge = {\n        alpha: 1.0,\n        beta: 0.0,\n        value: 0.0,\n    };\n\n    Object.freeze(kDefaultSurcharge);\n\n    function is_present(value) {\n        return value !== null && value !== undefined;\n    }\n\n    function is_number(value) {\n        return typeof value === 'number';\n    }\n\n    function find_closest(iterable, get_deviation) {\n        let selected_item = undefined;\n        let deviation = undefined;\n        for (let item of iterable) {\n            let current_deviation = Math.abs(get_deviation(item));\n            if (!is_present(deviation) || current_deviation < deviation) {\n                selected_item = item;\n                deviation = current_deviation;\n            }\n        }\n        return selected_item;\n    }\n\n    let seen_categories = new Set();\n\n    function get_surcharge_and_surge(current_category, recursive) {\n        seen_categories.add(current_category);\n\n        if (current_category === base_class) {\n            if (is_present(table_coef_ps)) {\n                let selected_table_coef_item = find_closest(table_coef_ps, item => item.coeff - value);\n                if (selected_table_coef_item) {\n                    return {\n                        value: selected_table_coef_item.coeff,\n                        surcharge: {\n                            alpha: selected_table_coef_item.alpha,\n                            beta: selected_table_coef_item.beta,\n                            value: selected_table_coef_item.surcharge,\n                        }\n                    };\n                }\n            }\n        } else {\n            let rule = rules[current_category];\n            if (rule) {\n                if (recursive) {\n                    let linear_dependency = rule.linear_dependency_formula;\n                    if (linear_dependency && linear_dependency.use_base_class_table) {\n                        // https://st.yandex-team.ru/EFFICIENCYDEV-3719\n                        if (linear_dependency.from_class !== base_class || value >= kDefaultSurge) {\n                            if (seen_categories.has(linear_dependency.from_class)) {\n                                log.error(\"cyclic linear dependency: rerunning with disabled recursive table lookup\");\n                                // degradation: get first seen category and\n                                // rerun function with recursive table lookup disabled\n                                return get_surcharge_and_surge(seen_categories.values().next().value, /*recursive=*/false);\n                            }\n                            return get_surcharge_and_surge(linear_dependency.from_class, recursive);\n                        }\n                    }\n                }\n\n                let selected_surge_rules_item = find_closest(rule.surge_rules, item => item.surge_value - value);\n                if (selected_surge_rules_item) {\n                    return {\n                        value: selected_surge_rules_item.surge_value,\n                        surcharge: {\n                            alpha: selected_surge_rules_item.alpha,\n                            beta: selected_surge_rules_item.beta,\n                            value: selected_surge_rules_item.surcharge,\n                        }\n                    };\n                }\n            }\n        }\n\n        return {value: value, surcharge: kDefaultSurcharge};\n    }\n\n    let result = get_surcharge_and_surge(category, /*recursive=*/true);\n\n    if (!is_number(result.value)) {\n        log.error('no surge value! default surcharge will be used');\n        return {value: value, surcharge: kDefaultSurcharge};\n    }\n\n    let surcharge_coeffs = Object.values(result.surcharge);\n\n    if (!surcharge_coeffs.some(is_number)) {\n        // no surcharge params at all - use default but keep value from table\n        result.surcharge = kDefaultSurcharge;\n    } else if (!surcharge_coeffs.every(is_number)) {\n        // incomplete surcharge params - considered ill formed - discard table\n        log.warning('inconsistent surcharge params! default surcharge will be used');\n        return {value: value, surcharge: kDefaultSurcharge};\n    }\n\n    return result;\n"
    },
    {
      "conditions": [],
      "in_bindings": [
        {
          "domain": "resource",
          "optional": false,
          "query": "zone.base_class"
        },
        {
          "domain": "resource",
          "optional": false,
          "query": "config.surge_coefficient_precision{precision}"
        },
        {
          "domain": "output",
          "optional": false,
          "query": "classes[base_class].surge.value"
        }
      ],
      "name": "round_base_class_coeffs",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "optional": false,
          "query": "classes[base_class].surge.value"
        }
      ],
      "source_code": "\n    const factor = Math.pow(10, precision);\n    return {value: Math.round(value * factor) / factor};\n"
    }
  ],
  "state": "active"
}
