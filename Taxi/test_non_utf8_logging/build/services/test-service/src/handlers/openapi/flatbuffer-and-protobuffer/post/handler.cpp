/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s):
// taxi/uservices/services/test-service/docs/yaml/api/api.yaml,
// taxi/uservices/services/test-service/docs/yaml/api/openapi.yaml

#include <handlers/openapi/flatbuffer-and-protobuffer/post/handler.hpp>

#include <optional>
#include <string_view>

#include <fmt/format.h>
#include <clients/codegen/exception.hpp>
#include <userver/components/component_config.hpp>
#include <userver/http/common_headers.hpp>
#include <userver/http/content_type.hpp>
#include <userver/server/handlers/exceptions.hpp>
#include <userver/server/handlers/json_error_builder.hpp>
#include <userver/server/handlers/legacy_json_error_builder.hpp>
#include <userver/server/http/http_response.hpp>
#include <userver/tracing/span.hpp>

#include <handlers/dependencies.hpp>
#include <handlers/openapi/flatbuffer-and-protobuffer/post/request.hpp>
#include <handlers/openapi/flatbuffer-and-protobuffer/post/response.hpp>

#include <codegen/impl/call_user_view_handle.hpp>
#include <codegen/impl/json_in_context.hpp>
#include <codegen/impl/logging_meta.hpp>
#include <codegen/raw_request_body.hpp>

// User class
#include <views/openapi/flatbuffer-and-protobuffer/post/view.hpp>

// This and the following files have tight dependencies. We compile them in one
// go, as a single translation unit.
#define USERVER_CODEGEN_IPP_INSTANTIATION_GUARD
#include <handlers/openapi/flatbuffer-and-protobuffer/post/request.ipp>
#include <handlers/openapi/flatbuffer-and-protobuffer/post/response.ipp>

#undef USERVER_CODEGEN_IPP_INSTANTIATION_GUARD

namespace codegen::impl {
inline const std::string kRequestObjectDataName = "__request_object";
inline const std::string kResponseObjectDataName = "__response_object";
}

namespace handlers::openapi_flatbuffer_and_protobuffer::post {

namespace {

namespace impl {

Request ParseRequest(const server::http::HttpRequest& http_request,
                     const formats::json::Value* json_body,
                     server::request::RequestContext& context)
{
  try {
    return Request(http_request, json_body, context);
  } catch (const server::handlers::CustomHandlerException& e)
  {
    // Correct exception type, proxy it as-is
    throw;
  } catch (const formats::json::Exception& e) {
    throw server::handlers::RequestParseError(
        server::handlers::ExternalBody{e.what()},  // safe exception text
        server::handlers::InternalMessage{
            std::string("JSON exception while parsing request: ") + e.what()});
  } catch (const std::exception& e) {
    throw server::handlers::RequestParseError(
        server::handlers::ExternalBody{"Failed to parse request"},
        server::handlers::InternalMessage{
            std::string("Unhandled exception while parsing request: ") +
            e.what()});
  }
}

Response DoHandle(Request&& request, handlers::Dependencies&& dependencies,
                  server::request::RequestContext& context) {
  return codegen::impl::CallUserViewHandle<
      ::handlers::openapi_flatbuffer_and_protobuffer::post::View>(
      std::move(request), std::move(dependencies), context);
}

Response Handle(Request&& request, handlers::Dependencies&& dependencies,
                bool proxy_too_many_requests_error,
                server::request::RequestContext& context) {
  try {
    return impl::DoHandle(std::move(request), std::move(dependencies), context);
  } catch (const clients::codegen::ExceptionWithStatusCode& e)
  {
    if (e.GetStatusCode() == 429 && proxy_too_many_requests_error)
    {
      using namespace ::server::handlers;
      using namespace ::http::headers;
      const auto& exc = dynamic_cast<const std::exception&>(e);

      ExtraHeaders exc_headers;
      for (const auto& name :
           {kXYaTaxiRatelimitReason, kXYaTaxiRatelimitedBy}) {
        auto value = e.GetHeader(name);
        if (value.empty()) continue;

        exc_headers.headers[name] = std::move(value);
      }

      throw ExceptionWithCode<HandlerErrorCode::kTooManyRequests>{
          ExternalBody{"Too Many Requests"},
          InternalMessage{fmt::format(
              "Propagated client 429 error to handlers, original message: {}",
              exc.what())},
          std::move(exc_headers),
      };
    }

    throw;
  }
}

}  // namespace impl

}  // namespace

Handler::Handler(const components::ComponentConfig& config,
                 const components::ComponentContext& context)
    : HttpHandlerBase(config, context),
      deps_factory_(
          std::make_unique<handlers::DependenciesFactory>(config, context)),
      proxy_too_many_requests_error_(
          config["propagate-client-errors"]["ratelimit"].As<bool>(false))

{}

Handler::~Handler() = default;

::server::handlers::FormattedErrorData Handler::GetFormattedExternalErrorBody(
    const ::server::handlers::CustomHandlerException& exc) const {
  return {exc.GetExternalErrorBody()};
}

void Handler::ParseRequestData(const server::http::HttpRequest& http_request,
                               server::request::RequestContext& context) const {
  HttpHandlerBase::ParseRequestData(http_request, context);

  Request request = [&] {
    if constexpr (::codegen::impl::kHasJsonLogRequestFunction<
                      ::handlers::openapi_flatbuffer_and_protobuffer::post::
                          View, Request>) {
      formats::json::Value request_json;
      try {
        if (!http_request.RequestBody().empty())
          request_json = formats::json::FromString(http_request.RequestBody());
      } catch (const formats::json::Exception& e) {
        throw ::server::handlers::RequestParseError(
            ::server::handlers::InternalMessage{"Invalid JSON body"},
            ::server::handlers::ExternalBody{
                std::string("Invalid JSON body: ") + e.what()});
      }

      ::codegen::impl::SetRequestJson(context, request_json);
      return impl::ParseRequest(http_request, &request_json, context);
    } else {
      return impl::ParseRequest(http_request, nullptr, context);
    }
  }();

  request.SetSpanTags();

  context.SetData(::codegen::impl::kRequestObjectDataName, std::move(request));
}

std::string Handler::HandleRequestThrow(
    const server::http::HttpRequest& http_request,
    server::request::RequestContext& context) const {
  // GetRequestBodyForLogging is already called at this point, so it is safe to
  // move out the data
  auto request = std::move(
      context.GetData<Request>(::codegen::impl::kRequestObjectDataName));
  context.EraseData(::codegen::impl::kRequestObjectDataName);

  context.SetData<std::string_view>(::codegen::kRawRequestBodyDataName,
                                    http_request.RequestBody());

  handlers::Dependencies dependencies = deps_factory_->GetDependencies();

  auto response_holder =
      impl::Handle(std::move(request), std::move(dependencies),
                   proxy_too_many_requests_error_, context);

  const Response* response = &response_holder;

  constexpr bool kHasLogResponse =
      (::codegen::impl::kHasNonJsonLogResponseFunction<
           ::handlers::openapi_flatbuffer_and_protobuffer::post::View,
           Response> ||
       ::codegen::impl::HasTwoResponseLoggingFunctions<
           ::handlers::openapi_flatbuffer_and_protobuffer::post::View,
           Response>());
  if constexpr (kHasLogResponse) {
    response = &context.SetData(::codegen::impl::kResponseObjectDataName,
                                std::move(response_holder));
  }

  const auto scope_time = tracing::Span::CurrentSpan().CreateScopeTime(
      "http_serialize_response_data");

  post::FillHttpResponse(http_request.GetHttpResponse(), *response);
  return ToString(*response);
}

std::string Handler::GetRequestBodyForLogging(
    const server::http::HttpRequest& request,
    server::request::RequestContext& context,
    const std::string& request_body) const {
  return DoGetRequestBodyForLogging<
      ::handlers::openapi_flatbuffer_and_protobuffer::post::View>(
      request, context, request_body);
}

template <typename ViewType>
std::string Handler::DoGetRequestBodyForLogging(
    [[maybe_unused]] const server::http::HttpRequest& request,
    server::request::RequestContext& context,
    const std::string& request_body) const {
  static_assert(
      !(::codegen::impl::kHasJsonLogRequestFunction<ViewType, Request> &&
        ::codegen::impl::kHasNonJsonLogRequestFunction<ViewType, Request>),
      "Two GetRequestBodyForLogging() overloads detected!");

  if constexpr (::codegen::impl::kHasLogRequestFunction<ViewType>) {
    static_assert(
        ::codegen::impl::kHasJsonLogRequestFunction<ViewType, Request> ||
            ::codegen::impl::kHasNonJsonLogRequestFunction<ViewType, Request>,
        "Incorrect definition of GetRequestBodyForLogging() method. "
        "Should be: static std::string GetRequestBodyForLogging("
        "const Request* request, "
        "const formats::json::Value* request_json, "
        "const std::string& request_body); or "
        "static std::string GetRequestBodyForLogging("
        "const Request* request, "
        "const std::string& request_body);");

    auto req = context.GetDataOptional<Request>(
        ::codegen::impl::kRequestObjectDataName);

    if constexpr (::codegen::impl::kHasNonJsonLogRequestFunction<ViewType,
                                                                 Request>)
    {
      return ViewType::GetRequestBodyForLogging(req, request_body);

    } else {
      return ViewType::GetRequestBodyForLogging(
          req, ::codegen::impl::GetRequestJson(context), request_body);
    }
  } else {
    return HttpHandlerBase::GetRequestBodyForLogging(request, context,
                                                     request_body);
  }
}

std::string Handler::GetResponseDataForLogging(
    const server::http::HttpRequest& request,
    server::request::RequestContext& context,
    const std::string& response_data) const {
  return DoGetResponseDataForLogging<
      ::handlers::openapi_flatbuffer_and_protobuffer::post::View>(
      request, context, response_data);
}

template <typename ViewType>
std::string Handler::DoGetResponseDataForLogging(
    [[maybe_unused]] const server::http::HttpRequest& request,
    server::request::RequestContext& context,
    const std::string& response_data) const {
  if constexpr (::codegen::impl::HasTwoResponseLoggingFunctions<ViewType,
                                                                Response>()) {
    auto response = context.GetDataOptional<Response>(
        ::codegen::impl::kResponseObjectDataName);
    return (
        response
            ? ViewType::GetResponseForLogging(*response, response_data, context)
            : ViewType::GetNonSchemaResponseForLogging(response_data, context));
  } else if constexpr (::codegen::impl::kHasLogResponseFunction<ViewType>) {
    auto response = context.GetDataOptional<Response>(
        ::codegen::impl::kResponseObjectDataName);
    static_assert(
        ::codegen::impl::kHasNonJsonLogResponseFunction<ViewType, Response>,
        "Incorrect definition of GetResponseDataForLogging() method. "
        "Use two functions instead: "
        "static std::string GetResponseForLogging("
        "const Response& , ::server::request::RequestContext& );"
        "static std::string GetNonSchemaResponseForLogging("
        "const std::string& , ::server::request::RequestContext& );");

    return ViewType::GetResponseDataForLogging(response, response_data);
  } else {
    return fmt::format("<binary buffer, total {} bytes>", response_data.size());
  }
}

yaml_config::Schema Handler::GetStaticConfigSchema() {
  return codegen::impl::GetDependenciesSchema<custom::Dependencies>();
}

}
