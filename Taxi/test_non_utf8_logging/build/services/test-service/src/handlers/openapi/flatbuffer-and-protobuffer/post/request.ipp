#ifndef USERVER_CODEGEN_IPP_INSTANTIATION_GUARD
#error DO NOT INCLUDE THIS FILE! INCLUDE THE FILE WITH *.hpp EXTENSION!
#endif

/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s):
// taxi/uservices/services/test-service/docs/yaml/api/api.yaml,
// taxi/uservices/services/test-service/docs/yaml/api/openapi.yaml

#include <handlers/openapi/flatbuffer-and-protobuffer/post/request.hpp>

#include <codegen/impl/convert.hpp>
#include <codegen/impl/get_validation_length.hpp>
#include <codegen/impl/optional_convert.hpp>
#include <codegen/impl/parsers.hpp>
#include <cstring>
#include <unordered_set>
#include <userver/formats/common/meta.hpp>
#include <userver/formats/json/string_builder.hpp>
#include <userver/logging/log.hpp>
#include <userver/utils/assert.hpp>
#include <userver/utils/datetime/from_string_saturating.hpp>
#include <userver/utils/underlying_value.hpp>

#include <codegen/impl/convert.hpp>

#include <boost/algorithm/string/join.hpp>
#include <boost/uuid/uuid_io.hpp>
#include <codegen/impl/convert.hpp>
#include <codegen/impl/parsers.hpp>
#include <userver/utils/datetime/from_string_saturating.hpp>

#include <userver/formats/json/serialize.hpp>
#include <userver/formats/json/value.hpp>
#include <userver/http/common_headers.hpp>
#include <userver/http/content_type.hpp>
#include <userver/server/handlers/exceptions.hpp>
#include <userver/server/http/http_request.hpp>
#include <userver/tracing/span.hpp>
#include <userver/utils/assert.hpp>

#include <codegen/impl/split_by.hpp>
#include <codegen/prepare_json.hpp>
#include <userver/formats/parse/common_containers.hpp>

namespace handlers::openapi_flatbuffer_and_protobuffer::post {

handlers::openapi_flatbuffer_and_protobuffer::post::Body Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<
        handlers::openapi_flatbuffer_and_protobuffer::post::Body>) {
  handlers::openapi_flatbuffer_and_protobuffer::post::Body result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PBody::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PBody::ParserLocalDomToType<To>::Convert(::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PBody::PBody()
{}

void PBody::Reset()
{
  state_ = State::kStart;
  result_ = {};
}

void PBody::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PBody::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PBody::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      SetResult(std::move(result_));
      break;
  }
}

std::string PBody::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PBody::GetPathItem() const { return key_; }
}

formats::json::Value Serialize(
    [[maybe_unused]] const handlers::openapi_flatbuffer_and_protobuffer::post::
        Body& value, ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const handlers::
                       openapi_flatbuffer_and_protobuffer::post::Body& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);
}

logging::LogHelper& operator<<(
    logging::LogHelper& lh,
    const handlers::openapi_flatbuffer_and_protobuffer::post::Body& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

Request::Request([[maybe_unused]] const server::http::HttpRequest& http_request,
                 [[maybe_unused]] const formats::json::Value* json_body,
                 [[maybe_unused]] ::server::request::RequestContext& context)
{
  if (json_body) {
    // We already have json::Value, so it's faster to parse DOM
    // instead of parsing SAX from the beginning.
    ::tracing::Span::CurrentSpan().AddNonInheritableTag("dom_parsed", 1);

    this->body =
        (*json_body)
            .As<handlers::openapi_flatbuffer_and_protobuffer::post::Body>();
  } else {
    // No DOM model, just use SAX parser (if available)
    ::tracing::Span::CurrentSpan().AddNonInheritableTag("sax_parsed", 1);

    const auto body = ::codegen::PrepareJsonString(http_request.RequestBody());
    this->body = [](std::string_view sw) {
      handlers::openapi_flatbuffer_and_protobuffer::post::Body result;
      // .cpp_type: handlers::openapi_flatbuffer_and_protobuffer::post::Body
      // .optional_subtype: None
      // cpp_type: handlers::openapi_flatbuffer_and_protobuffer::post::Body
      handlers::openapi_flatbuffer_and_protobuffer::post::parser::PBody parser;

      parser.Reset();
      ::formats::json::parser::SubscriberSink sink(result);
      parser.Subscribe(sink);

      formats::json::parser::ParserState state;
      state.PushParser(parser.GetParser());
      state.ProcessInput(sw);
      return result;
    }(body);
  }

  static const http::ContentType kAllowedContentType[] = {
      "application/json",
  };
  try {
    const http::ContentType request_content_type =
        http_request.GetHeader(http::headers::kContentType);
    if (std::find_if(
            std::begin(kAllowedContentType), std::end(kAllowedContentType),
            [&request_content_type](const http::ContentType& allowed_range) {
              return allowed_range.DoesAccept(request_content_type);
            }) == std::end(kAllowedContentType)) {
      auto msg = std::string("Invalid ") + http::headers::kContentType +
                 ", must be one of ['application/json'], got '" +
                 request_content_type.ToString() + "'";
      throw server::handlers::ClientError(
          server::handlers::ExternalBody{msg},
          server::handlers::InternalMessage{msg});
    }
  } catch (const http::MalformedContentType& ex) {
    throw server::handlers::ClientError(
        server::handlers::ExternalBody{std::string("Malformed ") +
                                       http::headers::kContentType},
        server::handlers::InternalMessage{ex.what()});
  }
}

void Request::SetSpanTags() const {}

}
