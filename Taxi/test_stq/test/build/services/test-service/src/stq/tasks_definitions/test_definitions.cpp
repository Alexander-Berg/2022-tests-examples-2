/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s):
// taxi/uservices/services/test-service/docs/stq/definitions/test_definitions.yaml

#include <stq/tasks_definitions/test_definitions.hpp>

#include <userver/formats/serialize/common_containers.hpp>

#include <codegen/impl/convert.hpp>
#include <codegen/impl/get_validation_length.hpp>
#include <codegen/impl/optional_convert.hpp>
#include <codegen/impl/parsers.hpp>
#include <cstring>
#include <unordered_set>
#include <userver/formats/common/meta.hpp>
#include <userver/formats/json/string_builder.hpp>
#include <userver/logging/log.hpp>
#include <userver/utils/assert.hpp>
#include <userver/utils/datetime.hpp>
#include <userver/utils/datetime/from_string_saturating.hpp>
#include <userver/utils/underlying_value.hpp>

namespace stq_tasks::test_definitions {

stq_tasks::test_definitions::TestObject Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<stq_tasks::test_definitions::TestObject>) {
  stq_tasks::test_definitions::TestObject result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.bool_property = elem["bool_property"].As<std::optional<bool>>();
  result.string_property = elem["string_property"].As<std::string>();

  return result;
}

formats::json::Value Serialize(
    [[maybe_unused]] const stq_tasks::test_definitions::TestObject& value,
    ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  if (value.bool_property)
    builder.EmplaceNocheck("bool_property", *value.bool_property);
  builder.EmplaceNocheck("string_property", value.string_property);
  return builder.ExtractValue();
}

void WriteToStream(
    [[maybe_unused]] const stq_tasks::test_definitions::TestObject& value,
    formats::json::StringBuilder& sw, [[maybe_unused]] bool hide_brackets,
    [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);

  if (!hide_field_name || std::strcmp(hide_field_name, "bool_property"))
  {
    if (value.bool_property)
    {
      sw.Key("bool_property");

      WriteToStream(*value.bool_property, sw);
    }
  }
  if (!hide_field_name || std::strcmp(hide_field_name, "string_property"))
  {
    sw.Key("string_property");

    WriteToStream(value.string_property, sw);
  }
}

}
namespace stq_tasks::test_definitions {

stq_tasks::test_definitions::Datetime Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<stq_tasks::test_definitions::Datetime>) {
  stq_tasks::test_definitions::Datetime result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result._date = elem["$date"].As<std::chrono::system_clock::time_point>();

  return result;
}

formats::json::Value Serialize(
    [[maybe_unused]] const stq_tasks::test_definitions::Datetime& value,
    ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  builder.EmplaceNocheck("$date", value._date);
  return builder.ExtractValue();
}

void WriteToStream(
    [[maybe_unused]] const stq_tasks::test_definitions::Datetime& value,
    formats::json::StringBuilder& sw, [[maybe_unused]] bool hide_brackets,
    [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);

  if (!hide_field_name || std::strcmp(hide_field_name, "$date"))
  {
    sw.Key("$date");

    WriteToStream(value._date, sw);
  }
}

}
