#pragma once

/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

#include <chrono>
#include <ios>
#include <optional>
#include <vector>

#include <userver/formats/bson/value.hpp>
#include <userver/formats/json/value_builder.hpp>
#include <userver/storages/postgres/result_set.hpp>

#include <api_base/model.hpp>

namespace api_over_db::models {

namespace proxy1 {

struct Proxy1 {
  using Timestamp = formats::bson::Timestamp;

  std::size_t Save(std::ostream& out) const;

  void Load(std::istream& in);

  bool IsDeleted() const { return false; }

  Timestamp GetTimestamp() const;
  // implement this function by hand
  ::std::string GetId() const;
  formats::json::ValueBuilder ToJson(
      std::optional<utils::Projection> projection = std::nullopt) const;
  static formats::json::ValueBuilder GetAbsentObjectJson(const std::string& id);

  // returns json field name if the corresponding mongo field could be removed
  // from mongo projection
  static const std::vector<std::string>& GetRemovableJsonNamesForMongoName(
      const std::string& db_name);

  bool operator==(const Proxy1& other) const;
  bool operator!=(const Proxy1& other) const { return !(*this == other); }
};

Proxy1 Parse(const formats::bson::Value& elem, formats::parse::To<Proxy1>);

const api_over_db::utils::Projection& GetAllJsonFields();

}

namespace replica1 {

struct Replica1 {
  using Timestamp = formats::bson::Timestamp;

  // db field: mongo-some1-field1
  // json field: data.json-some1-field1
  ::std::vector<std::string> some1_field1;
  // db field: mongo-some1-updated
  // json field: (no json name)
  ::formats::bson::Timestamp some1_updated;

  std::size_t Save(std::ostream& out) const;

  void Load(std::istream& in);

  // db field: (no db name)
  // json field: json-some1-deleted
  bool some1_deleted{false};

  bool IsDeleted() const { return some1_deleted; }

  Timestamp GetTimestamp() const;
  // implement this function by hand
  ::std::string GetId() const;
  formats::json::ValueBuilder ToJson(
      std::optional<utils::Projection> projection = std::nullopt) const;
  static formats::json::ValueBuilder GetAbsentObjectJson(const std::string& id);

  // returns json field name if the corresponding mongo field could be removed
  // from mongo projection
  static const std::vector<std::string>& GetRemovableJsonNamesForMongoName(
      const std::string& db_name);

  bool operator==(const Replica1& other) const;
  bool operator!=(const Replica1& other) const { return !(*this == other); }
};

Replica1 Parse(const formats::bson::Value& elem, formats::parse::To<Replica1>);

const api_over_db::utils::Projection& GetAllJsonFields();

}

namespace replica2 {

struct Replica2 {
  using Timestamp = formats::bson::Timestamp;

  // db field: mongo-some2-updated
  // json field: (no json name)
  ::formats::bson::Timestamp some2_updated;

  std::size_t Save(std::ostream& out) const;

  void Load(std::istream& in);

  // db field: (no db name)
  // json field: json-some2-deleted
  bool some2_deleted{false};

  bool IsDeleted() const { return some2_deleted; }

  Timestamp GetTimestamp() const;
  // implement this function by hand
  ::std::string GetId() const;
  formats::json::ValueBuilder ToJson(
      std::optional<utils::Projection> projection = std::nullopt) const;
  static formats::json::ValueBuilder GetAbsentObjectJson(const std::string& id);

  // returns json field name if the corresponding mongo field could be removed
  // from mongo projection
  static const std::vector<std::string>& GetRemovableJsonNamesForMongoName(
      const std::string& db_name);

  bool operator==(const Replica2& other) const;
  bool operator!=(const Replica2& other) const { return !(*this == other); }
};

Replica2 Parse(const formats::bson::Value& elem, formats::parse::To<Replica2>);

const api_over_db::utils::Projection& GetAllJsonFields();

}

namespace replica3 {

struct Replica3 {
  using Timestamp = formats::bson::Timestamp;

  // db field: mongo-some3-field1
  // json field: data.json-some3-field1
  bool some3_field1;
  // db field: mongo-some3-updated
  // json field: (no json name)
  ::formats::bson::Timestamp some3_updated;

  std::size_t Save(std::ostream& out) const;

  void Load(std::istream& in);

  // db field: (no db name)
  // json field: json-some3-deleted
  bool some3_deleted{false};

  bool IsDeleted() const { return some3_deleted; }

  Timestamp GetTimestamp() const;
  // implement this function by hand
  ::std::string GetId() const;
  formats::json::ValueBuilder ToJson(
      std::optional<utils::Projection> projection = std::nullopt) const;
  static formats::json::ValueBuilder GetAbsentObjectJson(const std::string& id);

  // returns json field name if the corresponding mongo field could be removed
  // from mongo projection
  static const std::vector<std::string>& GetRemovableJsonNamesForMongoName(
      const std::string& db_name);

  bool operator==(const Replica3& other) const;
  bool operator!=(const Replica3& other) const { return !(*this == other); }
};

Replica3 Parse(const formats::bson::Value& elem, formats::parse::To<Replica3>);

const api_over_db::utils::Projection& GetAllJsonFields();

}

}
