/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

#include <api_over_db/api_over_db_model.hpp>

#include <userver/formats/parse/common_containers.hpp>
#include <userver/formats/parse/variant.hpp>

#include <api_base/utils.hpp>

namespace {

template <class T>
formats::json::ValueBuilder ConvertToJson(
    const T& value, const api_over_db::utils::JsonConversionOptions& opt) {
  return api_over_db::utils::ConvertToJson(value, opt);
}

}

namespace formats::bson {

std::optional<std::chrono::system_clock::time_point> Convert(
    const formats::bson::Value& elem,
    formats::parse::To<std::optional<std::chrono::system_clock::time_point>>) {
  if (elem.IsMissing() || elem.IsNull()) return std::nullopt;
  return elem.ConvertTo<std::chrono::system_clock::time_point>();
}

std::chrono::system_clock::time_point Convert(
    const formats::bson::Value& elem,
    formats::parse::To<std::chrono::system_clock::time_point>) {
  return elem.As<std::chrono::system_clock::time_point>();
}

}

namespace api_over_db::models {

namespace proxy1 {

Proxy1 Parse(const formats::bson::Value& elem, formats::parse::To<Proxy1>) {
  Proxy1 result;

  return result;
}

formats::json::ValueBuilder ConvertToJson(
    [[maybe_unused]] const Proxy1& value,
    [[maybe_unused]] const utils::JsonConversionOptions& opt) {
  formats::json::ValueBuilder result(formats::json::Type::kObject);
  if (!value.IsDeleted()) {
    result["data"] = formats::json::ValueBuilder(formats::json::Type::kObject);
  }

  {
    static const std::vector<std::string> field_names = {
        "data",
        "json-some2-field",
    };
    if (!opt.projection || opt.projection->CheckMember(field_names)) {
      utils::SetNested(result, field_names, value.some2_field,
                       utils::JsonConversionOptions{false, opt.projection});
    }
  }

  {
    static const std::vector<std::string> field_names = {
        "json-some2-id",
    };
    utils::SetNested(result, field_names, value.GetId(),
                     utils::JsonConversionOptions{false, opt.projection});
  }

  return result;
}

std::size_t Proxy1::Save([[maybe_unused]] std::ostream& out) const {
  std::size_t length = 0;
  return length;
}

void Proxy1::Load([[maybe_unused]] std::istream& in) {}

formats::json::ValueBuilder Proxy1::ToJson(
    std::optional<utils::Projection> projection) const {
  return ConvertToJson(*this, utils::JsonConversionOptions{false, projection});
}

formats::json::ValueBuilder Proxy1::GetAbsentObjectJson(const std::string& id) {
  formats::json::ValueBuilder result(formats::json::Type::kObject);
  api_over_db::utils::JsonConversionOptions opt{};
  {
    static const std::vector<std::string> field_names = {
        "json-some2-id",
    };
    utils::SetNested(result, field_names, id,
                     utils::JsonConversionOptions{false, opt.projection});
  }

  return result;
}

const std::vector<std::string>& Proxy1::GetRemovableJsonNamesForMongoName(
    const std::string& db_name) {
  static const std::vector<std::string> kEmpty;
  static const std::unordered_map<std::string, std::vector<std::string>>
      name_map{};
  auto it = name_map.find(db_name);
  if (it == name_map.end()) return kEmpty;
  return it->second;
}

bool Proxy1::operator==([[maybe_unused]] const Proxy1& other) const {
  return true;
}

const api_over_db::utils::Projection& GetAllJsonFields() {
  static const api_over_db::utils::Projection master([]() {
    api_over_db::utils::Projection result;

    {
      std::vector<std::string> path{"data", "json-some2-field"};
      result.AddProjection(path);
    }
    {
      std::vector<std::string> path{"json-some2-id"};
      result.AddProjection(path);
    }

    return result;
  }());
  return master;
};

}

namespace replica1 {

Replica1 Parse(const formats::bson::Value& elem, formats::parse::To<Replica1>) {
  Replica1 result;

  result.some1_field1 =
      elem["mongo-some1-field1"].ConvertTo<std::vector<std::string>>();
  result.some1_updated =
      elem["mongo-some1-updated"].As<formats::bson::Timestamp>();

  return result;
}

formats::json::ValueBuilder ConvertToJson(
    [[maybe_unused]] const Replica1& value,
    [[maybe_unused]] const utils::JsonConversionOptions& opt) {
  formats::json::ValueBuilder result(formats::json::Type::kObject);
  if (!value.IsDeleted()) {
    result["data"] = formats::json::ValueBuilder(formats::json::Type::kObject);
  }

  {
    static const std::vector<std::string> field_names = {
        "json-some1-deleted",
    };
    if (!opt.projection || opt.projection->CheckMember(field_names)) {
      utils::SetNested(result, field_names, value.some1_deleted,
                       utils::JsonConversionOptions{false, opt.projection});
    }
  }

  {
    static const std::vector<std::string> field_names = {
        "data",
        "json-some1-field1",
    };
    if (!opt.projection || opt.projection->CheckMember(field_names)) {
      utils::SetNested(result, field_names, value.some1_field1,
                       utils::JsonConversionOptions{true, opt.projection}

      );
    }
  }

  {
    static const std::vector<std::string> field_names = {
        "data",
        "json-some1-field2",
    };
    if (!opt.projection || opt.projection->CheckMember(field_names)) {
      utils::SetNested(result, field_names, value.some1_field2,
                       utils::JsonConversionOptions{false, opt.projection});
    }
  }

  {
    static const std::vector<std::string> field_names = {
        "data",
        "json-some1-field3",
    };
    if (!opt.projection || opt.projection->CheckMember(field_names)) {
      utils::SetNested(result, field_names, value.some1_field3,
                       utils::JsonConversionOptions{false, opt.projection});
    }
  }

  {
    static const std::vector<std::string> field_names = {
        "json-some1-id",
    };
    utils::SetNested(result, field_names, value.GetId(),
                     utils::JsonConversionOptions{false, opt.projection});
  }

  {
    static const std::vector<std::string> field_names = {
        "json-some1-revision",
    };
    if (!opt.projection || opt.projection->CheckMember(field_names)) {
      utils::SetNested(result, field_names,
                       api_over_db::utils::MakeRevision(value.GetTimestamp()),
                       utils::JsonConversionOptions{false, opt.projection});
    }
  }

  return result;
}

Replica1::Timestamp Replica1::GetTimestamp() const { return some1_updated; }

std::size_t Replica1::Save([[maybe_unused]] std::ostream& out) const {
  std::size_t length = 0;
  length += utils::SaveToDump(out, this->some1_deleted);
  length += utils::SaveToDump(out, this->some1_field1);
  length += utils::SaveToDump(out, this->some1_updated);
  return length;
}

void Replica1::Load([[maybe_unused]] std::istream& in) {
  utils::LoadFromDump(in, some1_deleted);
  utils::LoadFromDump(in, some1_field1);
  utils::LoadFromDump(in, some1_updated);
}

formats::json::ValueBuilder Replica1::ToJson(
    std::optional<utils::Projection> projection) const {
  return ConvertToJson(*this, utils::JsonConversionOptions{false, projection});
}

formats::json::ValueBuilder Replica1::GetAbsentObjectJson(
    const std::string& id) {
  formats::json::ValueBuilder result(formats::json::Type::kObject);
  api_over_db::utils::JsonConversionOptions opt{};
  {
    static const std::vector<std::string> field_names = {
        "json-some1-id",
    };
    utils::SetNested(result, field_names, id,
                     utils::JsonConversionOptions{false, opt.projection});
  }

  return result;
}

const std::vector<std::string>& Replica1::GetRemovableJsonNamesForMongoName(
    const std::string& db_name) {
  static const std::vector<std::string> kEmpty;
  static const std::unordered_map<std::string, std::vector<std::string>>
      name_map{};
  auto it = name_map.find(db_name);
  if (it == name_map.end()) return kEmpty;
  return it->second;
}

bool Replica1::operator==([[maybe_unused]] const Replica1& other) const {
  return true && utils::IsEqual(some1_deleted, other.some1_deleted) &&
         utils::IsEqual(some1_field1, other.some1_field1) &&
         utils::IsEqual(some1_updated, other.some1_updated);
}

const api_over_db::utils::Projection& GetAllJsonFields() {
  static const api_over_db::utils::Projection master([]() {
    api_over_db::utils::Projection result;

    {
      std::vector<std::string> path{"data", "json-some1-field1"};
      result.AddProjection(path);
    }
    {
      std::vector<std::string> path{"data", "json-some1-field2"};
      result.AddProjection(path);
    }
    {
      std::vector<std::string> path{"data", "json-some1-field3"};
      result.AddProjection(path);
    }
    {
      std::vector<std::string> path{"json-some1-deleted"};
      result.AddProjection(path);
    }
    {
      std::vector<std::string> path{"json-some1-id"};
      result.AddProjection(path);
    }
    {
      std::vector<std::string> path{"json-some1-revision"};
      result.AddProjection(path);
    }

    return result;
  }());
  return master;
};

}

namespace replica2 {

Replica2 Parse(const formats::bson::Value& elem, formats::parse::To<Replica2>) {
  Replica2 result;

  result.some2_updated =
      elem["mongo-some2-updated"].As<formats::bson::Timestamp>();

  return result;
}

formats::json::ValueBuilder ConvertToJson(
    [[maybe_unused]] const Replica2& value,
    [[maybe_unused]] const utils::JsonConversionOptions& opt) {
  formats::json::ValueBuilder result(formats::json::Type::kObject);
  if (!value.IsDeleted()) {
    result["data"] = formats::json::ValueBuilder(formats::json::Type::kObject);
  }

  {
    static const std::vector<std::string> field_names = {
        "json-some2-deleted",
    };
    if (!opt.projection || opt.projection->CheckMember(field_names)) {
      utils::SetNested(result, field_names, value.some2_deleted,
                       utils::JsonConversionOptions{false, opt.projection});
    }
  }

  {
    static const std::vector<std::string> field_names = {
        "data",
        "json-some2-field",
    };
    if (!opt.projection || opt.projection->CheckMember(field_names)) {
      utils::SetNested(result, field_names, value.some2_field,
                       utils::JsonConversionOptions{false, opt.projection});
    }
  }

  {
    static const std::vector<std::string> field_names = {
        "json-some2-id",
    };
    utils::SetNested(result, field_names, value.GetId(),
                     utils::JsonConversionOptions{false, opt.projection});
  }

  {
    static const std::vector<std::string> field_names = {
        "json-some2-revision",
    };
    if (!opt.projection || opt.projection->CheckMember(field_names)) {
      utils::SetNested(result, field_names,
                       api_over_db::utils::MakeRevision(value.GetTimestamp()),
                       utils::JsonConversionOptions{false, opt.projection});
    }
  }

  return result;
}

Replica2::Timestamp Replica2::GetTimestamp() const { return some2_updated; }

std::size_t Replica2::Save([[maybe_unused]] std::ostream& out) const {
  std::size_t length = 0;
  length += utils::SaveToDump(out, this->some2_deleted);
  length += utils::SaveToDump(out, this->some2_updated);
  return length;
}

void Replica2::Load([[maybe_unused]] std::istream& in) {
  utils::LoadFromDump(in, some2_deleted);
  utils::LoadFromDump(in, some2_updated);
}

formats::json::ValueBuilder Replica2::ToJson(
    std::optional<utils::Projection> projection) const {
  return ConvertToJson(*this, utils::JsonConversionOptions{false, projection});
}

formats::json::ValueBuilder Replica2::GetAbsentObjectJson(
    const std::string& id) {
  formats::json::ValueBuilder result(formats::json::Type::kObject);
  api_over_db::utils::JsonConversionOptions opt{};
  {
    static const std::vector<std::string> field_names = {
        "json-some2-id",
    };
    utils::SetNested(result, field_names, id,
                     utils::JsonConversionOptions{false, opt.projection});
  }

  return result;
}

const std::vector<std::string>& Replica2::GetRemovableJsonNamesForMongoName(
    const std::string& db_name) {
  static const std::vector<std::string> kEmpty;
  static const std::unordered_map<std::string, std::vector<std::string>>
      name_map{};
  auto it = name_map.find(db_name);
  if (it == name_map.end()) return kEmpty;
  return it->second;
}

bool Replica2::operator==([[maybe_unused]] const Replica2& other) const {
  return true && utils::IsEqual(some2_deleted, other.some2_deleted) &&
         utils::IsEqual(some2_updated, other.some2_updated);
}

const api_over_db::utils::Projection& GetAllJsonFields() {
  static const api_over_db::utils::Projection master([]() {
    api_over_db::utils::Projection result;

    {
      std::vector<std::string> path{"data", "json-some2-field"};
      result.AddProjection(path);
    }
    {
      std::vector<std::string> path{"json-some2-deleted"};
      result.AddProjection(path);
    }
    {
      std::vector<std::string> path{"json-some2-id"};
      result.AddProjection(path);
    }
    {
      std::vector<std::string> path{"json-some2-revision"};
      result.AddProjection(path);
    }

    return result;
  }());
  return master;
};

}

namespace replica3 {

Replica3 Parse(const formats::bson::Value& elem, formats::parse::To<Replica3>) {
  Replica3 result;

  result.some3_field1 = elem["mongo-some3-field1"].As<bool>();
  result.some3_updated =
      elem["mongo-some3-updated"].As<formats::bson::Timestamp>();

  return result;
}

formats::json::ValueBuilder ConvertToJson(
    [[maybe_unused]] const Replica3& value,
    [[maybe_unused]] const utils::JsonConversionOptions& opt) {
  formats::json::ValueBuilder result(formats::json::Type::kObject);
  if (!value.IsDeleted()) {
    result["data"] = formats::json::ValueBuilder(formats::json::Type::kObject);
  }

  {
    static const std::vector<std::string> field_names = {
        "json-some3-deleted",
    };
    if (!opt.projection || opt.projection->CheckMember(field_names)) {
      utils::SetNested(result, field_names, value.some3_deleted,
                       utils::JsonConversionOptions{false, opt.projection});
    }
  }

  {
    static const std::vector<std::string> field_names = {
        "data",
        "json-some3-field1",
    };
    if (!opt.projection || opt.projection->CheckMember(field_names)) {
      utils::SetNested(result, field_names, value.some3_field1,
                       utils::JsonConversionOptions{false, opt.projection});
    }
  }

  {
    static const std::vector<std::string> field_names = {
        "data",
        "json-some3-field2",
    };
    if (!opt.projection || opt.projection->CheckMember(field_names)) {
      utils::SetNested(result, field_names, value.some3_field2,
                       utils::JsonConversionOptions{false, opt.projection});
    }
  }

  {
    static const std::vector<std::string> field_names = {
        "data",
        "json-some3-field3",
    };
    if (!opt.projection || opt.projection->CheckMember(field_names)) {
      utils::SetNested(result, field_names, value.some3_field3,
                       utils::JsonConversionOptions{false, opt.projection});
    }
  }

  {
    static const std::vector<std::string> field_names = {
        "json-some3-id",
    };
    utils::SetNested(result, field_names, value.GetId(),
                     utils::JsonConversionOptions{false, opt.projection});
  }

  {
    static const std::vector<std::string> field_names = {
        "json-some3-revision",
    };
    if (!opt.projection || opt.projection->CheckMember(field_names)) {
      utils::SetNested(result, field_names,
                       api_over_db::utils::MakeRevision(value.GetTimestamp()),
                       utils::JsonConversionOptions{false, opt.projection});
    }
  }

  return result;
}

Replica3::Timestamp Replica3::GetTimestamp() const { return some3_updated; }

std::size_t Replica3::Save([[maybe_unused]] std::ostream& out) const {
  std::size_t length = 0;
  length += utils::SaveToDump(out, this->some3_deleted);
  length += utils::SaveToDump(out, this->some3_field1);
  length += utils::SaveToDump(out, this->some3_updated);
  return length;
}

void Replica3::Load([[maybe_unused]] std::istream& in) {
  utils::LoadFromDump(in, some3_deleted);
  utils::LoadFromDump(in, some3_field1);
  utils::LoadFromDump(in, some3_updated);
}

formats::json::ValueBuilder Replica3::ToJson(
    std::optional<utils::Projection> projection) const {
  return ConvertToJson(*this, utils::JsonConversionOptions{false, projection});
}

formats::json::ValueBuilder Replica3::GetAbsentObjectJson(
    const std::string& id) {
  formats::json::ValueBuilder result(formats::json::Type::kObject);
  api_over_db::utils::JsonConversionOptions opt{};
  {
    static const std::vector<std::string> field_names = {
        "json-some3-id",
    };
    utils::SetNested(result, field_names, id,
                     utils::JsonConversionOptions{false, opt.projection});
  }

  return result;
}

const std::vector<std::string>& Replica3::GetRemovableJsonNamesForMongoName(
    const std::string& db_name) {
  static const std::vector<std::string> kEmpty;
  static const std::unordered_map<std::string, std::vector<std::string>>
      name_map{};
  auto it = name_map.find(db_name);
  if (it == name_map.end()) return kEmpty;
  return it->second;
}

bool Replica3::operator==([[maybe_unused]] const Replica3& other) const {
  return true && utils::IsEqual(some3_deleted, other.some3_deleted) &&
         utils::IsEqual(some3_field1, other.some3_field1) &&
         utils::IsEqual(some3_updated, other.some3_updated);
}

const api_over_db::utils::Projection& GetAllJsonFields() {
  static const api_over_db::utils::Projection master([]() {
    api_over_db::utils::Projection result;

    {
      std::vector<std::string> path{"data", "json-some3-field1"};
      result.AddProjection(path);
    }
    {
      std::vector<std::string> path{"data", "json-some3-field2"};
      result.AddProjection(path);
    }
    {
      std::vector<std::string> path{"data", "json-some3-field3"};
      result.AddProjection(path);
    }
    {
      std::vector<std::string> path{"json-some3-deleted"};
      result.AddProjection(path);
    }
    {
      std::vector<std::string> path{"json-some3-id"};
      result.AddProjection(path);
    }
    {
      std::vector<std::string> path{"json-some3-revision"};
      result.AddProjection(path);
    }

    return result;
  }());
  return master;
};

}

}
