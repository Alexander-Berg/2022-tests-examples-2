/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

#include <clients/client-test-service/responses.hpp>

#include <userver/formats/json/serialize.hpp>
#include <userver/http/common_headers.hpp>
#include <userver/utils/assert.hpp>

#include <codegen/impl/convert.hpp>
#include <codegen/impl/get_validation_length.hpp>
#include <codegen/impl/optional_convert.hpp>
#include <codegen/impl/parsers.hpp>
#include <cstring>
#include <unordered_set>
#include <userver/formats/common/meta.hpp>
#include <userver/formats/json/string_builder.hpp>
#include <userver/logging/log.hpp>
#include <userver/utils/assert.hpp>
#include <userver/utils/datetime/from_string_saturating.hpp>
#include <userver/utils/underlying_value.hpp>

#include <codegen/impl/convert.hpp>

#include <boost/algorithm/string/join.hpp>
#include <boost/uuid/uuid_io.hpp>
#include <codegen/impl/convert.hpp>
#include <codegen/impl/parsers.hpp>
#include <userver/utils/datetime/from_string_saturating.hpp>

#include <userver/formats/json/serialize.hpp>
#include <userver/formats/json/serialize_container.hpp>  // for std::optional

namespace clients::client_test_service {

namespace v1_my_arg_smth::get {

const char* Exception::what() const noexcept { return kHandleInfo; }

std::string_view Exception::HandleInfo() const noexcept { return kHandleInfo; }

TimeoutException::~TimeoutException() = default;

ExceptionWithStatusCode::~ExceptionWithStatusCode() = default;

clients::client_test_service::v1_my_arg_smth::get::Response200 Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<
        clients::client_test_service::v1_my_arg_smth::get::Response200>) {
  clients::client_test_service::v1_my_arg_smth::get::Response200 result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.ok = elem["ok"].As<std::string>();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PResponse200::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PResponse200::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PResponse200::PResponse200()
{
  f_ok_.Subscribe(sink_ok_);
}

void PResponse200::Reset()
{
  state_ = State::kStart;
  result_ = {};

  s_ok_ = false;
}

void PResponse200::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PResponse200::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else if (key == "ok") {
    s_ok_ = true;
    f_ok_.Reset();

    parser_state_->PushParser(f_ok_.GetParser());
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PResponse200::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      if (!s_ok_) {
        throw ::formats::json::parser::InternalParseError(
            "missing required field 'ok'");
      }

      SetResult(std::move(result_));
      break;
  }
}

std::string PResponse200::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PResponse200::GetPathItem() const { return key_; }
}

formats::json::Value Serialize([[maybe_unused]] const Response200& value,
                               ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  builder.EmplaceNocheck("ok", value.ok);
  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const Response200& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);

  if (!hide_field_name || std::strcmp(hide_field_name, "ok"))
  {
    sw.Key("ok");

    WriteToStream(value.ok, sw);
  }
}

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response200& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

}

namespace v1_my_arg_smth::post {

const char* Exception::what() const noexcept { return kHandleInfo; }

std::string_view Exception::HandleInfo() const noexcept { return kHandleInfo; }

TimeoutException::~TimeoutException() = default;

ExceptionWithStatusCode::~ExceptionWithStatusCode() = default;

clients::client_test_service::v1_my_arg_smth::post::Response200 Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<
        clients::client_test_service::v1_my_arg_smth::post::Response200>) {
  clients::client_test_service::v1_my_arg_smth::post::Response200 result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PResponse200::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PResponse200::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PResponse200::PResponse200()
{}

void PResponse200::Reset()
{
  state_ = State::kStart;
  result_ = {};
}

void PResponse200::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PResponse200::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PResponse200::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      SetResult(std::move(result_));
      break;
  }
}

std::string PResponse200::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PResponse200::GetPathItem() const { return key_; }
}

formats::json::Value Serialize([[maybe_unused]] const Response200& value,
                               ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const Response200& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);
}

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response200& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

}

namespace v2_smth::get {

const char* Exception::what() const noexcept { return kHandleInfo; }

std::string_view Exception::HandleInfo() const noexcept { return kHandleInfo; }

TimeoutException::~TimeoutException() = default;

ExceptionWithStatusCode::~ExceptionWithStatusCode() = default;

clients::client_test_service::v2_smth::get::Response200 Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<
        clients::client_test_service::v2_smth::get::Response200>) {
  clients::client_test_service::v2_smth::get::Response200 result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PResponse200::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PResponse200::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PResponse200::PResponse200()
{}

void PResponse200::Reset()
{
  state_ = State::kStart;
  result_ = {};
}

void PResponse200::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PResponse200::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PResponse200::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      SetResult(std::move(result_));
      break;
  }
}

std::string PResponse200::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PResponse200::GetPathItem() const { return key_; }
}

formats::json::Value Serialize([[maybe_unused]] const Response200& value,
                               ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const Response200& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);
}

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response200& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

}

namespace v2_smth::post {

const char* Exception::what() const noexcept { return kHandleInfo; }

std::string_view Exception::HandleInfo() const noexcept { return kHandleInfo; }

TimeoutException::~TimeoutException() = default;

ExceptionWithStatusCode::~ExceptionWithStatusCode() = default;

clients::client_test_service::v2_smth::post::Response200 Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<
        clients::client_test_service::v2_smth::post::Response200>) {
  clients::client_test_service::v2_smth::post::Response200 result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PResponse200::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PResponse200::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PResponse200::PResponse200()
{}

void PResponse200::Reset()
{
  state_ = State::kStart;
  result_ = {};
}

void PResponse200::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PResponse200::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PResponse200::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      SetResult(std::move(result_));
      break;
  }
}

std::string PResponse200::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PResponse200::GetPathItem() const { return key_; }
}

formats::json::Value Serialize([[maybe_unused]] const Response200& value,
                               ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const Response200& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);
}

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response200& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

}

namespace v3_smth::get {

const char* Exception::what() const noexcept { return kHandleInfo; }

std::string_view Exception::HandleInfo() const noexcept { return kHandleInfo; }

TimeoutException::~TimeoutException() = default;

ExceptionWithStatusCode::~ExceptionWithStatusCode() = default;

clients::client_test_service::v3_smth::get::Response200 Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<
        clients::client_test_service::v3_smth::get::Response200>) {
  clients::client_test_service::v3_smth::get::Response200 result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PResponse200::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PResponse200::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PResponse200::PResponse200()
{}

void PResponse200::Reset()
{
  state_ = State::kStart;
  result_ = {};
}

void PResponse200::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PResponse200::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PResponse200::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      SetResult(std::move(result_));
      break;
  }
}

std::string PResponse200::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PResponse200::GetPathItem() const { return key_; }
}

formats::json::Value Serialize([[maybe_unused]] const Response200& value,
                               ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const Response200& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);
}

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response200& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

}

namespace v3_smth::post {

const char* Exception::what() const noexcept { return kHandleInfo; }

std::string_view Exception::HandleInfo() const noexcept { return kHandleInfo; }

TimeoutException::~TimeoutException() = default;

ExceptionWithStatusCode::~ExceptionWithStatusCode() = default;

clients::client_test_service::v3_smth::post::Response200 Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<
        clients::client_test_service::v3_smth::post::Response200>) {
  clients::client_test_service::v3_smth::post::Response200 result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PResponse200::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PResponse200::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PResponse200::PResponse200()
{}

void PResponse200::Reset()
{
  state_ = State::kStart;
  result_ = {};
}

void PResponse200::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PResponse200::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PResponse200::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      SetResult(std::move(result_));
      break;
  }
}

std::string PResponse200::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PResponse200::GetPathItem() const { return key_; }
}

formats::json::Value Serialize([[maybe_unused]] const Response200& value,
                               ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const Response200& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);
}

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response200& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

}

namespace root_::get {

const char* Exception::what() const noexcept { return kHandleInfo; }

std::string_view Exception::HandleInfo() const noexcept { return kHandleInfo; }

TimeoutException::~TimeoutException() = default;

ExceptionWithStatusCode::~ExceptionWithStatusCode() = default;

clients::client_test_service::root_::get::Response200 Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<clients::client_test_service::root_::get::Response200>) {
  clients::client_test_service::root_::get::Response200 result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.ok = elem["ok"].As<std::string>();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PResponse200::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PResponse200::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PResponse200::PResponse200()
{
  f_ok_.Subscribe(sink_ok_);
}

void PResponse200::Reset()
{
  state_ = State::kStart;
  result_ = {};

  s_ok_ = false;
}

void PResponse200::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PResponse200::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else if (key == "ok") {
    s_ok_ = true;
    f_ok_.Reset();

    parser_state_->PushParser(f_ok_.GetParser());
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PResponse200::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      if (!s_ok_) {
        throw ::formats::json::parser::InternalParseError(
            "missing required field 'ok'");
      }

      SetResult(std::move(result_));
      break;
  }
}

std::string PResponse200::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PResponse200::GetPathItem() const { return key_; }
}

formats::json::Value Serialize([[maybe_unused]] const Response200& value,
                               ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  builder.EmplaceNocheck("ok", value.ok);
  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const Response200& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);

  if (!hide_field_name || std::strcmp(hide_field_name, "ok"))
  {
    sw.Key("ok");

    WriteToStream(value.ok, sw);
  }
}

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response200& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

}

namespace root_::post {

const char* Exception::what() const noexcept { return kHandleInfo; }

std::string_view Exception::HandleInfo() const noexcept { return kHandleInfo; }

TimeoutException::~TimeoutException() = default;

ExceptionWithStatusCode::~ExceptionWithStatusCode() = default;

clients::client_test_service::root_::post::Response200 Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<
        clients::client_test_service::root_::post::Response200>) {
  clients::client_test_service::root_::post::Response200 result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PResponse200::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PResponse200::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PResponse200::PResponse200()
{}

void PResponse200::Reset()
{
  state_ = State::kStart;
  result_ = {};
}

void PResponse200::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PResponse200::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PResponse200::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      SetResult(std::move(result_));
      break;
  }
}

std::string PResponse200::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PResponse200::GetPathItem() const { return key_; }
}

formats::json::Value Serialize([[maybe_unused]] const Response200& value,
                               ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const Response200& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);
}

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response200& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

clients::client_test_service::root_::post::Response201 Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<
        clients::client_test_service::root_::post::Response201>) {
  clients::client_test_service::root_::post::Response201 result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PResponse201::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PResponse201::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PResponse201::PResponse201()
{}

void PResponse201::Reset()
{
  state_ = State::kStart;
  result_ = {};
}

void PResponse201::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PResponse201::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PResponse201::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      SetResult(std::move(result_));
      break;
  }
}

std::string PResponse201::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PResponse201::GetPathItem() const { return key_; }
}

formats::json::Value Serialize([[maybe_unused]] const Response201& value,
                               ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const Response201& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);
}

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response201& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

clients::client_test_service::root_::post::Response404 Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<
        clients::client_test_service::root_::post::Response404>) {
  clients::client_test_service::root_::post::Response404 result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PResponse404::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PResponse404::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PResponse404::PResponse404()
{}

void PResponse404::Reset()
{
  state_ = State::kStart;
  result_ = {};
}

void PResponse404::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PResponse404::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PResponse404::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      SetResult(std::move(result_));
      break;
  }
}

std::string PResponse404::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PResponse404::GetPathItem() const { return key_; }
}

formats::json::Value Serialize([[maybe_unused]] const Response404& value,
                               ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const Response404& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);
}

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response404& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

}

}
