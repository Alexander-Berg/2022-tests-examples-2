/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s):
// taxi/schemas/schemas/configs/declarations/CLIENT_TEST_SERVICE_CLIENT_QOS.yaml

#include <codegen/impl/convert.hpp>
#include <codegen/impl/get_validation_length.hpp>
#include <codegen/impl/optional_convert.hpp>
#include <codegen/impl/parsers.hpp>
#include <cstring>
#include <taxi_config/variables/CLIENT_TEST_SERVICE_CLIENT_QOS.hpp>
#include <unordered_set>
#include <userver/dynamic_config/value.hpp>
#include <userver/formats/common/meta.hpp>
#include <userver/formats/json/serialize_container.hpp>
#include <userver/formats/json/serialize_duration.hpp>
#include <userver/formats/json/string_builder.hpp>
#include <userver/logging/log.hpp>
#include <userver/utils/assert.hpp>
#include <userver/utils/datetime/from_string_saturating.hpp>
#include <userver/utils/underlying_value.hpp>

namespace taxi_config::client_test_service_client_qos {

taxi_config::client_test_service_client_qos::QosInfo Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<taxi_config::client_test_service_client_qos::QosInfo>) {
  taxi_config::client_test_service_client_qos::QosInfo result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.attempts = [](const formats::json::Value& value) -> int {
    auto tmp = value.As<int>(3);

    if (!(1 <= tmp)) {
      auto msg = "out of bounds, must be 1 (limit) <= " + std::to_string(tmp) +
                 " (value)";
      throw formats::json::Value::ParseException("Value of '" +
                                                 value.GetPath() + "': " + msg);
    }

    return tmp;
  }(elem["attempts"])

      ;
  result.timeout_ms =
      [](const formats::json::Value& value) -> ::std::chrono::milliseconds {
    auto tmp = value.As<int>();

    if (!(1 <= tmp)) {
      auto msg = "out of bounds, must be 1 (limit) <= " + std::to_string(tmp) +
                 " (value)";
      throw formats::json::Value::ParseException("Value of '" +
                                                 value.GetPath() + "': " + msg);
    }

    return ::codegen::impl::Convert<::std::chrono::milliseconds>(tmp);
  }(elem["timeout-ms"])

      ;

  return result;
}

}

namespace taxi_config::client_test_service_client_qos {

VariableType ParseVariable(const dynamic_config::DocsMap& docs_map) {
  return [](const formats::json::Value& value)
             -> dynamic_config::ValueDict<
                 taxi_config::client_test_service_client_qos::QosInfo> {
    std::unordered_map<std::string,
                       ::taxi_config::client_test_service_client_qos::QosInfo>
        map;
    for (auto it = value.begin(); it != value.end(); ++it) {
      const auto& name = it.GetName();
      map.emplace(std::make_pair(
          name,
          (*it).As<taxi_config::client_test_service_client_qos::QosInfo>()));
    }

    return dynamic_config::ValueDict<
        taxi_config::client_test_service_client_qos::QosInfo>(value.GetPath(),
                                                              std::move(map));
  }(docs_map.Get("CLIENT_TEST_SERVICE_CLIENT_QOS"));
}

}
