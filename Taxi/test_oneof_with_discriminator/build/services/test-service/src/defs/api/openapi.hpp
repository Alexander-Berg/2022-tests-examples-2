/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s): openapi.yaml

#pragma once

#include <array>
#include <boost/type_traits/has_equal_to.hpp>
#include <codegen/convert_to_json_optional.hpp>
#include <codegen/format.hpp>
#include <codegen/non_null_ptr.hpp>
#include <codegen/parsing_flags.hpp>
#include <optional>
#include <string>
#include <userver/formats/json/inline.hpp>
#include <userver/formats/json/string_builder_fwd.hpp>
#include <userver/formats/json/value.hpp>
#include <userver/formats/json/value_builder.hpp>
#include <userver/logging/log_helper_fwd.hpp>
#include <variant>

#include <codegen/parser/datetime_parser.hpp>
#include <codegen/parser/dummy_parser.hpp>  // TODO: for debug only
#include <codegen/parser/enum_parser.hpp>
#include <codegen/parser/extra_helper.hpp>
#include <codegen/parser/null_swallow.hpp>
#include <codegen/parser/nullable_helper.hpp>
#include <codegen/parser/parser_converter.hpp>
#include <codegen/parser/parser_dom.hpp>
#include <codegen/parser/parser_empty.hpp>
#include <codegen/parser/parser_non_null_ptr.hpp>
#include <codegen/parser/validator.hpp>
#include <codegen/parser/value_builder_helper.hpp>
#include <userver/formats/json/parser/parser.hpp>

namespace handlers {

struct SomeCardLikePayment {
  ::std::string type{};
  ::std::optional<::std::string> card_num{};
};

SomeCardLikePayment Parse(const formats::json::Value& elem,
                          formats::parse::To<SomeCardLikePayment>);

namespace parser {
class PSomeCardLikePayment final: public ::formats::json::parser::TypedParser<
                                      handlers::SomeCardLikePayment> {
 public:
  PSomeCardLikePayment();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  handlers::SomeCardLikePayment result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  // type
  // .cpp_type: std::string
  // .optional_subtype: None
  // cpp_type: std::string
  ::formats::json::parser::StringParser f_type_;

  ::formats::json::parser::SubscriberSink<std::string> sink_type_{result_.type};

  bool s_type_{false};

  // card-num
  // .cpp_type: std::optional<::std::string>
  // .optional_subtype: std::string
  // cpp_type: std::string
  ::formats::json::parser::StringParser f_card_num_;

  ::codegen::parser::NullableHelper<::std::optional<::std::string>,
                                    decltype(f_card_num_)>
      null_card_num_{f_card_num_};
  ::formats::json::parser::SubscriberSinkOptional<std::string> sink_card_num_{
      result_.card_num};

  bool s_card_num_{false};

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const SomeCardLikePayment& v);

template <typename U>
std::enable_if_t<std::is_same<U, SomeCardLikePayment>::value, bool> operator==(
    const U& lhs, const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(
      boost::has_equal_to<decltype(lhs.type)>::value,
      "No operator==() defined for field 'type' of type '::std::string'");
  static_assert(boost::has_equal_to<decltype(lhs.card_num)>::value,
                "No operator==() defined for field 'card_num' of type "
                "'::std::optional<::std::string>'");

  return std::tie(lhs.type, lhs.card_num) == std::tie(rhs.type, rhs.card_num);
}

template <typename U>
std::enable_if_t<std::is_same<U, SomeCardLikePayment>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

::formats::json::Value Serialize(
    const SomeCardLikePayment& value,
    ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const SomeCardLikePayment& value,
                   formats::json::StringBuilder& sw, bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

struct SomeApplePayPayment: public handlers::SomeCardLikePayment {
  using SomeCardLikePayment::SomeCardLikePayment;
  explicit SomeApplePayPayment(const SomeCardLikePayment& other)
      : SomeCardLikePayment{other}
  {}
  explicit SomeApplePayPayment(SomeCardLikePayment&& other) noexcept(
      std::is_nothrow_move_constructible_v<handlers::SomeCardLikePayment>)
      : SomeCardLikePayment{std::move(other)}
  {}
};

SomeApplePayPayment Parse(const formats::json::Value& elem,
                          formats::parse::To<SomeApplePayPayment>);

namespace parser {}  // namespace parser

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const SomeApplePayPayment& v);

::formats::json::Value Serialize(
    const SomeApplePayPayment& value,
    ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const SomeApplePayPayment& value,
                   formats::json::StringBuilder& sw);

struct SomeGooglePayPayment: public handlers::SomeCardLikePayment {
  using SomeCardLikePayment::SomeCardLikePayment;
  explicit SomeGooglePayPayment(const SomeCardLikePayment& other)
      : SomeCardLikePayment{other}
  {}
  explicit SomeGooglePayPayment(SomeCardLikePayment&& other) noexcept(
      std::is_nothrow_move_constructible_v<handlers::SomeCardLikePayment>)
      : SomeCardLikePayment{std::move(other)}
  {}
};

SomeGooglePayPayment Parse(const formats::json::Value& elem,
                           formats::parse::To<SomeGooglePayPayment>);

namespace parser {}  // namespace parser

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const SomeGooglePayPayment& v);

::formats::json::Value Serialize(
    const SomeGooglePayPayment& value,
    ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const SomeGooglePayPayment& value,
                   formats::json::StringBuilder& sw);

class SomePayment {
 public:
  using Variant =
      std::variant<handlers::SomeCardLikePayment, handlers::SomeApplePayPayment,
                   handlers::SomeGooglePayPayment>;

  SomePayment() = default;

  template <
      class T,
      class = std::enable_if_t<
          std::is_same<std::decay_t<T>, Variant>::value ||
          std::is_same<std::decay_t<T>, handlers::SomeCardLikePayment>::value ||
          std::is_same<std::decay_t<T>, handlers::SomeApplePayPayment>::value ||
          std::is_same<std::decay_t<T>, handlers::SomeGooglePayPayment>::value>>
  explicit SomePayment(T&& value)
      : data_(std::forward<T>(value))
  {}

  template <
      class T,
      class = std::enable_if_t<
          std::is_same<std::decay_t<T>, Variant>::value ||
          std::is_same<std::decay_t<T>, handlers::SomeCardLikePayment>::value ||
          std::is_same<std::decay_t<T>, handlers::SomeApplePayPayment>::value ||
          std::is_same<std::decay_t<T>, handlers::SomeGooglePayPayment>::value>>
  SomePayment& operator=(T&& value) {
    data_ = std::forward<T>(value);
    return *this;
  }

  template <class Target>
  Target& As() {
    return std::get<Target>(data_);
  }

  template <class Target>
  const Target& As() const {
    return std::get<Target>(data_);
  }

  Variant& AsVariant() { return data_; }
  const Variant& AsVariant() const { return data_; }

 private:
  Variant data_{};
};

SomePayment Parse(const formats::json::Value& elem,
                  formats::parse::To<SomePayment>);

namespace parser {
struct PSomePaymentDomToType {
  static handlers::SomePayment Convert(::formats::json::Value&& value);
};
using PSomePayment =
    ::codegen::parser::ParserDom<handlers::SomePayment, PSomePaymentDomToType>;

}  // namespace parser

logging::LogHelper& operator<<(logging::LogHelper& lh, const SomePayment& v);

template <typename U>
std::enable_if_t<std::is_same<U, SomePayment>::value, bool> operator==(
    const U& lhs, const U& rhs) {
  return lhs.AsVariant() == rhs.AsVariant();
}

template <typename U>
std::enable_if_t<std::is_same<U, SomePayment>::value, bool> operator!=(
    const U& lhs, const U& rhs) {
  return !(lhs.data_ == rhs.data_);
}

::formats::json::Value Serialize(
    const SomePayment& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const SomePayment& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

class SomeOtherPayment {
 public:
  using Variant =
      std::variant<handlers::SomeCardLikePayment, handlers::SomeApplePayPayment,
                   handlers::SomeGooglePayPayment>;

  SomeOtherPayment() = default;

  template <
      class T,
      class = std::enable_if_t<
          std::is_same<std::decay_t<T>, Variant>::value ||
          std::is_same<std::decay_t<T>, handlers::SomeCardLikePayment>::value ||
          std::is_same<std::decay_t<T>, handlers::SomeApplePayPayment>::value ||
          std::is_same<std::decay_t<T>, handlers::SomeGooglePayPayment>::value>>
  explicit SomeOtherPayment(T&& value)
      : data_(std::forward<T>(value))
  {}

  template <
      class T,
      class = std::enable_if_t<
          std::is_same<std::decay_t<T>, Variant>::value ||
          std::is_same<std::decay_t<T>, handlers::SomeCardLikePayment>::value ||
          std::is_same<std::decay_t<T>, handlers::SomeApplePayPayment>::value ||
          std::is_same<std::decay_t<T>, handlers::SomeGooglePayPayment>::value>>
  SomeOtherPayment& operator=(T&& value) {
    data_ = std::forward<T>(value);
    return *this;
  }

  template <class Target>
  Target& As() {
    return std::get<Target>(data_);
  }

  template <class Target>
  const Target& As() const {
    return std::get<Target>(data_);
  }

  Variant& AsVariant() { return data_; }
  const Variant& AsVariant() const { return data_; }

 private:
  Variant data_{};
};

SomeOtherPayment Parse(const formats::json::Value& elem,
                       formats::parse::To<SomeOtherPayment>);

namespace parser {
struct PSomeOtherPaymentDomToType {
  static handlers::SomeOtherPayment Convert(::formats::json::Value&& value);
};
using PSomeOtherPayment =
    ::codegen::parser::ParserDom<handlers::SomeOtherPayment,
                                 PSomeOtherPaymentDomToType>;

}  // namespace parser

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const SomeOtherPayment& v);

template <typename U>
std::enable_if_t<std::is_same<U, SomeOtherPayment>::value, bool> operator==(
    const U& lhs, const U& rhs) {
  return lhs.AsVariant() == rhs.AsVariant();
}

template <typename U>
std::enable_if_t<std::is_same<U, SomeOtherPayment>::value, bool> operator!=(
    const U& lhs, const U& rhs) {
  return !(lhs.data_ == rhs.data_);
}

::formats::json::Value Serialize(
    const SomeOtherPayment& value,
    ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const SomeOtherPayment& value,
                   formats::json::StringBuilder& sw, bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

struct OpenapiRequest {
  double id{};
  ::std::optional<::std::string> data{};
};

OpenapiRequest Parse(const formats::json::Value& elem,
                     formats::parse::To<OpenapiRequest>);

namespace parser {
class POpenapiRequest final
    : public ::formats::json::parser::TypedParser<handlers::OpenapiRequest> {
 public:
  POpenapiRequest();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  handlers::OpenapiRequest result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  // id
  // .cpp_type: double
  // .optional_subtype: None
  // cpp_type: double
  ::formats::json::parser::DoubleParser f_id_;

  ::formats::json::parser::SubscriberSink<double> sink_id_{result_.id};

  bool s_id_{false};

  // data
  // .cpp_type: std::optional<::std::string>
  // .optional_subtype: std::string
  // cpp_type: std::string
  ::formats::json::parser::StringParser f_data_;

  ::codegen::parser::NullableHelper<::std::optional<::std::string>,
                                    decltype(f_data_)>
      null_data_{f_data_};
  ::formats::json::parser::SubscriberSinkOptional<std::string> sink_data_{
      result_.data};

  bool s_data_{false};

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

logging::LogHelper& operator<<(logging::LogHelper& lh, const OpenapiRequest& v);

template <typename U>
std::enable_if_t<std::is_same<U, OpenapiRequest>::value, bool> operator==(
    const U& lhs, const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(boost::has_equal_to<decltype(lhs.id)>::value,
                "No operator==() defined for field 'id' of type 'double'");
  static_assert(boost::has_equal_to<decltype(lhs.data)>::value,
                "No operator==() defined for field 'data' of type "
                "'::std::optional<::std::string>'");

  return std::tie(lhs.id, lhs.data) == std::tie(rhs.id, rhs.data);
}

template <typename U>
std::enable_if_t<std::is_same<U, OpenapiRequest>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

::formats::json::Value Serialize(
    const OpenapiRequest& value,
    ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const OpenapiRequest& value,
                   formats::json::StringBuilder& sw, bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

struct OpenapiBadRequest {
  ::std::optional<::std::string> message{};
};

OpenapiBadRequest Parse(const formats::json::Value& elem,
                        formats::parse::To<OpenapiBadRequest>);

namespace parser {
class POpenapiBadRequest final
    : public ::formats::json::parser::TypedParser<handlers::OpenapiBadRequest> {
 public:
  POpenapiBadRequest();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  handlers::OpenapiBadRequest result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  // message
  // .cpp_type: std::optional<::std::string>
  // .optional_subtype: std::string
  // cpp_type: std::string
  ::formats::json::parser::StringParser f_message_;

  ::codegen::parser::NullableHelper<::std::optional<::std::string>,
                                    decltype(f_message_)>
      null_message_{f_message_};
  ::formats::json::parser::SubscriberSinkOptional<std::string> sink_message_{
      result_.message};

  bool s_message_{false};

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const OpenapiBadRequest& v);

template <typename U>
std::enable_if_t<std::is_same<U, OpenapiBadRequest>::value, bool> operator==(
    const U& lhs, const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(boost::has_equal_to<decltype(lhs.message)>::value,
                "No operator==() defined for field 'message' of type "
                "'::std::optional<::std::string>'");

  return std::tie(lhs.message) == std::tie(rhs.message);
}

template <typename U>
std::enable_if_t<std::is_same<U, OpenapiBadRequest>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

::formats::json::Value Serialize(
    const OpenapiBadRequest& value,
    ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const OpenapiBadRequest& value,
                   formats::json::StringBuilder& sw, bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

enum class OneOfEnumBCType { kTypeB, kTypeC };

inline constexpr std::array<OneOfEnumBCType, 2> kOneOfEnumBCTypeValues = {
    OneOfEnumBCType::kTypeB,
    OneOfEnumBCType::kTypeC,
};

OneOfEnumBCType Parse(const formats::json::Value& elem,
                      formats::parse::To<OneOfEnumBCType>);

OneOfEnumBCType Parse(std::string_view elem,
                      formats::parse::To<OneOfEnumBCType>);

namespace parser {
using POneOfEnumBCType =
    ::codegen::parser::EnumParser<handlers::OneOfEnumBCType>;

}  // namespace parser

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const OneOfEnumBCType& v);

::formats::json::Value Serialize(
    const OneOfEnumBCType& value,
    ::formats::serialize::To<::formats::json::Value>);

std::string ToString(OneOfEnumBCType value);

void WriteToStream(const OneOfEnumBCType& value,
                   formats::json::StringBuilder& sw);

struct OneOfEnumBC {
  ::handlers::OneOfEnumBCType type{};
  ::std::optional<int> field_bc{};
};

OneOfEnumBC Parse(const formats::json::Value& elem,
                  formats::parse::To<OneOfEnumBC>);

namespace parser {
class POneOfEnumBC final
    : public ::formats::json::parser::TypedParser<handlers::OneOfEnumBC> {
 public:
  POneOfEnumBC();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  handlers::OneOfEnumBC result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  // type
  // .cpp_type: handlers::OneOfEnumBCType
  // .optional_subtype: None
  // cpp_type: handlers::OneOfEnumBCType
  handlers::parser::POneOfEnumBCType f_type_;

  ::formats::json::parser::SubscriberSink<handlers::OneOfEnumBCType> sink_type_{
      result_.type};

  bool s_type_{false};

  // field_bc
  // .cpp_type: std::optional<int>
  // .optional_subtype: int
  // cpp_type: int
  ::formats::json::parser::IntegralParser<int> f_field_bc_;

  ::codegen::parser::NullableHelper<::std::optional<int>, decltype(f_field_bc_)>
      null_field_bc_{f_field_bc_};
  ::formats::json::parser::SubscriberSinkOptional<int> sink_field_bc_{
      result_.field_bc};

  bool s_field_bc_{false};

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

logging::LogHelper& operator<<(logging::LogHelper& lh, const OneOfEnumBC& v);

template <typename U>
std::enable_if_t<std::is_same<U, OneOfEnumBC>::value, bool> operator==(
    const U& lhs, const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(boost::has_equal_to<decltype(lhs.type)>::value,
                "No operator==() defined for field 'type' of type "
                "'::handlers::OneOfEnumBCType'");
  static_assert(boost::has_equal_to<decltype(lhs.field_bc)>::value,
                "No operator==() defined for field 'field_bc' of type "
                "'::std::optional<int>'");

  return std::tie(lhs.type, lhs.field_bc) == std::tie(rhs.type, rhs.field_bc);
}

template <typename U>
std::enable_if_t<std::is_same<U, OneOfEnumBC>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

::formats::json::Value Serialize(
    const OneOfEnumBC& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const OneOfEnumBC& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

enum class OneOfEnumAType { kTypeA };

inline constexpr std::array<OneOfEnumAType, 1> kOneOfEnumATypeValues = {
    OneOfEnumAType::kTypeA,
};

OneOfEnumAType Parse(const formats::json::Value& elem,
                     formats::parse::To<OneOfEnumAType>);

OneOfEnumAType Parse(std::string_view elem, formats::parse::To<OneOfEnumAType>);

namespace parser {
using POneOfEnumAType = ::codegen::parser::EnumParser<handlers::OneOfEnumAType>;

}  // namespace parser

logging::LogHelper& operator<<(logging::LogHelper& lh, const OneOfEnumAType& v);

::formats::json::Value Serialize(
    const OneOfEnumAType& value,
    ::formats::serialize::To<::formats::json::Value>);

std::string ToString(OneOfEnumAType value);

void WriteToStream(const OneOfEnumAType& value,
                   formats::json::StringBuilder& sw);

struct OneOfEnumA {
  ::handlers::OneOfEnumAType type{};
  ::std::optional<int> field_a{};
};

OneOfEnumA Parse(const formats::json::Value& elem,
                 formats::parse::To<OneOfEnumA>);

namespace parser {
class POneOfEnumA final
    : public ::formats::json::parser::TypedParser<handlers::OneOfEnumA> {
 public:
  POneOfEnumA();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  handlers::OneOfEnumA result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  // type
  // .cpp_type: handlers::OneOfEnumAType
  // .optional_subtype: None
  // cpp_type: handlers::OneOfEnumAType
  handlers::parser::POneOfEnumAType f_type_;

  ::formats::json::parser::SubscriberSink<handlers::OneOfEnumAType> sink_type_{
      result_.type};

  bool s_type_{false};

  // field_a
  // .cpp_type: std::optional<int>
  // .optional_subtype: int
  // cpp_type: int
  ::formats::json::parser::IntegralParser<int> f_field_a_;

  ::codegen::parser::NullableHelper<::std::optional<int>, decltype(f_field_a_)>
      null_field_a_{f_field_a_};
  ::formats::json::parser::SubscriberSinkOptional<int> sink_field_a_{
      result_.field_a};

  bool s_field_a_{false};

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

logging::LogHelper& operator<<(logging::LogHelper& lh, const OneOfEnumA& v);

template <typename U>
std::enable_if_t<std::is_same<U, OneOfEnumA>::value, bool> operator==(
    const U& lhs, const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(boost::has_equal_to<decltype(lhs.type)>::value,
                "No operator==() defined for field 'type' of type "
                "'::handlers::OneOfEnumAType'");
  static_assert(boost::has_equal_to<decltype(lhs.field_a)>::value,
                "No operator==() defined for field 'field_a' of type "
                "'::std::optional<int>'");

  return std::tie(lhs.type, lhs.field_a) == std::tie(rhs.type, rhs.field_a);
}

template <typename U>
std::enable_if_t<std::is_same<U, OneOfEnumA>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

::formats::json::Value Serialize(
    const OneOfEnumA& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const OneOfEnumA& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

class OneOfEnum {
 public:
  using Variant = std::variant<handlers::OneOfEnumA, handlers::OneOfEnumBC>;

  OneOfEnum() = default;

  template <class T,
            class = std::enable_if_t<
                std::is_same<std::decay_t<T>, Variant>::value ||
                std::is_same<std::decay_t<T>, handlers::OneOfEnumA>::value ||
                std::is_same<std::decay_t<T>, handlers::OneOfEnumBC>::value>>
  explicit OneOfEnum(T&& value)
      : data_(std::forward<T>(value))
  {}

  template <class T,
            class = std::enable_if_t<
                std::is_same<std::decay_t<T>, Variant>::value ||
                std::is_same<std::decay_t<T>, handlers::OneOfEnumA>::value ||
                std::is_same<std::decay_t<T>, handlers::OneOfEnumBC>::value>>
  OneOfEnum& operator=(T&& value) {
    data_ = std::forward<T>(value);
    return *this;
  }

  template <class Target>
  Target& As() {
    return std::get<Target>(data_);
  }

  template <class Target>
  const Target& As() const {
    return std::get<Target>(data_);
  }

  Variant& AsVariant() { return data_; }
  const Variant& AsVariant() const { return data_; }

 private:
  Variant data_{};
};

OneOfEnum Parse(const formats::json::Value& elem,
                formats::parse::To<OneOfEnum>);

namespace parser {
struct POneOfEnumDomToType {
  static handlers::OneOfEnum Convert(::formats::json::Value&& value);
};
using POneOfEnum =
    ::codegen::parser::ParserDom<handlers::OneOfEnum, POneOfEnumDomToType>;

}  // namespace parser

logging::LogHelper& operator<<(logging::LogHelper& lh, const OneOfEnum& v);

template <typename U>
std::enable_if_t<std::is_same<U, OneOfEnum>::value, bool> operator==(
    const U& lhs, const U& rhs) {
  return lhs.AsVariant() == rhs.AsVariant();
}

template <typename U>
std::enable_if_t<std::is_same<U, OneOfEnum>::value, bool> operator!=(
    const U& lhs, const U& rhs) {
  return !(lhs.data_ == rhs.data_);
}

::formats::json::Value Serialize(
    const OneOfEnum& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const OneOfEnum& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

}
