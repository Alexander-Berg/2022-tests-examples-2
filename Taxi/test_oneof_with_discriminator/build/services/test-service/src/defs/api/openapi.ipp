#ifndef USERVER_CODEGEN_IPP_INSTANTIATION_GUARD
#error DO NOT INCLUDE THIS FILE! INCLUDE THE FILE WITH *.hpp EXTENSION!
#endif

/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s): openapi.yaml

#include <defs/api/openapi.hpp>

#include <userver/formats/json/serialize_variant.hpp>
#include <userver/formats/parse/variant.hpp>

#include <userver/formats/json/value_builder.hpp>
#include <userver/formats/parse/common_containers.hpp>
#include <userver/formats/parse/variant.hpp>

#include <codegen/impl/convert.hpp>
#include <codegen/impl/get_validation_length.hpp>
#include <codegen/impl/optional_convert.hpp>
#include <codegen/impl/parsers.hpp>
#include <cstring>
#include <unordered_set>
#include <userver/formats/common/meta.hpp>
#include <userver/formats/json/string_builder.hpp>
#include <userver/logging/log.hpp>
#include <userver/utils/assert.hpp>
#include <userver/utils/datetime/from_string_saturating.hpp>
#include <userver/utils/underlying_value.hpp>

#include <codegen/impl/convert.hpp>

namespace handlers {

handlers::SomeCardLikePayment Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<handlers::SomeCardLikePayment>) {
  handlers::SomeCardLikePayment result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.type = elem["type"].As<std::string>();
  result.card_num = elem["card-num"].As<std::optional<::std::string>>();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PSomeCardLikePayment::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PSomeCardLikePayment::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PSomeCardLikePayment::PSomeCardLikePayment()
{
  f_type_.Subscribe(sink_type_);
  null_card_num_.Subscribe(sink_card_num_);

  f_card_num_.Subscribe(sink_card_num_);
}

void PSomeCardLikePayment::Reset()
{
  state_ = State::kStart;
  result_ = {};

  s_type_ = false;
  s_card_num_ = false;
}

void PSomeCardLikePayment::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PSomeCardLikePayment::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else if (key == "type") {
    s_type_ = true;
    f_type_.Reset();

    parser_state_->PushParser(f_type_.GetParser());
  }

  else if (key == "card-num") {
    s_card_num_ = true;
    f_card_num_.Reset();

    parser_state_->PushParser(null_card_num_.GetParser());
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PSomeCardLikePayment::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      if (!s_type_) {
        throw ::formats::json::parser::InternalParseError(
            "missing required field 'type'");
      }
      if (!s_card_num_) {
        result_.card_num = {};
      }

      SetResult(std::move(result_));
      break;
  }
}

std::string PSomeCardLikePayment::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PSomeCardLikePayment::GetPathItem() const { return key_; }
}

formats::json::Value Serialize(
    [[maybe_unused]] const handlers::SomeCardLikePayment& value,
    ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  builder.EmplaceNocheck("type", value.type);
  if (value.card_num) builder.EmplaceNocheck("card-num", *value.card_num);
  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const handlers::SomeCardLikePayment& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);

  if (!hide_field_name || std::strcmp(hide_field_name, "type"))
  {
    sw.Key("type");

    WriteToStream(value.type, sw);
  }
  if (!hide_field_name || std::strcmp(hide_field_name, "card-num"))
  {
    if (value.card_num)
    {
      sw.Key("card-num");

      WriteToStream(*value.card_num, sw);
    }
  }
}

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const handlers::SomeCardLikePayment& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

handlers::SomeApplePayPayment Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<handlers::SomeApplePayPayment>) {
  return handlers::SomeApplePayPayment{
      Parse(elem, formats::parse::To<handlers::SomeCardLikePayment>())};
}

formats::json::Value Serialize(
    [[maybe_unused]] const handlers::SomeApplePayPayment& value,
    ::formats::serialize::To<formats::json::Value>)
{
  return formats::json::ValueBuilder(
             static_cast<const handlers::SomeCardLikePayment&>(value))
      .ExtractValue();
}

void WriteToStream([[maybe_unused]] const handlers::SomeApplePayPayment& value,
                   formats::json::StringBuilder& sw)
{
  WriteToStream(static_cast<const handlers::SomeCardLikePayment&>(value), sw);
}

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const handlers::SomeApplePayPayment& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

handlers::SomeGooglePayPayment Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<handlers::SomeGooglePayPayment>) {
  return handlers::SomeGooglePayPayment{
      Parse(elem, formats::parse::To<handlers::SomeCardLikePayment>())};
}

formats::json::Value Serialize(
    [[maybe_unused]] const handlers::SomeGooglePayPayment& value,
    ::formats::serialize::To<formats::json::Value>)
{
  return formats::json::ValueBuilder(
             static_cast<const handlers::SomeCardLikePayment&>(value))
      .ExtractValue();
}

void WriteToStream([[maybe_unused]] const handlers::SomeGooglePayPayment& value,
                   formats::json::StringBuilder& sw)
{
  WriteToStream(static_cast<const handlers::SomeCardLikePayment&>(value), sw);
}

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const handlers::SomeGooglePayPayment& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

handlers::SomePayment Parse([[maybe_unused]] const formats::json::Value& elem,
                            formats::parse::To<handlers::SomePayment>) {
  const auto discriminator = elem["type"].As<std::string>();
  if (discriminator == "card") {
    return handlers::SomePayment{
        elem.As<handlers::SomeCardLikePayment>(),
    };
  } else if (discriminator == "applepay") {
    return handlers::SomePayment{
        handlers::SomeApplePayPayment{elem.As<handlers::SomeCardLikePayment>()},
    };
  } else if (discriminator == "googlepay") {
    return handlers::SomePayment{
        handlers::SomeGooglePayPayment{
            elem.As<handlers::SomeCardLikePayment>()},
    };
  } else {
    throw formats::json::Value::ParseException(
        "Value of discriminator '" + discriminator + "' for path '" +
        elem.GetPath() +
        "' does not match any known mapping from ['card', 'applepay', "
        "'googlepay']");
  }
}

namespace parser {
handlers::SomePayment PSomePaymentDomToType::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<handlers::SomePayment>();
}
}  // namespace parser

formats::json::Value Serialize(
    [[maybe_unused]] const handlers::SomePayment& value,
    ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(value.AsVariant());
  builder["type"] = [](const auto& v) -> std::string_view {
    switch (v.AsVariant().index()) {
      case 0:
        // handlers::SomeCardLikePayment
        return "card";
      case 1:
        // handlers::SomeApplePayPayment
        return "applepay";
      case 2:
        // handlers::SomeGooglePayPayment
        return "googlepay";
    }
    throw std::runtime_error(
        "Detected an attempt to serialize a corrupted 'handlers::SomePayment'");
  }(value)

      ;
  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const handlers::SomePayment& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);

  std::visit([&sw](const auto& v) { WriteToStream(v, sw, true, "type"); },
             value.AsVariant());

  if (!hide_field_name || std::strcmp("type", hide_field_name)) {
    sw.Key("type");
    sw.WriteString([](const auto& v) -> std::string_view {
      switch (v.AsVariant().index()) {
        case 0:
          // handlers::SomeCardLikePayment
          return "card";
        case 1:
          // handlers::SomeApplePayPayment
          return "applepay";
        case 2:
          // handlers::SomeGooglePayPayment
          return "googlepay";
      }
      throw std::runtime_error(
          "Detected an attempt to serialize a corrupted "
          "'handlers::SomePayment'");
    }(value)

    );
  }
}

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const handlers::SomePayment& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

handlers::SomeOtherPayment Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<handlers::SomeOtherPayment>) {
  const auto discriminator = elem["type"].As<std::string>();
  if (discriminator == "card") {
    return handlers::SomeOtherPayment{
        elem.As<handlers::SomeCardLikePayment>(),
    };
  } else if (discriminator == "card_a") {
    return handlers::SomeOtherPayment{
        elem.As<handlers::SomeCardLikePayment>(),
    };
  } else if (discriminator == "card_b") {
    return handlers::SomeOtherPayment{
        elem.As<handlers::SomeCardLikePayment>(),
    };
  } else if (discriminator == "applepay") {
    return handlers::SomeOtherPayment{
        handlers::SomeApplePayPayment{elem.As<handlers::SomeCardLikePayment>()},
    };
  } else if (discriminator == "googlepay") {
    return handlers::SomeOtherPayment{
        handlers::SomeGooglePayPayment{
            elem.As<handlers::SomeCardLikePayment>()},
    };
  } else {
    throw formats::json::Value::ParseException(
        "Value of discriminator '" + discriminator + "' for path '" +
        elem.GetPath() +
        "' does not match any known mapping from ['card', 'card_a', 'card_b', "
        "'applepay', 'googlepay']");
  }
}

namespace parser {
handlers::SomeOtherPayment PSomeOtherPaymentDomToType::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<handlers::SomeOtherPayment>();
}
}  // namespace parser

formats::json::Value Serialize(
    [[maybe_unused]] const handlers::SomeOtherPayment& value,
    ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(value.AsVariant());
  builder["type"] = [](const auto& v) -> std::string {
    struct Visitor {
      std::string operator()(const handlers::SomeCardLikePayment& v) const {
        const std::string& v_str = v.type;

        if (false || v_str == "card" || v_str == "card_a" ||
            v_str == "card_b") {
          return v_str;
        }

        throw std::runtime_error(
            "Detected an attempt to serialize a 'handlers::SomeOtherPayment' "
            "with unsupported discriminator value '" +
            v_str + "'");
      }
      std::string operator()(const handlers::SomeApplePayPayment& v) const {
        const std::string& v_str = v.type;

        if (false || v_str == "applepay") {
          return v_str;
        }

        throw std::runtime_error(
            "Detected an attempt to serialize a 'handlers::SomeOtherPayment' "
            "with unsupported discriminator value '" +
            v_str + "'");
      }
      std::string operator()(const handlers::SomeGooglePayPayment& v) const {
        const std::string& v_str = v.type;

        if (false || v_str == "googlepay") {
          return v_str;
        }

        throw std::runtime_error(
            "Detected an attempt to serialize a 'handlers::SomeOtherPayment' "
            "with unsupported discriminator value '" +
            v_str + "'");
      }
    };
    return std::visit(Visitor{}, v.AsVariant());
  }(value)

      ;
  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const handlers::SomeOtherPayment& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);

  std::visit([&sw](const auto& v) { WriteToStream(v, sw, true, "type"); },
             value.AsVariant());

  if (!hide_field_name || std::strcmp("type", hide_field_name)) {
    sw.Key("type");
    sw.WriteString([](const auto& v) -> std::string {
      struct Visitor {
        std::string operator()(const handlers::SomeCardLikePayment& v) const {
          const std::string& v_str = v.type;

          if (false || v_str == "card" || v_str == "card_a" ||
              v_str == "card_b") {
            return v_str;
          }

          throw std::runtime_error(
              "Detected an attempt to serialize a 'handlers::SomeOtherPayment' "
              "with unsupported discriminator value '" +
              v_str + "'");
        }
        std::string operator()(const handlers::SomeApplePayPayment& v) const {
          const std::string& v_str = v.type;

          if (false || v_str == "applepay") {
            return v_str;
          }

          throw std::runtime_error(
              "Detected an attempt to serialize a 'handlers::SomeOtherPayment' "
              "with unsupported discriminator value '" +
              v_str + "'");
        }
        std::string operator()(const handlers::SomeGooglePayPayment& v) const {
          const std::string& v_str = v.type;

          if (false || v_str == "googlepay") {
            return v_str;
          }

          throw std::runtime_error(
              "Detected an attempt to serialize a 'handlers::SomeOtherPayment' "
              "with unsupported discriminator value '" +
              v_str + "'");
        }
      };
      return std::visit(Visitor{}, v.AsVariant());
    }(value)

    );
  }
}

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const handlers::SomeOtherPayment& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

handlers::OpenapiRequest Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<handlers::OpenapiRequest>) {
  handlers::OpenapiRequest result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.id = elem["id"].As<double>();
  result.data = elem["data"].As<std::optional<::std::string>>();

  return result;
}

namespace parser {
template <class To>
template <class From>
To POpenapiRequest::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To POpenapiRequest::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

POpenapiRequest::POpenapiRequest()
{
  f_id_.Subscribe(sink_id_);
  null_data_.Subscribe(sink_data_);

  f_data_.Subscribe(sink_data_);
}

void POpenapiRequest::Reset()
{
  state_ = State::kStart;
  result_ = {};

  s_id_ = false;
  s_data_ = false;
}

void POpenapiRequest::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void POpenapiRequest::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else if (key == "id") {
    s_id_ = true;
    f_id_.Reset();

    parser_state_->PushParser(f_id_.GetParser());
  }

  else if (key == "data") {
    s_data_ = true;
    f_data_.Reset();

    parser_state_->PushParser(null_data_.GetParser());
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void POpenapiRequest::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      if (!s_id_) {
        throw ::formats::json::parser::InternalParseError(
            "missing required field 'id'");
      }
      if (!s_data_) {
        result_.data = {};
      }

      SetResult(std::move(result_));
      break;
  }
}

std::string POpenapiRequest::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string POpenapiRequest::GetPathItem() const { return key_; }
}

formats::json::Value Serialize(
    [[maybe_unused]] const handlers::OpenapiRequest& value,
    ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  builder.EmplaceNocheck("id", value.id);
  if (value.data) builder.EmplaceNocheck("data", *value.data);
  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const handlers::OpenapiRequest& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);

  if (!hide_field_name || std::strcmp(hide_field_name, "id"))
  {
    sw.Key("id");

    WriteToStream(value.id, sw);
  }
  if (!hide_field_name || std::strcmp(hide_field_name, "data"))
  {
    if (value.data)
    {
      sw.Key("data");

      WriteToStream(*value.data, sw);
    }
  }
}

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const handlers::OpenapiRequest& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

handlers::OpenapiBadRequest Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<handlers::OpenapiBadRequest>) {
  handlers::OpenapiBadRequest result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.message = elem["message"].As<std::optional<::std::string>>();

  return result;
}

namespace parser {
template <class To>
template <class From>
To POpenapiBadRequest::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To POpenapiBadRequest::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

POpenapiBadRequest::POpenapiBadRequest()
{
  null_message_.Subscribe(sink_message_);

  f_message_.Subscribe(sink_message_);
}

void POpenapiBadRequest::Reset()
{
  state_ = State::kStart;
  result_ = {};

  s_message_ = false;
}

void POpenapiBadRequest::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void POpenapiBadRequest::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else if (key == "message") {
    s_message_ = true;
    f_message_.Reset();

    parser_state_->PushParser(null_message_.GetParser());
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void POpenapiBadRequest::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      if (!s_message_) {
        result_.message = {};
      }

      SetResult(std::move(result_));
      break;
  }
}

std::string POpenapiBadRequest::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string POpenapiBadRequest::GetPathItem() const { return key_; }
}

formats::json::Value Serialize(
    [[maybe_unused]] const handlers::OpenapiBadRequest& value,
    ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  if (value.message) builder.EmplaceNocheck("message", *value.message);
  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const handlers::OpenapiBadRequest& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);

  if (!hide_field_name || std::strcmp(hide_field_name, "message"))
  {
    if (value.message)
    {
      sw.Key("message");

      WriteToStream(*value.message, sw);
    }
  }
}

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const handlers::OpenapiBadRequest& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

handlers::OneOfEnumBCType Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<handlers::OneOfEnumBCType>) {
  const auto& value = elem.As<std::string>();
  if (value == "type_b") {
    return handlers::OneOfEnumBCType::kTypeB;
  } else if (value == "type_c") {
    return handlers::OneOfEnumBCType::kTypeC;
  } else {
    throw formats::json::ParseException("Value of '" + elem.GetPath() + "' (" +
                                        value + ") is not parseable into enum");
  }
}

OneOfEnumBCType Parse(std::string_view value,
                      formats::parse::To<OneOfEnumBCType>)
{
  static const std::unordered_map<std::string_view, handlers::OneOfEnumBCType>
      map = {
          {"type_b", handlers::OneOfEnumBCType::kTypeB},
          {"type_c", handlers::OneOfEnumBCType::kTypeC},
      };
  auto it = map.find(value);
  if (it != map.end()) return it->second;

  throw std::runtime_error("Value '" + std::string{value} +
                           "' is not parseable into handlers::OneOfEnumBCType");
}

std::string ToString(handlers::OneOfEnumBCType value) {
  switch (value) {
    case handlers::OneOfEnumBCType::kTypeB:
      return "type_b";
    case handlers::OneOfEnumBCType::kTypeC:
      return "type_c";
  }
  throw std::runtime_error(
      "Detected an attempt to serialize a corrupted "
      "'handlers::OneOfEnumBCType' (" +
      std::to_string(utils::UnderlyingValue(value)) + ")");
}

formats::json::Value Serialize(
    [[maybe_unused]] const handlers::OneOfEnumBCType& value,
    ::formats::serialize::To<formats::json::Value>)
{
  return formats::json::ValueBuilder(ToString(value)).ExtractValue();
}

void WriteToStream([[maybe_unused]] const handlers::OneOfEnumBCType& value,
                   formats::json::StringBuilder& sw)
{
  switch (value) {
    case handlers::OneOfEnumBCType::kTypeB:
      WriteToStream("type_b", sw);
      break;
    case handlers::OneOfEnumBCType::kTypeC:
      WriteToStream("type_c", sw);
      break;
  }
}

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const handlers::OneOfEnumBCType& v)
{
  return lh << ToString(v);
}

handlers::OneOfEnumBC Parse([[maybe_unused]] const formats::json::Value& elem,
                            formats::parse::To<handlers::OneOfEnumBC>) {
  handlers::OneOfEnumBC result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.type = elem["type"].As<handlers::OneOfEnumBCType>();
  result.field_bc = elem["field_bc"].As<std::optional<int>>();

  return result;
}

namespace parser {
template <class To>
template <class From>
To POneOfEnumBC::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To POneOfEnumBC::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

POneOfEnumBC::POneOfEnumBC()
{
  f_type_.Subscribe(sink_type_);
  null_field_bc_.Subscribe(sink_field_bc_);

  f_field_bc_.Subscribe(sink_field_bc_);
}

void POneOfEnumBC::Reset()
{
  state_ = State::kStart;
  result_ = {};

  s_type_ = false;
  s_field_bc_ = false;
}

void POneOfEnumBC::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void POneOfEnumBC::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else if (key == "type") {
    s_type_ = true;
    f_type_.Reset();

    parser_state_->PushParser(f_type_.GetParser());
  }

  else if (key == "field_bc") {
    s_field_bc_ = true;
    f_field_bc_.Reset();

    parser_state_->PushParser(null_field_bc_.GetParser());
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void POneOfEnumBC::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      if (!s_type_) {
        throw ::formats::json::parser::InternalParseError(
            "missing required field 'type'");
      }
      if (!s_field_bc_) {
        result_.field_bc = {};
      }

      SetResult(std::move(result_));
      break;
  }
}

std::string POneOfEnumBC::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string POneOfEnumBC::GetPathItem() const { return key_; }
}

formats::json::Value Serialize(
    [[maybe_unused]] const handlers::OneOfEnumBC& value,
    ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  builder.EmplaceNocheck("type", value.type);
  if (value.field_bc) builder.EmplaceNocheck("field_bc", *value.field_bc);
  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const handlers::OneOfEnumBC& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);

  if (!hide_field_name || std::strcmp(hide_field_name, "type"))
  {
    sw.Key("type");

    WriteToStream(value.type, sw);
  }
  if (!hide_field_name || std::strcmp(hide_field_name, "field_bc"))
  {
    if (value.field_bc)
    {
      sw.Key("field_bc");

      WriteToStream(*value.field_bc, sw);
    }
  }
}

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const handlers::OneOfEnumBC& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

handlers::OneOfEnumAType Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<handlers::OneOfEnumAType>) {
  const auto& value = elem.As<std::string>();
  if (value == "type_a") {
    return handlers::OneOfEnumAType::kTypeA;
  } else {
    throw formats::json::ParseException("Value of '" + elem.GetPath() + "' (" +
                                        value + ") is not parseable into enum");
  }
}

OneOfEnumAType Parse(std::string_view value, formats::parse::To<OneOfEnumAType>)
{
  static const std::unordered_map<std::string_view, handlers::OneOfEnumAType>
      map = {
          {"type_a", handlers::OneOfEnumAType::kTypeA},
      };
  auto it = map.find(value);
  if (it != map.end()) return it->second;

  throw std::runtime_error("Value '" + std::string{value} +
                           "' is not parseable into handlers::OneOfEnumAType");
}

std::string ToString(handlers::OneOfEnumAType value) {
  switch (value) {
    case handlers::OneOfEnumAType::kTypeA:
      return "type_a";
  }
  throw std::runtime_error(
      "Detected an attempt to serialize a corrupted 'handlers::OneOfEnumAType' "
      "(" +
      std::to_string(utils::UnderlyingValue(value)) + ")");
}

formats::json::Value Serialize(
    [[maybe_unused]] const handlers::OneOfEnumAType& value,
    ::formats::serialize::To<formats::json::Value>)
{
  return formats::json::ValueBuilder(ToString(value)).ExtractValue();
}

void WriteToStream([[maybe_unused]] const handlers::OneOfEnumAType& value,
                   formats::json::StringBuilder& sw)
{
  switch (value) {
    case handlers::OneOfEnumAType::kTypeA:
      WriteToStream("type_a", sw);
      break;
  }
}

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const handlers::OneOfEnumAType& v)
{
  return lh << ToString(v);
}

handlers::OneOfEnumA Parse([[maybe_unused]] const formats::json::Value& elem,
                           formats::parse::To<handlers::OneOfEnumA>) {
  handlers::OneOfEnumA result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.type = elem["type"].As<handlers::OneOfEnumAType>();
  result.field_a = elem["field_a"].As<std::optional<int>>();

  return result;
}

namespace parser {
template <class To>
template <class From>
To POneOfEnumA::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To POneOfEnumA::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

POneOfEnumA::POneOfEnumA()
{
  f_type_.Subscribe(sink_type_);
  null_field_a_.Subscribe(sink_field_a_);

  f_field_a_.Subscribe(sink_field_a_);
}

void POneOfEnumA::Reset()
{
  state_ = State::kStart;
  result_ = {};

  s_type_ = false;
  s_field_a_ = false;
}

void POneOfEnumA::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void POneOfEnumA::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else if (key == "type") {
    s_type_ = true;
    f_type_.Reset();

    parser_state_->PushParser(f_type_.GetParser());
  }

  else if (key == "field_a") {
    s_field_a_ = true;
    f_field_a_.Reset();

    parser_state_->PushParser(null_field_a_.GetParser());
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void POneOfEnumA::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      if (!s_type_) {
        throw ::formats::json::parser::InternalParseError(
            "missing required field 'type'");
      }
      if (!s_field_a_) {
        result_.field_a = {};
      }

      SetResult(std::move(result_));
      break;
  }
}

std::string POneOfEnumA::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string POneOfEnumA::GetPathItem() const { return key_; }
}

formats::json::Value Serialize(
    [[maybe_unused]] const handlers::OneOfEnumA& value,
    ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  builder.EmplaceNocheck("type", value.type);
  if (value.field_a) builder.EmplaceNocheck("field_a", *value.field_a);
  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const handlers::OneOfEnumA& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);

  if (!hide_field_name || std::strcmp(hide_field_name, "type"))
  {
    sw.Key("type");

    WriteToStream(value.type, sw);
  }
  if (!hide_field_name || std::strcmp(hide_field_name, "field_a"))
  {
    if (value.field_a)
    {
      sw.Key("field_a");

      WriteToStream(*value.field_a, sw);
    }
  }
}

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const handlers::OneOfEnumA& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

handlers::OneOfEnum Parse([[maybe_unused]] const formats::json::Value& elem,
                          formats::parse::To<handlers::OneOfEnum>) {
  const auto discriminator = elem["type"].As<std::string>();
  if (discriminator == "type_a") {
    return handlers::OneOfEnum{
        elem.As<handlers::OneOfEnumA>(),
    };
  } else if (discriminator == "type_b") {
    return handlers::OneOfEnum{
        elem.As<handlers::OneOfEnumBC>(),
    };
  } else if (discriminator == "type_c") {
    return handlers::OneOfEnum{
        elem.As<handlers::OneOfEnumBC>(),
    };
  } else {
    throw formats::json::Value::ParseException(
        "Value of discriminator '" + discriminator + "' for path '" +
        elem.GetPath() +
        "' does not match any known mapping from ['type_a', 'type_b', "
        "'type_c']");
  }
}

namespace parser {
handlers::OneOfEnum POneOfEnumDomToType::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<handlers::OneOfEnum>();
}
}  // namespace parser

formats::json::Value Serialize(
    [[maybe_unused]] const handlers::OneOfEnum& value,
    ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(value.AsVariant());
  builder["type"] = [](const auto& v) -> std::string {
    struct Visitor {
      std::string operator()(const handlers::OneOfEnumA& v) const {
        const std::string& v_str = ToString(v.type);

        if (false || v_str == "type_a") {
          return v_str;
        }

        throw std::runtime_error(
            "Detected an attempt to serialize a 'handlers::OneOfEnum' "
            "with unsupported discriminator value '" +
            v_str + "'");
      }
      std::string operator()(const handlers::OneOfEnumBC& v) const {
        const std::string& v_str = ToString(v.type);

        if (false || v_str == "type_b" || v_str == "type_c") {
          return v_str;
        }

        throw std::runtime_error(
            "Detected an attempt to serialize a 'handlers::OneOfEnum' "
            "with unsupported discriminator value '" +
            v_str + "'");
      }
    };
    return std::visit(Visitor{}, v.AsVariant());
  }(value)

      ;
  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const handlers::OneOfEnum& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);

  std::visit([&sw](const auto& v) { WriteToStream(v, sw, true, "type"); },
             value.AsVariant());

  if (!hide_field_name || std::strcmp("type", hide_field_name)) {
    sw.Key("type");
    sw.WriteString([](const auto& v) -> std::string {
      struct Visitor {
        std::string operator()(const handlers::OneOfEnumA& v) const {
          const std::string& v_str = ToString(v.type);

          if (false || v_str == "type_a") {
            return v_str;
          }

          throw std::runtime_error(
              "Detected an attempt to serialize a 'handlers::OneOfEnum' "
              "with unsupported discriminator value '" +
              v_str + "'");
        }
        std::string operator()(const handlers::OneOfEnumBC& v) const {
          const std::string& v_str = ToString(v.type);

          if (false || v_str == "type_b" || v_str == "type_c") {
            return v_str;
          }

          throw std::runtime_error(
              "Detected an attempt to serialize a 'handlers::OneOfEnum' "
              "with unsupported discriminator value '" +
              v_str + "'");
        }
      };
      return std::visit(Visitor{}, v.AsVariant());
    }(value)

    );
  }
}

logging::LogHelper& operator<<(logging::LogHelper& lh,
                               const handlers::OneOfEnum& v)
{
  return lh << ToString(formats::json::ValueBuilder(v).ExtractValue());
}

}
