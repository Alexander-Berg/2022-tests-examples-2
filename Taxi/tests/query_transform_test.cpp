#include "models/yql/query_transform.hpp"

#include <chrono>

#include <fmt/format.h>
#include <gtest/gtest.h>
#include <boost/algorithm/string/join.hpp>
#include <boost/regex.hpp>

#include <userver/utils/mock_now.hpp>

#include <defs/all_definitions.hpp>
#include <models/utils/timestamp.hpp>
#include <taxi_config/taxi_config.hpp>

namespace {

using DeduplicationPolicy =
    taxi_config::utags_yql_deduplication_policy::DeduplicationPolicy;

const std::string kQueryWithPlaceholder =
    "SOME DIFFICULT SELECTS\n[_INSERT_HERE_]\n[_LAST_RUN_RESULT_] SELECT 'tag' "
    "'dbid_uuid';\n";

const std::string kUseCluster = "use chyt.hahn/robot-tags-alias;";

const std::string kCliqueName = "robot-tags-alias";

const std::string kPragma = "PRAGMA yql.DisableParallelExecution = true;";

const std::string kChytQueryWithPlaceholder = kQueryWithPlaceholder;

const std::string kCreateTable = "CREATE TABLE IF NOT EXISTS";

const std::string kCommentGenerated =
    "-- THIS CODE WAS GENERATED BY TAGS SERVICE";
const std::string kCommentSection =
    "--------------------------------------------------------";
const std::string kEmptyTableWithSchema =
    "(SELECT * from range(\"dummy\", \"\", \"\") WITH SCHEMA "
    "Struct<tag:string,ttl:string,entity_value:string,entity_type:string>)";

std::string RemoveUUID(const std::string& str) {
  static const boost::regex random_uuid{"_[A-Za-z0-9]{32}"};
  return boost::regex_replace(str, random_uuid, "");
}

std::string GetAppendPath(const std::string& service_name) {
  return fmt::format("home/taxi/testing/features/{}/snapshots/provider0_append",
                     service_name);
}

std::string GetRemovePath(const std::string& service_name) {
  return fmt::format("home/taxi/testing/features/{}/snapshots/provider0_remove",
                     service_name);
}

models::yql::QueryText GetQueryWithPlaceholder(
    const std::string& entity_type_str) {
  return models::yql::QueryText{
      "SOME DIFFICULT SELECTS\n[_INSERT_HERE_]\n[_LAST_RUN_RESULT_] SELECT "
      "'tag' '" +
      entity_type_str + "';\n"};
}

std::string GetYqlBasicQueryTransformed(
    const std::string& snapshot_path, const std::string& tmp_path,
    const std::string& tag_names_path, const std::string& entity_types_path,
    const std::optional<std::string>& last_snapshot_path,
    const std::string& entity_type_str, const bool distinct_enabled) {
  const std::string last_snapshot = last_snapshot_path
                                        ? "`" + *last_snapshot_path + "`"
                                        : kEmptyTableWithSchema;
  const std::string ttl_field =
      distinct_enabled ? "SOME(WeakField(a.ttl, string) ?? 'infinity')"
                       : "WeakField(a.ttl, string) ?? 'infinity'";
  const std::string group_by =
      distinct_enabled ? " GROUP BY a.tag, a." + entity_type_str : "";

  return "SOME DIFFICULT SELECTS\n"
         "\n"
         "\n"
         "--------------------------------------------------------\n"
         "-- THIS CODE WAS GENERATED BY TAGS SERVICE\n"
         "INSERT INTO `" +
         tmp_path +
         "` "
         "WITH TRUNCATE\n"
         "--------------------------------------------------------\n"
         "\n"
         "\n"
         "\n" +
         last_snapshot + " SELECT 'tag' '" + entity_type_str +
         "';\n\n"
         "\n"
         "\n"
         "--------------------------------------------------------\n"
         "-- THIS CODE WAS GENERATED BY TAGS SERVICE\n"
         ";\n"
         "COMMIT;\n"
         "INSERT INTO `" +
         snapshot_path + "` WITH TRUNCATE SELECT a.tag, a." + entity_type_str +
         " AS entity_value, '" + entity_type_str + "' AS entity_type, " +
         ttl_field + " AS ttl FROM `" + tmp_path + "` AS a" + group_by +
         ";\nCOMMIT;\nINSERT INTO `" + tag_names_path +
         "` WITH TRUNCATE SELECT DISTINCT tag FROM `" + snapshot_path +
         "`;\nINSERT INTO `" + entity_types_path +
         "` WITH TRUNCATE SELECT DISTINCT entity_type FROM `" + snapshot_path +
         "`;\nDROP TABLE `" + tmp_path + "`;\n";
}

std::string GetYqlMergeQueryTransformed(const std::string& snapshot_path,
                                        const std::string& append_path,
                                        const std::string& remove_path,
                                        const std::string& last_snapshot_path) {
  return "INSERT INTO `" + append_path +
         "` WITH TRUNCATE SELECT a.tag AS tag, a.entity_value AS "
         "entity_value, "
         "a.entity_type AS entity_type, (WeakField(a.ttl, string) ?? "
         "'infinity') AS ttl FROM `" +
         snapshot_path + "` AS a LEFT ONLY JOIN `" + last_snapshot_path +
         "` AS b ON a.tag = b.tag AND a.entity_value = b.entity_value AND "
         "a.entity_type = b.entity_type AND (WeakField(a.ttl, string) ?? "
         "'infinity') = (WeakField(b.ttl, string) ?? 'infinity');\nINSERT "
         "INTO "
         "`" +
         remove_path +
         "` WITH TRUNCATE SELECT a.tag AS tag, a.entity_value AS "
         "entity_value, "
         "a.entity_type AS entity_type FROM `" +
         last_snapshot_path + "` AS a LEFT ONLY JOIN `" + snapshot_path +
         "` AS b ON a.tag = b.tag AND a.entity_value = b.entity_value AND "
         "a.entity_type = b.entity_type;\n";
}

}  // namespace

TEST(YqlQueryTransformer, Basic) {
  const auto environment_name = "testing";
  const auto provider_name = "provider0";
  const auto service_name = "tags";

  const auto snapshots_dir =
      models::yql::GetSnapshotsDirectory(environment_name, service_name);
  ASSERT_EQ(snapshots_dir, "home/taxi/testing/features/tags/snapshots");

  const auto expected_snapshot_path =
      snapshots_dir + "/" + provider_name + "_snapshot";
  const auto expected_tmp_path = snapshots_dir + "/" + provider_name + "_tmp";
  const auto expected_tag_names_path =
      snapshots_dir + "/" + provider_name + "_tag_names";
  const auto expected_entity_types_path =
      snapshots_dir + "/" + provider_name + "_entity_types";

  {
    auto [transformed_query, snapshot_path, append_path, remove_info,
          tag_names_path, entity_types_path, tmp_path] =
        models::yql::TransformYqlQuery(
            GetQueryWithPlaceholder(ToString(models::EntityType::kDbidUuid)),
            snapshots_dir, models::ProviderName{provider_name},
            models::EntityType::kDbidUuid, std::nullopt, {},
            DeduplicationPolicy::kAllowDuplicates);

    const auto query = RemoveUUID(transformed_query.GetUnderlying());

    ASSERT_NE(entity_types_path, std::nullopt);
    ASSERT_EQ(query, GetYqlBasicQueryTransformed(
                         expected_snapshot_path, expected_tmp_path,
                         expected_tag_names_path, expected_entity_types_path,
                         std::nullopt, ToString(models::EntityType::kDbidUuid),
                         false));
    ASSERT_EQ(RemoveUUID(snapshot_path), expected_snapshot_path);
    ASSERT_EQ(RemoveUUID(append_path), expected_snapshot_path);
    ASSERT_EQ(remove_info, std::nullopt);
    ASSERT_EQ(RemoveUUID(tag_names_path), expected_tag_names_path);
    ASSERT_EQ(RemoveUUID(*entity_types_path), expected_entity_types_path);
    ASSERT_EQ(RemoveUUID(tmp_path), expected_tmp_path);
  }

  {
    const auto last_snapshot_path = "//path/to/unfinished/snapshot";
    auto [transformed_query, snapshot_path, append_path, remove_info,
          tag_names_path, entity_types_path, tmp_path] =
        models::yql::TransformYqlQuery(
            GetQueryWithPlaceholder(ToString(models::EntityType::kDbidUuid)),
            snapshots_dir, models::ProviderName{provider_name},
            models::EntityType::kDbidUuid,
            {{models::YtSnapshotStatus::kOutdated, last_snapshot_path,
              models::EntityType::kDbidUuid, models::yql::Syntax::kSqlv1}},
            {}, DeduplicationPolicy::kAllowDuplicates);

    const auto query = RemoveUUID(transformed_query.GetUnderlying());

    ASSERT_NE(entity_types_path, std::nullopt);
    ASSERT_EQ(query, GetYqlBasicQueryTransformed(
                         expected_snapshot_path, expected_tmp_path,
                         expected_tag_names_path, expected_entity_types_path,
                         std::nullopt, ToString(models::EntityType::kDbidUuid),
                         false));
    ASSERT_EQ(RemoveUUID(snapshot_path), expected_snapshot_path);
    ASSERT_EQ(RemoveUUID(append_path), expected_snapshot_path);
    ASSERT_EQ(remove_info, std::nullopt);
    ASSERT_EQ(RemoveUUID(tag_names_path), expected_tag_names_path);
    ASSERT_EQ(RemoveUUID(*entity_types_path), expected_entity_types_path);
    ASSERT_EQ(RemoveUUID(tmp_path), expected_tmp_path);
  }

  {
    const std::vector<models::EntityType> kEntityTypes{
        models::EntityType::kDbidUuid, models::EntityType::kUdid,
        models::EntityType::kCarNumber, models::EntityType::kPark,
        models::EntityType::kParkCarId};

    for (const auto entity_type : kEntityTypes) {
      const auto finished_path = "path/to/finished/snapshot";
      const auto expected_append_path = GetAppendPath(service_name);
      const auto expected_remove_path = GetRemovePath(service_name);
      const auto [transformed_query, snapshot_path, append_path, remove_info,
                  tag_names_path, entity_types_path, tmp_path] =
          models::yql::TransformYqlQuery(
              GetQueryWithPlaceholder(ToString(entity_type)), snapshots_dir,
              models::ProviderName{provider_name}, entity_type,
              {{models::YtSnapshotStatus::kFullyApplied, finished_path,
                entity_type, models::yql::Syntax::kSqlv1}},
              {}, DeduplicationPolicy::kRemoveDuplicates);
      const auto [remove_path, remove_entity_type] = *remove_info;
      const auto query = RemoveUUID(transformed_query.GetUnderlying());

      ASSERT_NE(entity_types_path, std::nullopt);
      const auto expected_result =
          GetYqlBasicQueryTransformed(expected_snapshot_path, expected_tmp_path,
                                      expected_tag_names_path,
                                      expected_entity_types_path, finished_path,
                                      ToString(entity_type), true) +
          GetYqlMergeQueryTransformed(expected_snapshot_path,
                                      expected_append_path,
                                      expected_remove_path, finished_path);

      ASSERT_EQ(query, expected_result);
      ASSERT_EQ(RemoveUUID(snapshot_path), expected_snapshot_path);
      ASSERT_EQ(RemoveUUID(append_path), expected_append_path);
      ASSERT_EQ(RemoveUUID(remove_path), expected_remove_path);
      ASSERT_EQ(remove_entity_type, entity_type);
      ASSERT_EQ(RemoveUUID(tag_names_path), expected_tag_names_path);
      ASSERT_EQ(RemoveUUID(*entity_types_path), expected_entity_types_path);
      ASSERT_EQ(RemoveUUID(tmp_path), expected_tmp_path);
    }
  }

  {
    const auto finished_path = "path/to/unfinished/snapshot";
    ASSERT_THROW(
        models::yql::TransformYqlQuery(
            GetQueryWithPlaceholder(ToString(models::EntityType::kDbidUuid)),
            snapshots_dir, models::ProviderName{provider_name},
            models::EntityType::kDbidUuid,
            {{models::YtSnapshotStatus::kPartiallyApplied, finished_path,
              models::EntityType::kDbidUuid, models::yql::Syntax::kSqlv1}},
            {}, DeduplicationPolicy::kAllowDuplicates),
        std::logic_error);
  }
}

TEST(YqlQueryTransformer, NoPlaceholder) {
  const auto environment_name = "testing";
  const auto service_name = "tags";

  const auto snapshots_dir =
      models::yql::GetSnapshotsDirectory(environment_name, service_name);

  ASSERT_THROW(
      models::yql::TransformYqlQuery(
          models::yql::QueryText{"abacaba"}, snapshots_dir,
          models::ProviderName{"provider"}, models::EntityType::kDbidUuid,
          std::nullopt, {}, DeduplicationPolicy::kAllowDuplicates),
      std::logic_error);
}

TEST(YqlQueryTransformer, TwoPlaceholders) {
  const auto environment_name = "testing";
  const auto service_name = "tags";

  const auto snapshots_dir =
      models::yql::GetSnapshotsDirectory(environment_name, service_name);

  ASSERT_THROW(models::yql::TransformYqlQuery(
                   models::yql::QueryText{
                       "[_INSERT_HERE_] SELECT FROM [_INSERT_HERE_] SELECT"},
                   snapshots_dir, models::ProviderName{"provider"},
                   models::EntityType::kDbidUuid, std::nullopt, {},
                   DeduplicationPolicy::kAllowDuplicates),
               std::logic_error);
}

TEST(YqlQueryTransformer, ChangeEntityType) {
  const auto environment_name = "testing";
  const auto provider_name = "provider0";
  const auto service_name = "passenger-tags";

  const auto snapshots_dir =
      models::yql::GetSnapshotsDirectory(environment_name, service_name);
  ASSERT_EQ(snapshots_dir,
            "home/taxi/testing/features/passenger-tags/snapshots");

  const auto expected_snapshot_path =
      snapshots_dir + "/" + provider_name + "_snapshot";
  const auto expected_append_path =
      snapshots_dir + "/" + provider_name + "_append";
  const auto expected_remove_path =
      snapshots_dir + "/" + provider_name + "_remove";
  const auto expected_tmp_path = snapshots_dir + "/" + provider_name + "_tmp";
  const auto expected_entity_types_path =
      snapshots_dir + "/" + provider_name + "_entity_types";
  const auto expected_tag_names_path =
      snapshots_dir + "/" + provider_name + "_tag_names";
  const auto old_snapshot_path = "//path/to/snapshot";

  {
    const auto [transformed_query, snapshot_path, append_path, remove_info,
                tag_names_path, entity_types_path, tmp_path] =
        models::yql::TransformYqlQuery(
            GetQueryWithPlaceholder(ToString(models::EntityType::kDbidUuid)),
            snapshots_dir, models::ProviderName{provider_name},
            models::EntityType::kDbidUuid,
            {{models::YtSnapshotStatus::kFullyApplied, old_snapshot_path,
              models::EntityType::kUdid, models::yql::Syntax::kSqlv1}},
            {}, DeduplicationPolicy::kAllowDuplicates);
    const auto [remove_path, remove_entity_type] = *remove_info;
    const auto query = RemoveUUID(transformed_query.GetUnderlying());

    const auto expected_result =
        GetYqlBasicQueryTransformed(
            expected_snapshot_path, expected_tmp_path, expected_tag_names_path,
            expected_entity_types_path, old_snapshot_path,
            ToString(models::EntityType::kDbidUuid), false) +
        GetYqlMergeQueryTransformed(expected_snapshot_path,
                                    expected_append_path, expected_remove_path,
                                    old_snapshot_path);

    ASSERT_NE(entity_types_path, std::nullopt);
    ASSERT_EQ(query, expected_result);
    ASSERT_EQ(RemoveUUID(snapshot_path), expected_snapshot_path);
    ASSERT_EQ(RemoveUUID(append_path), expected_append_path);
    ASSERT_EQ(RemoveUUID(remove_path), expected_remove_path);
    ASSERT_EQ(remove_entity_type, models::EntityType::kUdid);
    ASSERT_EQ(RemoveUUID(tmp_path), expected_tmp_path);
  }
}

TEST(YqlPragmas, Basic) {
  const auto environment_name = "testing";
  const auto service_name = "eats-tags";
  const auto provider_name = "provider0";

  const auto snapshots_dir =
      models::yql::GetSnapshotsDirectory(environment_name, service_name);
  ASSERT_EQ(snapshots_dir, "home/taxi/testing/features/eats-tags/snapshots");

  const std::string pragma0 = "prAgma yT.UsErsLots = \"100500\";\n";
  const std::string pragma1 = "PRAGMA YT.POOL = \"custom_pool\";\n";
  const std::string pragma2 = "prAgma UsErsLots = \"some_value\";\n";
  const std::string pragma3 = "prAgma yt.Owner = \"nikitaevg\";\n";
  {
    const auto [transformed_query, snapshot_path, append_path, remove_info,
                tag_names_path, entity_types_path, tmp_path] =
        models::yql::TransformYqlQuery(
            models::yql::QueryText{pragma0 + pragma1 + pragma2 + pragma3 +
                                   kQueryWithPlaceholder + pragma0},
            snapshots_dir, models::ProviderName{provider_name},
            models::EntityType::kDbidUuid, std::nullopt,
            {{"yt.UserSlots", "100"},
             {"yt.Pool", "tags"},
             {"yt.OperationSpec", "annotation"}},
            DeduplicationPolicy::kAllowDuplicates);

    const auto query = RemoveUUID(transformed_query.GetUnderlying());

    const auto find = [&query](const auto& value) {
      ASSERT_TRUE(query.find(value) != std::string::npos);
    };
    const auto not_find = [&query](const auto& value) {
      ASSERT_TRUE(query.find(value) == std::string::npos);
    };
    find("PRAGMA yt.Pool = \"tags\";\n");
    find("PRAGMA yt.UserSlots = \"100\";\n");
    not_find(pragma0);
    not_find(pragma1);
    find(pragma2);
    find(pragma3);
    not_find("100500");
    not_find("custom_pool");
    not_find("yT.UsErsLots");
    not_find("YT.POOL");
    find("yt.OperationSpec");
  }

  {
    const auto [transformed_query, snapshot_path, append_path, remove_info,
                tag_names_path, entity_types_path, tmp_path] =
        models::yql::TransformYqlQuery(
            models::yql::QueryText{pragma2 + kQueryWithPlaceholder},
            snapshots_dir, models::ProviderName{provider_name},
            models::EntityType::kDbidUuid, std::nullopt, {},
            DeduplicationPolicy::kAllowDuplicates);

    const auto query = RemoveUUID(transformed_query.GetUnderlying());
    ASSERT_TRUE(query.find(pragma2) != std::string::npos);
  }
}

namespace {

std::string StringToPath(const std::string& path, bool should_truncate = true) {
  if (should_truncate) {
    return "\"<append=false>//" + path + "\"";
  }
  return "\"//" + path + "\"";
}

std::string CreateTableQuery(
    const std::string& table_path, bool ordered,
    const std::optional<std::string> entity_name = "dbid_uuid") {
  std::string columns_schema = "tag String";
  std::string order_by = "tag";
  if (entity_name) {
    columns_schema += ", " + *entity_name + " String";
    order_by += ", " + *entity_name;
  }
  std::string res = kCreateTable + " " + StringToPath(table_path, false) + "(" +
                    columns_schema + ") ENGINE = YtTable()";
  if (ordered) {
    res += " ORDER BY (" + order_by + ")";
  }
  res += ";";
  return res;
}

std::string GetChytBasicQueryTransformed(
    const std::string& path, const std::string& tag_names_path,
    const std::optional<std::string>& last_snapshot_path) {
  return "SOME DIFFICULT SELECTS\n"
         "\n"
         "\n"
         "--------------------------------------------------------\n"
         "-- THIS CODE WAS GENERATED BY TAGS SERVICE\n"
         " INSERT INTO " +
         StringToPath(path) +
         "\n"
         "--------------------------------------------------------\n"
         "\n"
         "\n"
         "\n" +
         StringToPath(last_snapshot_path.value_or(path), false) +
         " SELECT 'tag' 'dbid_uuid';\n\n"
         "\n"
         "\n"
         "--------------------------------------------------------\n"
         "-- THIS CODE WAS GENERATED BY TAGS SERVICE\n"
         ";\n\n\n"
         "INSERT INTO " +
         StringToPath(tag_names_path) + " SELECT DISTINCT tag FROM " +
         StringToPath(path, false) + ";\n";
}

}  // namespace

TEST(ChytQueryTransformer, Basic) {
  const auto environment_name = "testing";
  const auto service_name = "passenger-tags";
  const auto provider_name = "provider0";

  const auto snapshots_dir =
      models::yql::GetSnapshotsDirectory(environment_name, service_name);
  ASSERT_EQ(snapshots_dir,
            "home/taxi/testing/features/passenger-tags/snapshots");

  const auto expected_snapshot_path =
      snapshots_dir + "/" + provider_name + "_snapshot";
  const auto expected_tmp_path = snapshots_dir + "/" + provider_name + "_tmp";
  const auto expected_append_path =
      snapshots_dir + "/" + provider_name + "_append";
  const auto expected_remove_path =
      snapshots_dir + "/" + provider_name + "_remove";
  const auto expected_tag_names_path =
      snapshots_dir + "/" + provider_name + "_tag_names";

  {
    auto [transformed_query, snapshot_path, append_path, remove_info,
          tag_names_path, entity_types_path, tmp_path] =
        models::yql::TransformCHQuery(
            models::yql::QueryText{kChytQueryWithPlaceholder}, snapshots_dir,
            models::ProviderName{provider_name}, kCliqueName,
            models::EntityType::kDbidUuid, std::nullopt,
            DeduplicationPolicy::kAllowDuplicates);

    const auto query = RemoveUUID(transformed_query.GetUnderlying());
    std::string expected_query =
        boost::join(std::vector{kCommentGenerated, kUseCluster, kPragma,
                                CreateTableQuery(expected_tmp_path, false),
                                CreateTableQuery(expected_snapshot_path, true),
                                CreateTableQuery(expected_tag_names_path, false,
                                                 std::nullopt),
                                kCommentSection},
                    "\n") +
        "\n\n\n";

    expected_query += GetChytBasicQueryTransformed(
        expected_tmp_path, expected_tag_names_path, expected_snapshot_path);

    expected_query += "INSERT INTO " + StringToPath(expected_snapshot_path) +
                      " SELECT tag, dbid_uuid FROM " +
                      StringToPath(expected_tmp_path, false) +
                      " ORDER BY (tag, dbid_uuid);\n";

    expected_query +=
        "DROP TABLE " + StringToPath(expected_tmp_path, false) + ";\n";
    ASSERT_EQ(query, expected_query);
    ASSERT_EQ(RemoveUUID(snapshot_path), expected_snapshot_path);
    ASSERT_EQ(RemoveUUID(append_path), expected_snapshot_path);
    ASSERT_EQ(remove_info, std::nullopt);
    ASSERT_EQ(entity_types_path, std::nullopt);
    ASSERT_EQ(RemoveUUID(tmp_path), expected_tmp_path);
  }

  {
    const auto old_snapshot_path = "path/to/finished/snapshot";
    auto [transformed_query, snapshot_path, append_path, remove_info,
          tag_names_path, entity_types_path, tmp_path] =
        models::yql::TransformCHQuery(
            models::yql::QueryText{kChytQueryWithPlaceholder}, snapshots_dir,
            models::ProviderName{provider_name}, kCliqueName,
            models::EntityType::kDbidUuid,
            {{models::YtSnapshotStatus::kFullyApplied, old_snapshot_path,
              models::EntityType::kDbidUuid, models::yql::Syntax::kClickhouse}},
            DeduplicationPolicy::kAllowDuplicates);
    auto [remove_path, remove_entity_type] = *remove_info;

    const auto query = RemoveUUID(transformed_query.GetUnderlying());
    std::string expected_result =
        boost::join(std::vector{kCommentGenerated, kUseCluster, kPragma,
                                CreateTableQuery(expected_tmp_path, false),
                                CreateTableQuery(expected_snapshot_path, true),
                                CreateTableQuery(expected_tag_names_path, false,
                                                 std::nullopt),
                                kCommentSection},
                    "\n") +
        "\n\n\n";

    expected_result += GetChytBasicQueryTransformed(
        expected_tmp_path, expected_tag_names_path, old_snapshot_path);

    expected_result += "INSERT INTO " + StringToPath(expected_snapshot_path) +
                       " SELECT tag, dbid_uuid FROM " +
                       StringToPath(expected_tmp_path, false) +
                       " ORDER BY (tag, dbid_uuid);\n";

    expected_result +=
        "DROP TABLE " + StringToPath(expected_tmp_path, false) + ";\n";

    expected_result +=
        boost::join(std::vector{CreateTableQuery(expected_append_path, false),
                                CreateTableQuery(expected_remove_path, false)},
                    "\n") +
        "\n";
    expected_result +=
        "INSERT INTO " + StringToPath(expected_remove_path) +
        " SELECT a.tag, a.dbid_uuid"
        " FROM " +
        StringToPath(old_snapshot_path, false) + " a LEFT JOIN " +
        StringToPath(expected_snapshot_path, false) +
        " b ON a.tag = b.tag AND a.dbid_uuid = b.dbid_uuid WHERE b.tag = '';\n";
    expected_result += "INSERT INTO " + StringToPath(expected_append_path) +
                       " SELECT a.tag, a.dbid_uuid"
                       " FROM " +
                       StringToPath(expected_snapshot_path, false) +
                       " a LEFT JOIN " +
                       StringToPath(old_snapshot_path, false) +
                       " b ON a.tag = b.tag AND a.dbid_uuid = b.dbid_uuid "
                       "WHERE b.tag = '';\n";

    ASSERT_EQ(query, expected_result);
    ASSERT_EQ(RemoveUUID(snapshot_path), expected_snapshot_path);
    ASSERT_EQ(RemoveUUID(append_path), GetAppendPath(service_name));
    ASSERT_EQ(RemoveUUID(remove_path), GetRemovePath(service_name));
    ASSERT_EQ(remove_entity_type, models::EntityType::kDbidUuid);
    ASSERT_EQ(entity_types_path, std::nullopt);
    ASSERT_EQ(RemoveUUID(tmp_path), expected_tmp_path);
  }

  {
    const auto old_snapshot_path = "path/to/finished/snapshot";
    auto [transformed_query, snapshot_path, append_path, remove_info,
          tag_names_path, entity_types_path, tmp_path] =
        models::yql::TransformCHQuery(
            models::yql::QueryText{kChytQueryWithPlaceholder}, snapshots_dir,
            models::ProviderName{provider_name}, kCliqueName,
            models::EntityType::kDbidUuid,
            {{models::YtSnapshotStatus::kFullyApplied, old_snapshot_path,
              models::EntityType::kUdid, models::yql::Syntax::kClickhouse}},
            DeduplicationPolicy::kAllowDuplicates);
    auto [remove_path, remove_entity_type] = *remove_info;

    const auto query = RemoveUUID(transformed_query.GetUnderlying());
    std::string expected_result =
        boost::join(std::vector{kCommentGenerated, kUseCluster, kPragma,
                                CreateTableQuery(expected_tmp_path, false),
                                CreateTableQuery(expected_snapshot_path, true),
                                CreateTableQuery(expected_tag_names_path, false,
                                                 std::nullopt),
                                kCommentSection},
                    "\n") +
        "\n\n\n";

    expected_result += GetChytBasicQueryTransformed(
        expected_tmp_path, expected_tag_names_path, old_snapshot_path);

    expected_result += "INSERT INTO " + StringToPath(expected_snapshot_path) +
                       " SELECT tag, dbid_uuid FROM " +
                       StringToPath(expected_tmp_path, false) +
                       " ORDER BY (tag, dbid_uuid);\n";

    expected_result +=
        "DROP TABLE " + StringToPath(expected_tmp_path, false) + ";\n";

    expected_result +=
        boost::join(
            std::vector{
                CreateTableQuery(expected_append_path, false, "dbid_uuid"),
                CreateTableQuery(expected_remove_path, false, "udid")},
            "\n") +
        "\n";
    expected_result += "INSERT INTO " + StringToPath(expected_remove_path) +
                       " SELECT tag, udid"
                       " FROM " +
                       StringToPath(old_snapshot_path, false) + ";\n";
    expected_result += "INSERT INTO " + StringToPath(expected_append_path) +
                       " SELECT tag, dbid_uuid"
                       " FROM " +
                       StringToPath(expected_snapshot_path, false) + ";\n";

    ASSERT_EQ(query, expected_result);
    ASSERT_EQ(RemoveUUID(snapshot_path), expected_snapshot_path);
    ASSERT_EQ(RemoveUUID(append_path), GetAppendPath(service_name));
    ASSERT_EQ(RemoveUUID(remove_path), GetRemovePath(service_name));
    ASSERT_EQ(remove_entity_type, models::EntityType::kUdid);
    ASSERT_EQ(entity_types_path, std::nullopt);
    ASSERT_EQ(RemoveUUID(tmp_path), expected_tmp_path);
  }
}

namespace {

const std::string kPrefix = "use chyt.hahn/";
const std::string kCreate = ";\ncreate table `//";
const std::string kSelect = "\nas select * from (\n";
const std::string kSelectEnd = "')";
constexpr auto kDateLength{10};

std::string ConvertServiceName(const std::string& service_name) {
  return service_name == "passenger-tags" ? "passenger_tags" : service_name;
}

std::string Engine(const utils::TimePoint ttl) {
  const std::string kEngine = "`\nengine = YtTable('{expiration_time=\"";
  const std::string kEngineSuffix = "\"}')";

  return kEngine + utils::datetime::Timestring(ttl, "UTC", "%FT%T") +
         kEngineSuffix;
}

std::string SelectOld(const std::string& service_name) {
  static const std::string kSelect =
      "select CAST(active as UInt64) as active, entity, entity_type, provider"
      ", tag, timestamp, ttl\nfrom concatYtTablesRange('//home"
      "/taxi/production/features/";
  static const std::string kSuffix = "/events/raw_entries', '2020-04-01', '";

  return kSelect + ConvertServiceName(service_name) + kSuffix;
}

std::string SelectNew(const utils::TimePoint from, const utils::TimePoint to,
                      const std::string& service_name, bool use_days) {
  static const std::string kSelect =
      "select CAST(active as UInt64) as active, entity, entity_type, provider, "
      "tag, timestamp_field as "
      "timestamp, ttl\nfrom concatYtTablesRange('//home/logfeller/logs/taxi-";
  static const std::string kTagEvent = "-tag-event-log/1";

  return boost::join(
             std::vector<std::string>{
                 kSelect + service_name + kTagEvent + (use_days ? "d" : "h"),
                 models::ToAdminIso(from).substr(0, kDateLength),
                 models::ToAdminIso(to).substr(0, kDateLength)},
             "', '") +
         "')";
}

std::string Where(const utils::TimePoint from, const utils::TimePoint to) {
  static const std::string kWhere =
      "\nwhere entity in ('some_entity') and timestamp >= '";
  static const std::string kTo = "' and timestamp < '";

  return kWhere + models::ToIso(from) + kTo + models::ToIso(to) + "\'";
}

const std::string kUnionAll = "\nunion all\n";
const std::string kOrderBy = "\n)\norder by timestamp desc";
const std::string kEnd = ";";

}  // namespace

TEST(HistoryQueryBuilder, Basic) {
  using HistoryRequest = handlers::TagsHistorySearchRequest;

  const auto environment_name = "testing";

  const auto now = utils::datetime::Now();
  const auto ttl = now + std::chrono::hours{24};
  utils::datetime::MockNowSet(now);

  auto from =
      utils::datetime::GuessStringtime("2020-04-01T12:34:56+0000", "UTC");
  auto to = utils::datetime::GuessStringtime("2020-04-02T12:34:56+0000", "UTC");

  {
    const auto service_name = "passenger-tags";

    const auto history_search_dir =
        models::yql::GetHistorySearchDirectory(environment_name, service_name);
    ASSERT_EQ(history_search_dir,
              "home/taxi/testing/features/passenger-tags/history_search");

    const auto [path, query] = models::yql::GetHistoryQueryInfo(
        HistoryRequest{std::vector<std::string>{"some_entity"}, std::nullopt,
                       std::nullopt, std::nullopt, models::ToIso(from),
                       models::ToIso(to)},
        now, from, to, {}, {}, history_search_dir, "clique_name", service_name);

    const auto uuid = path.substr(path.rfind('/'));
    const auto expected_path = history_search_dir + uuid;
    const auto expected_query = kPrefix + "clique_name" + kCreate +
                                expected_path + Engine(ttl) + kSelect +
                                SelectOld(service_name) + "2020-04-02" +
                                kSelectEnd + Where(from, to) + kOrderBy + kEnd;

    ASSERT_EQ(path, expected_path);
    ASSERT_EQ(query, expected_query);
  }

  to = now;
  {
    const auto service_name = "tags";

    const auto history_search_dir =
        models::yql::GetHistorySearchDirectory(environment_name, service_name);
    ASSERT_EQ(history_search_dir,
              "home/taxi/testing/features/tags/history_search");

    const auto to_iso = models::ToAdminIso(to);
    const auto [path, query] = models::yql::GetHistoryQueryInfo(
        HistoryRequest{std::vector<std::string>{"some_entity"}, std::nullopt,
                       std::nullopt, std::nullopt, models::ToIso(from), to_iso},
        now, from, to, {"2020-04-01", to_iso.substr(0, kDateLength)}, {},
        history_search_dir, "clique_name", service_name);

    const auto uuid = path.substr(path.rfind('/'));
    const auto expected_path = history_search_dir + uuid;
    const auto expected_query =
        kPrefix + "clique_name" + kCreate + expected_path + Engine(ttl) +
        kSelect + SelectOld(service_name) + to_iso.substr(0, kDateLength) +
        kSelectEnd + Where(from, to) + kUnionAll +
        SelectNew(from, to, service_name, true) + Where(from, to) + kOrderBy +
        kEnd;

    ASSERT_EQ(path, expected_path);
    ASSERT_EQ(query, expected_query);
  }

  from = utils::datetime::GuessStringtime("2020-04-07T12:34:56+0000", "UTC");
  {
    const auto service_name = "passenger-tags";

    const auto history_search_dir =
        models::yql::GetHistorySearchDirectory(environment_name, service_name);
    ASSERT_EQ(history_search_dir,
              "home/taxi/testing/features/passenger-tags/history_search");

    const auto to_iso = models::ToAdminIso(to);
    const std::string kToDay = to_iso.substr(0, kDateLength);
    auto [path, query] = models::yql::GetHistoryQueryInfo(
        HistoryRequest{std::vector<std::string>{"some_entity"}, std::nullopt,
                       std::nullopt, std::nullopt, models::ToIso(from), to_iso},
        now, from, to, {"2020-04-07", kToDay}, {kToDay}, history_search_dir,
        "clique_name", service_name);

    const auto uuid = path.substr(path.rfind('/'));
    const auto expected_path = history_search_dir + uuid;
    const auto expected_query =
        kPrefix + "clique_name" + kCreate + expected_path + Engine(ttl) +
        kSelect + SelectNew(from, to, service_name, true) + Where(from, to) +
        kUnionAll + SelectNew(to, to, service_name, false) + Where(from, to) +
        kOrderBy + kEnd;

    ASSERT_EQ(path, expected_path);
    ASSERT_EQ(query, expected_query);
  }
}
