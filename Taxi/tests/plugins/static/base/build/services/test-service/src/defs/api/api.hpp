/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s): api.yaml

#pragma once

#include <array>
#include <boost/type_traits/has_equal_to.hpp>
#include <codegen/convert_to_json_optional.hpp>
#include <codegen/format.hpp>
#include <codegen/non_null_ptr.hpp>
#include <codegen/parsing_flags.hpp>
#include <optional>
#include <string>
#include <userver/formats/json/inline.hpp>
#include <userver/formats/json/string_builder_fwd.hpp>
#include <userver/formats/json/value.hpp>
#include <userver/formats/json/value_builder.hpp>
#include <userver/logging/log_helper_fwd.hpp>

#include <codegen/parser/datetime_parser.hpp>
#include <codegen/parser/dummy_parser.hpp>  // TODO: for debug only
#include <codegen/parser/enum_parser.hpp>
#include <codegen/parser/extra_helper.hpp>
#include <codegen/parser/null_swallow.hpp>
#include <codegen/parser/nullable_helper.hpp>
#include <codegen/parser/parser_converter.hpp>
#include <codegen/parser/parser_dom.hpp>
#include <codegen/parser/parser_empty.hpp>
#include <codegen/parser/parser_non_null_ptr.hpp>
#include <codegen/parser/validator.hpp>
#include <codegen/parser/value_builder_helper.hpp>
#include <userver/formats/json/parser/parser.hpp>

namespace handlers {

struct Request {
  ::std::optional<::std::string> data{};
  double id{};
};

Request Parse(const formats::json::Value& elem, formats::parse::To<Request>);

namespace parser {
class PRequest final
    : public ::formats::json::parser::TypedParser<handlers::Request> {
 public:
  PRequest();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  handlers::Request result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  // data
  // .cpp_type: std::optional<::std::string>
  // .optional_subtype: std::string
  // cpp_type: std::string
  ::formats::json::parser::StringParser f_data_;

  ::codegen::parser::NullableHelper<::std::optional<::std::string>,
                                    decltype(f_data_)>
      null_data_{f_data_};
  ::formats::json::parser::SubscriberSinkOptional<std::string> sink_data_{
      result_.data};

  bool s_data_{false};

  // id
  // .cpp_type: double
  // .optional_subtype: None
  // cpp_type: double
  ::formats::json::parser::DoubleParser f_id_;

  ::formats::json::parser::SubscriberSink<double> sink_id_{result_.id};

  bool s_id_{false};

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

logging::LogHelper& operator<<(logging::LogHelper& lh, const Request& v);

template <typename U>
std::enable_if_t<std::is_same<U, Request>::value, bool> operator==(const U& lhs,
                                                                   const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(boost::has_equal_to<decltype(lhs.data)>::value,
                "No operator==() defined for field 'data' of type "
                "'::std::optional<::std::string>'");
  static_assert(boost::has_equal_to<decltype(lhs.id)>::value,
                "No operator==() defined for field 'id' of type 'double'");

  return std::tie(lhs.data, lhs.id) == std::tie(rhs.data, rhs.id);
}

template <typename U>
std::enable_if_t<std::is_same<U, Request>::value, bool> operator!=(const U& lhs,
                                                                   const U& rhs)
{
  return !(lhs == rhs);
}

::formats::json::Value Serialize(
    const Request& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const Request& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

struct BadRequest {
  ::std::optional<::std::string> message{};
};

BadRequest Parse(const formats::json::Value& elem,
                 formats::parse::To<BadRequest>);

namespace parser {
class PBadRequest final
    : public ::formats::json::parser::TypedParser<handlers::BadRequest> {
 public:
  PBadRequest();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  handlers::BadRequest result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  // message
  // .cpp_type: std::optional<::std::string>
  // .optional_subtype: std::string
  // cpp_type: std::string
  ::formats::json::parser::StringParser f_message_;

  ::codegen::parser::NullableHelper<::std::optional<::std::string>,
                                    decltype(f_message_)>
      null_message_{f_message_};
  ::formats::json::parser::SubscriberSinkOptional<std::string> sink_message_{
      result_.message};

  bool s_message_{false};

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

logging::LogHelper& operator<<(logging::LogHelper& lh, const BadRequest& v);

template <typename U>
std::enable_if_t<std::is_same<U, BadRequest>::value, bool> operator==(
    const U& lhs, const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(boost::has_equal_to<decltype(lhs.message)>::value,
                "No operator==() defined for field 'message' of type "
                "'::std::optional<::std::string>'");

  return std::tie(lhs.message) == std::tie(rhs.message);
}

template <typename U>
std::enable_if_t<std::is_same<U, BadRequest>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

::formats::json::Value Serialize(
    const BadRequest& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const BadRequest& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

}
