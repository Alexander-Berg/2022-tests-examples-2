/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s):
// taxi/uservices/services/test-service/experiments3/declarations/test_big_experiment.yaml

#pragma once

#include <experiments3/models/experiment_type.hpp>

#include <optional>
#include <string>
#include <vector>

#include <array>
#include <boost/type_traits/has_equal_to.hpp>
#include <codegen/convert_to_json_optional.hpp>
#include <codegen/format.hpp>
#include <codegen/parsing_flags.hpp>
#include <userver/formats/json/inline.hpp>
#include <userver/formats/json/string_builder_fwd.hpp>
#include <userver/formats/json/value_builder.hpp>
#include <userver/logging/log_helper_fwd.hpp>

#include <codegen/parser/datetime_parser.hpp>
#include <codegen/parser/dummy_parser.hpp>  // TODO: for debug only
#include <codegen/parser/enum_parser.hpp>
#include <codegen/parser/extra_helper.hpp>
#include <codegen/parser/null_swallow.hpp>
#include <codegen/parser/nullable_helper.hpp>
#include <codegen/parser/parser_converter.hpp>
#include <codegen/parser/parser_dom.hpp>
#include <codegen/parser/parser_empty.hpp>
#include <codegen/parser/parser_non_null_ptr.hpp>
#include <codegen/parser/validator.hpp>
#include <codegen/parser/value_builder_helper.hpp>
#include <userver/formats/json/parser/parser.hpp>

namespace experiments3::e_x_p_w_i_t_h_unusual_chars228 {

enum class ValueSomearrayA { kEnumValue1, kEnumValue2 };

inline constexpr std::array<ValueSomearrayA, 2> kValueSomearrayAValues = {
    ValueSomearrayA::kEnumValue1,
    ValueSomearrayA::kEnumValue2,
};

std::string ToString(
    experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA value);

ValueSomearrayA Parse(const formats::json::Value& elem,
                      formats::parse::To<ValueSomearrayA>);

ValueSomearrayA Parse(std::string_view elem,
                      formats::parse::To<ValueSomearrayA>);

namespace parser {
using PValueSomearrayA = ::codegen::parser::EnumParser<
    experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA>;

}  // namespace parser

}

namespace experiments3::e_x_p_w_i_t_h_unusual_chars228 {

struct ValueSomeobject {
  int some_field{};
};

ValueSomeobject Parse(const formats::json::Value& elem,
                      formats::parse::To<ValueSomeobject>);

namespace parser {
class PValueSomeobject final
    : public ::formats::json::parser::TypedParser<
          experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomeobject> {
 public:
  PValueSomeobject();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomeobject result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  // some_field
  // .cpp_type: int
  // .optional_subtype: None
  // cpp_type: int
  ::formats::json::parser::IntegralParser<int> f_some_field_;

  ::codegen::parser::NullSwallow<int, decltype(f_some_field_)> null_some_field_{
      f_some_field_};
  ::formats::json::parser::SubscriberSink<int> sink_some_field_{
      result_.some_field};

  bool s_some_field_{false};

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

}

namespace experiments3::e_x_p_w_i_t_h_unusual_chars228 {

/// Internal navi experiment
struct Value {
  bool is_enabled{};
  ::std::optional<::std::string> page_id{};
  ::std::vector<experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA>
      some_array{};
  ::std::optional<
      ::experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomeobject>
      some_object{};
};

Value Parse(const formats::json::Value& elem, formats::parse::To<Value>);

namespace parser {
class PValue final: public ::formats::json::parser::TypedParser<
                        experiments3::e_x_p_w_i_t_h_unusual_chars228::Value> {
 public:
  PValue();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  experiments3::e_x_p_w_i_t_h_unusual_chars228::Value result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  // is_enabled
  // .cpp_type: bool
  // .optional_subtype: None
  // cpp_type: bool
  ::formats::json::parser::BoolParser f_is_enabled_;

  ::codegen::parser::NullSwallow<bool, decltype(f_is_enabled_)>
      null_is_enabled_{f_is_enabled_};
  ::formats::json::parser::SubscriberSink<bool> sink_is_enabled_{
      result_.is_enabled};

  bool s_is_enabled_{false};

  // page_id
  // .cpp_type: std::optional<::std::string>
  // .optional_subtype: std::string
  // cpp_type: std::string
  ::formats::json::parser::StringParser f_page_id_;

  ::codegen::parser::NullableHelper<::std::optional<::std::string>,
                                    decltype(f_page_id_)>
      null_page_id_{f_page_id_};
  ::formats::json::parser::SubscriberSinkOptional<std::string> sink_page_id_{
      result_.page_id};

  bool s_page_id_{false};

  // some_array
  // .cpp_type: experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA
  // .optional_subtype: None
  // cpp_type: experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA
  experiments3::e_x_p_w_i_t_h_unusual_chars228::parser::PValueSomearrayA
      f_some_array_i_;

  ::formats::json::parser::ArrayParser<
      experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA,
      decltype(f_some_array_i_),
      std::vector<
          experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA>>
      f_some_array_{f_some_array_i_};

  ::formats::json::parser::SubscriberSink<std::vector<
      experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA>>
      sink_some_array_{result_.some_array};

  bool s_some_array_{false};

  // some_object
  // .cpp_type:
  // std::optional<::experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomeobject>
  // .optional_subtype:
  // experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomeobject cpp_type:
  // experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomeobject
  experiments3::e_x_p_w_i_t_h_unusual_chars228::parser::PValueSomeobject
      f_some_object_;

  ::codegen::parser::NullableHelper<
      ::std::optional<
          ::experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomeobject>,
      decltype(f_some_object_)>
      null_some_object_{f_some_object_};
  ::formats::json::parser::SubscriberSinkOptional<
      experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomeobject>
      sink_some_object_{result_.some_object};

  bool s_some_object_{false};

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

}

namespace experiments3 {
struct EXPWITHUnusualChars228 {
  using Value = experiments3::e_x_p_w_i_t_h_unusual_chars228::Value;
  enum class Type { kExperiment, kConfig, kUnion };
  static constexpr auto kType = Type::kExperiment;
  static constexpr bool kCacheResult = false;
  static const std::string kName;
};
}
