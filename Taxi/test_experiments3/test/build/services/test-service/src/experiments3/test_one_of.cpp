/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s):
// taxi/uservices/services/test-service/experiments3/declarations/test_one_of.yaml

#include <experiments3/test_one_of.hpp>

#include <userver/formats/json/serialize_container.hpp>
#include <userver/formats/json/serialize_variant.hpp>
#include <userver/formats/parse/common_containers.hpp>
#include <userver/formats/parse/variant.hpp>

#include <codegen/impl/convert.hpp>
#include <codegen/impl/get_validation_length.hpp>
#include <codegen/impl/optional_convert.hpp>
#include <codegen/impl/parsers.hpp>
#include <cstring>
#include <unordered_set>
#include <userver/formats/common/meta.hpp>
#include <userver/formats/json/string_builder.hpp>
#include <userver/logging/log.hpp>
#include <userver/utils/assert.hpp>
#include <userver/utils/datetime/from_string_saturating.hpp>
#include <userver/utils/underlying_value.hpp>

#include <codegen/impl/convert.hpp>

namespace experiments3::test_one_of {

experiments3::test_one_of::ValueTicketschemaAT0 Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<experiments3::test_one_of::ValueTicketschemaAT0>) {
  experiments3::test_one_of::ValueTicketschemaAT0 result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.name = elem["name"].As<std::optional<::std::string>>();
  result.tag = elem["tag"].As<std::optional<::std::string>>();
  result.ticket_param_name =
      elem["ticket_param_name"].As<std::optional<::std::string>>();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PValueTicketschemaAT0::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PValueTicketschemaAT0::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PValueTicketschemaAT0::PValueTicketschemaAT0()
{
  null_name_.Subscribe(sink_name_);

  f_name_.Subscribe(sink_name_);
  null_tag_.Subscribe(sink_tag_);

  f_tag_.Subscribe(sink_tag_);
  null_ticket_param_name_.Subscribe(sink_ticket_param_name_);

  f_ticket_param_name_.Subscribe(sink_ticket_param_name_);
}

void PValueTicketschemaAT0::Reset()
{
  state_ = State::kStart;
  result_ = {};

  s_name_ = false;
  s_tag_ = false;
  s_ticket_param_name_ = false;
}

void PValueTicketschemaAT0::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PValueTicketschemaAT0::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else if (key == "name") {
    s_name_ = true;
    f_name_.Reset();

    parser_state_->PushParser(null_name_.GetParser());
  }

  else if (key == "tag") {
    s_tag_ = true;
    f_tag_.Reset();

    parser_state_->PushParser(null_tag_.GetParser());
  }

  else if (key == "ticket_param_name") {
    s_ticket_param_name_ = true;
    f_ticket_param_name_.Reset();

    parser_state_->PushParser(null_ticket_param_name_.GetParser());
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PValueTicketschemaAT0::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      if (!s_name_) {
        result_.name = {};
      }
      if (!s_tag_) {
        result_.tag = {};
      }
      if (!s_ticket_param_name_) {
        result_.ticket_param_name = {};
      }

      SetResult(std::move(result_));
      break;
  }
}

std::string PValueTicketschemaAT0::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PValueTicketschemaAT0::GetPathItem() const { return key_; }
}

}

namespace experiments3::test_one_of {

experiments3::test_one_of::ValueTicketschemaAT1 Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<experiments3::test_one_of::ValueTicketschemaAT1>) {
  experiments3::test_one_of::ValueTicketschemaAT1 result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.name = elem["name"].As<std::optional<::std::string>>();
  result.tag = elem["tag"].As<std::optional<bool>>();
  result.ticket_param_name =
      elem["ticket_param_name"].As<std::optional<::std::string>>();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PValueTicketschemaAT1::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PValueTicketschemaAT1::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PValueTicketschemaAT1::PValueTicketschemaAT1()
{
  null_name_.Subscribe(sink_name_);

  f_name_.Subscribe(sink_name_);
  null_tag_.Subscribe(sink_tag_);

  f_tag_.Subscribe(sink_tag_);
  null_ticket_param_name_.Subscribe(sink_ticket_param_name_);

  f_ticket_param_name_.Subscribe(sink_ticket_param_name_);
}

void PValueTicketschemaAT1::Reset()
{
  state_ = State::kStart;
  result_ = {};

  s_name_ = false;
  s_tag_ = false;
  s_ticket_param_name_ = false;
}

void PValueTicketschemaAT1::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PValueTicketschemaAT1::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else if (key == "name") {
    s_name_ = true;
    f_name_.Reset();

    parser_state_->PushParser(null_name_.GetParser());
  }

  else if (key == "tag") {
    s_tag_ = true;
    f_tag_.Reset();

    parser_state_->PushParser(null_tag_.GetParser());
  }

  else if (key == "ticket_param_name") {
    s_ticket_param_name_ = true;
    f_ticket_param_name_.Reset();

    parser_state_->PushParser(null_ticket_param_name_.GetParser());
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PValueTicketschemaAT1::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      if (!s_name_) {
        result_.name = {};
      }
      if (!s_tag_) {
        result_.tag = {};
      }
      if (!s_ticket_param_name_) {
        result_.ticket_param_name = {};
      }

      SetResult(std::move(result_));
      break;
  }
}

std::string PValueTicketschemaAT1::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PValueTicketschemaAT1::GetPathItem() const { return key_; }
}

}

namespace experiments3::test_one_of {

experiments3::test_one_of::Value Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<experiments3::test_one_of::Value>) {
  experiments3::test_one_of::Value result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.ticket_schema = [](const formats::json::Value& array)
      -> ::std::optional<::std::vector<
          std::variant<experiments3::test_one_of::ValueTicketschemaAT0,
                       experiments3::test_one_of::ValueTicketschemaAT1>>> {
    if (array.IsMissing() || array.IsNull()) return std::nullopt;

    std::vector<std::variant<experiments3::test_one_of::ValueTicketschemaAT0,
                             experiments3::test_one_of::ValueTicketschemaAT1>>
        result;
    array.CheckArrayOrNull();
    result.reserve(array.GetSize());
    for (const auto& item : array) {
      result.insert(
          result.end(),
          [](const formats::json::Value& value)
              -> std::variant<experiments3::test_one_of::ValueTicketschemaAT0,
                              experiments3::test_one_of::ValueTicketschemaAT1> {
            std::optional<
                std::variant<experiments3::test_one_of::ValueTicketschemaAT0,
                             experiments3::test_one_of::ValueTicketschemaAT1>>
                result;
            int parse_successes = 0;

            try {
              result =
                  value.As<experiments3::test_one_of::ValueTicketschemaAT0>();
              ++parse_successes;
            } catch (const std::exception&) {
            }
            try {
              result =
                  value.As<experiments3::test_one_of::ValueTicketschemaAT1>();
              ++parse_successes;
            } catch (const std::exception&) {
            }

            if (parse_successes > 1) {
              throw ::formats::json::ParseException(
                  "Value of '" + value.GetPath() +
                  "' is ambiguous, it is parseable into multiple types");
            }

            if (!result) {
              throw ::formats::json::ParseException(
                  "Value of '" + value.GetPath() +
                  "' cannot be parsed as a variant");
            }
            return std::move(*result);
          }(item)

      );
    }

    return ::codegen::impl::Convert<
        ::std::optional<::std::vector<std::variant<
            experiments3::test_one_of::ValueTicketschemaAT0,
            experiments3::test_one_of::ValueTicketschemaAT1>>>::value_type,
        std::vector<
            std::variant<experiments3::test_one_of::ValueTicketschemaAT0,
                         experiments3::test_one_of::ValueTicketschemaAT1>>>(
        std::move(result));
  }(elem["ticket_schema"]);
  result.ticket_tags = [](const formats::json::Value& array)
      -> ::std::optional<::std::vector<std::string>> {
    if (array.IsMissing() || array.IsNull()) return std::nullopt;

    std::vector<std::string> result;
    array.CheckArrayOrNull();
    result.reserve(array.GetSize());
    for (const auto& item : array) {
      result.insert(result.end(), item.As<std::string>());
    }

    return ::codegen::impl::Convert<
        ::std::optional<::std::vector<std::string>>::value_type,
        std::vector<std::string>>(std::move(result));
  }(elem["ticket_tags"]);

  return result;
}

namespace parser {
template <class To>
template <class From>
To PValue::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PValue::ParserLocalDomToType<To>::Convert(::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

std::variant<experiments3::test_one_of::ValueTicketschemaAT0,
             experiments3::test_one_of::ValueTicketschemaAT1>
PValue::f_ticket_schemaconv__i_::Convert(::formats::json::Value&& value) {
  return [](const formats::json::Value& value)
             -> std::variant<experiments3::test_one_of::ValueTicketschemaAT0,
                             experiments3::test_one_of::ValueTicketschemaAT1> {
    std::optional<std::variant<experiments3::test_one_of::ValueTicketschemaAT0,
                               experiments3::test_one_of::ValueTicketschemaAT1>>
        result;
    int parse_successes = 0;

    try {
      result = value.As<experiments3::test_one_of::ValueTicketschemaAT0>();
      ++parse_successes;
    } catch (const std::exception&) {
    }
    try {
      result = value.As<experiments3::test_one_of::ValueTicketschemaAT1>();
      ++parse_successes;
    } catch (const std::exception&) {
    }

    if (parse_successes > 1) {
      throw ::formats::json::ParseException(
          "Value of '" + value.GetPath() +
          "' is ambiguous, it is parseable into multiple types");
    }

    if (!result) {
      throw ::formats::json::ParseException("Value of '" + value.GetPath() +
                                            "' cannot be parsed as a variant");
    }
    return std::move(*result);
  }(value);
}

PValue::PValue()
{
  null_ticket_schema_.Subscribe(sink_ticket_schema_);

  f_ticket_schema_.Subscribe(sink_ticket_schema_);
  null_ticket_tags_.Subscribe(sink_ticket_tags_);

  f_ticket_tags_.Subscribe(sink_ticket_tags_);
}

void PValue::Reset()
{
  state_ = State::kStart;
  result_ = {};

  s_ticket_schema_ = false;
  s_ticket_tags_ = false;
}

void PValue::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PValue::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else if (key == "ticket_schema") {
    s_ticket_schema_ = true;
    f_ticket_schema_.Reset();

    parser_state_->PushParser(null_ticket_schema_.GetParser());
  }

  else if (key == "ticket_tags") {
    s_ticket_tags_ = true;
    f_ticket_tags_.Reset();

    parser_state_->PushParser(null_ticket_tags_.GetParser());
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PValue::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      if (!s_ticket_schema_) {
        result_.ticket_schema = {};
      }
      if (!s_ticket_tags_) {
        result_.ticket_tags = {};
      }

      SetResult(std::move(result_));
      break;
  }
}

std::string PValue::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PValue::GetPathItem() const { return key_; }
}

}

namespace experiments3 {

const std::string TestOneOf::kName = "test_one_of";

}
