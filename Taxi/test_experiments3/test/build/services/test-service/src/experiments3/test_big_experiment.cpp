/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s):
// taxi/uservices/services/test-service/experiments3/declarations/test_big_experiment.yaml

#include <experiments3/test_big_experiment.hpp>

#include <userver/formats/json/serialize_container.hpp>
#include <userver/formats/parse/common_containers.hpp>

#include <codegen/impl/convert.hpp>
#include <codegen/impl/get_validation_length.hpp>
#include <codegen/impl/optional_convert.hpp>
#include <codegen/impl/parsers.hpp>
#include <cstring>
#include <unordered_set>
#include <userver/formats/common/meta.hpp>
#include <userver/formats/json/string_builder.hpp>
#include <userver/logging/log.hpp>
#include <userver/utils/assert.hpp>
#include <userver/utils/datetime/from_string_saturating.hpp>
#include <userver/utils/underlying_value.hpp>

#include <codegen/impl/convert.hpp>

namespace experiments3::e_x_p_w_i_t_h_unusual_chars228 {

experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<
        experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA>) {
  const auto& value = elem.As<std::string>();
  if (value == "enum_value1") {
    return experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA::
        kEnumValue1;
  } else if (value == "enum_value2") {
    return experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA::
        kEnumValue2;
  } else {
    throw formats::json::ParseException("Value of '" + elem.GetPath() + "' (" +
                                        value + ") is not parseable into enum");
  }
}

ValueSomearrayA Parse(std::string_view value,
                      formats::parse::To<ValueSomearrayA>)
{
  static const std::unordered_map<
      std::string_view,
      experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA>
      map = {
          {"enum_value1", experiments3::e_x_p_w_i_t_h_unusual_chars228::
                              ValueSomearrayA::kEnumValue1},
          {"enum_value2", experiments3::e_x_p_w_i_t_h_unusual_chars228::
                              ValueSomearrayA::kEnumValue2},
      };
  auto it = map.find(value);
  if (it != map.end()) return it->second;

  throw std::runtime_error(
      "Value '" + std::string{value} +
      "' is not parseable into "
      "experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA");
}

std::string ToString(
    experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA value) {
  switch (value) {
    case experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA::
        kEnumValue1:
      return "enum_value1";
    case experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA::
        kEnumValue2:
      return "enum_value2";
  }
  throw std::runtime_error(
      "Detected an attempt to serialize a corrupted "
      "'experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA' (" +
      std::to_string(utils::UnderlyingValue(value)) + ")");
}

}

namespace experiments3::e_x_p_w_i_t_h_unusual_chars228 {

experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomeobject Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<
        experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomeobject>) {
  experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomeobject result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.some_field = elem["some_field"].As<int>(42);

  return result;
}

namespace parser {
template <class To>
template <class From>
To PValueSomeobject::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PValueSomeobject::ParserLocalDomToType<To>::Convert(
    ::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PValueSomeobject::PValueSomeobject()
{
  null_some_field_.Subscribe(sink_some_field_);

  f_some_field_.Subscribe(sink_some_field_);
}

void PValueSomeobject::Reset()
{
  state_ = State::kStart;
  result_ = {};

  s_some_field_ = false;
}

void PValueSomeobject::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PValueSomeobject::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else if (key == "some_field") {
    s_some_field_ = true;
    f_some_field_.Reset();

    parser_state_->PushParser(null_some_field_.GetParser());
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PValueSomeobject::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      if (!s_some_field_ || null_some_field_.HasNullValue()) {
        result_.some_field = 42;
      }

      SetResult(std::move(result_));
      break;
  }
}

std::string PValueSomeobject::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PValueSomeobject::GetPathItem() const { return key_; }
}

}

namespace experiments3::e_x_p_w_i_t_h_unusual_chars228 {

experiments3::e_x_p_w_i_t_h_unusual_chars228::Value Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<experiments3::e_x_p_w_i_t_h_unusual_chars228::Value>) {
  experiments3::e_x_p_w_i_t_h_unusual_chars228::Value result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.is_enabled = elem["is_enabled"].As<bool>(false);
  result.page_id = elem["page_id"].As<std::optional<::std::string>>();
  result.some_array = [](const formats::json::Value& array)
      -> std::vector<
          experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA> {
    std::vector<experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA>
        result;
    array.CheckArrayOrNull();
    result.reserve(array.GetSize());
    for (const auto& item : array) {
      result.insert(
          result.end(),
          item.As<
              experiments3::e_x_p_w_i_t_h_unusual_chars228::ValueSomearrayA>());
    }

    return result;
  }(elem["some_array"]);
  result.some_object =
      elem["some_object"]
          .As<std::optional<::experiments3::e_x_p_w_i_t_h_unusual_chars228::
                                ValueSomeobject>>();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PValue::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PValue::ParserLocalDomToType<To>::Convert(::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PValue::PValue()
{
  null_is_enabled_.Subscribe(sink_is_enabled_);

  f_is_enabled_.Subscribe(sink_is_enabled_);
  null_page_id_.Subscribe(sink_page_id_);

  f_page_id_.Subscribe(sink_page_id_);

  f_some_array_.Subscribe(sink_some_array_);
  null_some_object_.Subscribe(sink_some_object_);

  f_some_object_.Subscribe(sink_some_object_);
}

void PValue::Reset()
{
  state_ = State::kStart;
  result_ = {};

  s_is_enabled_ = false;
  s_page_id_ = false;
  s_some_array_ = false;
  s_some_object_ = false;
}

void PValue::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PValue::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else if (key == "is_enabled") {
    s_is_enabled_ = true;
    f_is_enabled_.Reset();

    parser_state_->PushParser(null_is_enabled_.GetParser());
  }

  else if (key == "page_id") {
    s_page_id_ = true;
    f_page_id_.Reset();

    parser_state_->PushParser(null_page_id_.GetParser());
  }

  else if (key == "some_array") {
    s_some_array_ = true;
    f_some_array_.Reset();

    parser_state_->PushParser(f_some_array_.GetParser());
  }

  else if (key == "some_object") {
    s_some_object_ = true;
    f_some_object_.Reset();

    parser_state_->PushParser(null_some_object_.GetParser());
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PValue::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      if (!s_is_enabled_ || null_is_enabled_.HasNullValue()) {
        result_.is_enabled = false;
      }
      if (!s_page_id_) {
        result_.page_id = {};
      }
      if (!s_some_array_) {
        throw ::formats::json::parser::InternalParseError(
            "missing required field 'some_array'");
      }
      if (!s_some_object_) {
        result_.some_object = {};
      }

      SetResult(std::move(result_));
      break;
  }
}

std::string PValue::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PValue::GetPathItem() const { return key_; }
}

}

namespace experiments3 {

const std::string EXPWITHUnusualChars228::kName =
    "_e:x:p-W_I_T_H-:-unusual---cHaRs228";

}
