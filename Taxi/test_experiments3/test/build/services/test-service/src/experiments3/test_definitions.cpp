/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s):
// taxi/uservices/services/test-service/experiments3/declarations/test_definitions.yaml

#include <experiments3/test_definitions.hpp>

#include <userver/formats/json/serialize_container.hpp>
#include <userver/formats/parse/common_containers.hpp>

#include <codegen/impl/convert.hpp>
#include <codegen/impl/get_validation_length.hpp>
#include <codegen/impl/optional_convert.hpp>
#include <codegen/impl/parsers.hpp>
#include <cstring>
#include <unordered_set>
#include <userver/formats/common/meta.hpp>
#include <userver/formats/json/string_builder.hpp>
#include <userver/logging/log.hpp>
#include <userver/utils/assert.hpp>
#include <userver/utils/datetime/from_string_saturating.hpp>
#include <userver/utils/underlying_value.hpp>

#include <codegen/impl/convert.hpp>

namespace experiments3::test_definitions {

experiments3::test_definitions::SomeObj Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<experiments3::test_definitions::SomeObj>) {
  experiments3::test_definitions::SomeObj result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.sub = elem["sub"].As<std::string>("I am subref");

  return result;
}

namespace parser {
template <class To>
template <class From>
To PSomeObj::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PSomeObj::ParserLocalDomToType<To>::Convert(::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PSomeObj::PSomeObj()
{
  null_sub_.Subscribe(sink_sub_);

  f_sub_.Subscribe(sink_sub_);
}

void PSomeObj::Reset()
{
  state_ = State::kStart;
  result_ = {};

  s_sub_ = false;
}

void PSomeObj::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PSomeObj::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else if (key == "sub") {
    s_sub_ = true;
    f_sub_.Reset();

    parser_state_->PushParser(null_sub_.GetParser());
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PSomeObj::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      if (!s_sub_ || null_sub_.HasNullValue()) {
        result_.sub = "I am subref";
      }

      SetResult(std::move(result_));
      break;
  }
}

std::string PSomeObj::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PSomeObj::GetPathItem() const { return key_; }
}

}

namespace experiments3::test_definitions {

experiments3::test_definitions::Value Parse(
    [[maybe_unused]] const formats::json::Value& elem,
    formats::parse::To<experiments3::test_definitions::Value>) {
  experiments3::test_definitions::Value result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.some_int = elem["some_int"].As<int>(42);
  result.some_list = [](const formats::json::Value& array)
      -> ::std::optional<::std::vector<std::string>> {
    if (array.IsMissing() || array.IsNull()) return std::nullopt;

    std::vector<std::string> result;
    array.CheckArrayOrNull();
    result.reserve(array.GetSize());
    for (const auto& item : array) {
      result.insert(result.end(), item.As<std::string>("I am subref"));
    }

    return ::codegen::impl::Convert<
        ::std::optional<::std::vector<std::string>>::value_type,
        std::vector<std::string>>(std::move(result));
  }(elem["some_list"]);
  result.some_obj =
      elem["some_obj"]
          .As<std::optional<::experiments3::test_definitions::SomeObj>>();

  return result;
}

namespace parser {
template <class To>
template <class From>
To PValue::ParserLocalConverterTrait<To>::Convert(From&& from) {
  return ::codegen::impl::Convert<To>(std::forward<From>(from));
}

template <class To>
To PValue::ParserLocalDomToType<To>::Convert(::formats::json::Value&& value) {
  return std::move(value).As<To>();
}

PValue::PValue()
{
  null_some_int_.Subscribe(sink_some_int_);

  f_some_int_.Subscribe(sink_some_int_);
  null_some_list_.Subscribe(sink_some_list_);

  f_some_list_.Subscribe(sink_some_list_);
  null_some_obj_.Subscribe(sink_some_obj_);

  f_some_obj_.Subscribe(sink_some_obj_);
}

void PValue::Reset()
{
  state_ = State::kStart;
  result_ = {};

  s_some_int_ = false;
  s_some_list_ = false;
  s_some_obj_ = false;
}

void PValue::StartObject() {
  switch (state_) {
    case State::kStart:
      state_ = State::kInside;
      break;

    case State::kInside:
      Throw("{");
  }
}

void PValue::Key([[maybe_unused]] std::string_view key)
{
  key_ = key;
  if (false) {
  } else if (key == "some_int") {
    s_some_int_ = true;
    f_some_int_.Reset();

    parser_state_->PushParser(null_some_int_.GetParser());
  }

  else if (key == "some_list") {
    s_some_list_ = true;
    f_some_list_.Reset();

    parser_state_->PushParser(null_some_list_.GetParser());
  }

  else if (key == "some_obj") {
    s_some_obj_ = true;
    f_some_obj_.Reset();

    parser_state_->PushParser(null_some_obj_.GetParser());
  } else {
    /* Eat and ignore unknown value */
    ff_empty_.Reset();
    parser_state_->PushParser(ff_empty_.GetParser());
  }
}

void PValue::EndObject()
{
  switch (state_) {
    case State::kStart:
      Throw("}");

    case State::kInside:
      // If an exception is thrown below, we must not set .old_key
      key_.clear();

      if (!s_some_int_ || null_some_int_.HasNullValue()) {
        result_.some_int = 42;
      }
      if (!s_some_list_) {
        result_.some_list = {};
      }
      if (!s_some_obj_) {
        result_.some_obj = {};
      }

      SetResult(std::move(result_));
      break;
  }
}

std::string PValue::Expected() const {
  switch (state_) {
    case State::kStart:
      return "object";

    case State::kInside:
      return "field name";
  }
}

std::string PValue::GetPathItem() const { return key_; }
}

}

namespace experiments3 {

const std::string TestDefinitions::kName = "test_definitions";

}
