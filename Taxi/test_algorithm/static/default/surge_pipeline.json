{
  "consumer": "taxi-surge",
  "global_scope": {
    "source_code": "function is_present(value) { return value !== null && value !== undefined; }"
  },
  "name": "default",
  "stages": [
    {
      "args": [
        {
          "description": "Проверяемое значение",
          "name": "value"
        }
      ],
      "in_bindings": [],
      "name": "is_true",
      "source_code": "return value === true;"
    },
    {
      "args": [
        {
          "description": "Проверяемое значение",
          "name": "value"
        }
      ],
      "in_bindings": [],
      "name": "is_present",
      "source_code": "return is_present(value);"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "resource",
          "query": "zone"
        }
      ],
      "name": "is_in_zone",
      "source_code": "return Boolean(zone);"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "resource",
          "query": "zone.experiment"
        }
      ],
      "name": "is_in_zone_experiment",
      "source_code": "return Boolean(experiment);"
    },
    {
      "args": [
        {
          "description": "Название эксперимента",
          "name": "name"
        }
      ],
      "in_bindings": [],
      "name": "is_in_experiment3",
      "source_code": "return name in experiments3;"
    },
    {
      "args": [
        {
          "description": "Название тарифа",
          "name": "category"
        }
      ],
      "in_bindings": [
        {
          "domain": "resource",
          "query": "zone.experiment.rules"
        }
      ],
      "name": "has_rules",
      "source_code": "return rules && category in rules && rules[category];"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "input",
          "query": "layer_meta"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.smooth_surge.enable"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.smooth_surge.max_jump_up"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.smooth_surge.max_jump_down"
        }
      ],
      "name": "is_smoothing_active",
      "source_code": "return layer_meta && enable && max_jump_up !== undefined && max_jump_up !== null && max_jump_down !== undefined && max_jump_down !== null;"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "resource",
          "query": "config.surge_apply_bounds_to_linear_dependency_with_base_table{enabled}"
        }
      ],
      "name": "is_linear_dependency_with_base_table_bounds_enabled",
      "source_code": "return enabled === true;"
    },
    {
      "args": [
        {
          "description": "Название тарифа",
          "name": "category"
        }
      ],
      "in_bindings": [
        {
          "domain": "input",
          "query": "request.fixed_price_classes"
        },
        {
          "domain": "resource",
          "query": "config.surge_enable_antisurge{enabled_in_config}"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.antisurge_discount_enabled{enabled_in_experiment}"
        }
      ],
      "name": "is_antisurge_disabled",
      "source_code": "return enabled_in_config !== true || enabled_in_experiment !== true || (fixed_price_classes && Object.values(fixed_price_classes).indexOf(category) < 0);"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "resource",
          "query": "config.surge_enable_explicit_antisurge{enabled_in_config}"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.explicit_antisurge_enabled{enabled_in_experiment}"
        }
      ],
      "name": "is_explicit_antisurge_enabled",
      "source_code": "return enabled_in_config === true && enabled_in_experiment === true;"
    },
    {
      "args": [
        {
          "description": "Сглаженное значение сурджа",
          "name": "value"
        }
      ],
      "in_bindings": [
        {
          "domain": "resource",
          "query": "zone.experiment.explicit_antisurge_threshold{threshold}"
        }
      ],
      "name": "is_explicit_antisurge_satisfied",
      "source_code": "return threshold && value && value < threshold;"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "input",
          "query": "request.due"
        }
      ],
      "name": "is_not_due",
      "source_code": "return due === null || due === undefined;"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "resource",
          "query": "config.surge_enable_umlaas_statistics{enabled_in_config}"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.ml.action"
        }
      ],
      "name": "is_umlaas_statistics_needed",
      "source_code": "return action && (action !== \"ignore\") && enabled_in_config === true;"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "resource",
          "query": "config.surge_enable_surcharge{enabled_in_config}"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.surcharge_enabled{enabled_in_experiment}"
        }
      ],
      "name": "is_surcharge_enabled",
      "source_code": "return enabled_in_config === true && enabled_in_experiment === true;"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "resource",
          "query": "experiments3"
        }
      ],
      "name": "is_weighted_adjustment_experiment_enabled",
      "source_code": "return \"weighted_surge_adjustment\" in experiments3;"
    },
    {
      "conditions": [],
      "in_bindings": [
        {
          "domain": "input",
          "query": "required_categories.*{:category}"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.rules[category].surge_value{fixed_surge_value}"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.rules[category].reason{fixed_reason}"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.rules[category].time_rules"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.rules[category].linear_dependency_formula.enabled{linear_dependency_enabled}"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.balance"
        }
      ],
      "name": "initialize",
      "optional": false,
      "out_bindings": [
        {
          "alias": "class_info",
          "query": "classes[category]"
        }
      ],
      "source_code": "\n    if (linear_dependency_enabled) {\n        return {\n            class_info: {\n                name: category,\n                surge: {\n                    value: 1.0,\n                },\n                value_raw: 1.0,\n                calculation_meta: {\n                    reason: \"linear_dependency\",\n                },\n            },\n        };\n    }\n\n    if (fixed_surge_value) {\n        return {\n            class_info: {\n                name: category,\n                surge: {\n                    value: 1.0,\n                },\n                value_raw: fixed_surge_value,\n                calculation_meta: {\n                    reason: fixed_reason || \"no\",\n                },\n            },\n        };\n    }\n\n    if (time_rules) {\n        const now = new Date();\n        const hour_now = (now.getUTCHours() + 3) % 24; // Moscow +3\n        const mins_now = now.getMinutes();\n        for (let time_rule of time_rules) {\n            const hour_from = time_rule.time_from.hour;\n            const mins_from = time_rule.time_from.minute;\n            const hour_to = time_rule.time_to.hour;\n            const mins_to = time_rule.time_to.minute;\n\n            const gt_from = hour_now > hour_from || (hour_now == hour_from && mins_now >= mins_from);\n            const lt_to = hour_now < hour_to || (hour_now == hour_to && mins_now <= mins_to);\n\n            if (gt_from && lt_to) {\n                if (time_rule.surge_value) {\n                    return {\n                        class_info: {\n                            name: category,\n                            surge: {\n                                value: 1.0,\n                            },\n                            value_raw: time_rule.surge_value,\n                            calculation_meta: {\n                                reason: \"time\",\n                            },\n                        },\n                    };\n                } else if (balance) {\n                    return {\n                        class_info: {\n                            name: category,\n                            surge: {\n                                value: 1.0,\n                            },\n                            value_raw: 1.0,\n                            calculation_meta: {\n                                reason: \"pins_free\",\n                            },\n                        },\n                    };\n                } else {\n                    log.info(\"balance not active: no params\");\n                    break;\n                }\n            }\n        }\n    }\n\n    return {\n        class_info: {\n            name: category,\n            surge: {\n                value: 1.0,\n            },\n            value_raw: 1.0,\n            calculation_meta: {\n                reason: \"no\",\n            },\n        },\n    };\n"
    },
    {
      "args": [
        {
          "description": "Причина сурджа",
          "name": "reason"
        }
      ],
      "in_bindings": [],
      "name": "is_balance_equation",
      "source_code": "return reason === 'pins_free';"
    },
    {
      "args": [],
      "in_bindings": [
        {
          "domain": "output",
          "query": "classes"
        }
      ],
      "name": "is_balance_equation_needed",
      "source_code": "\n  for (let class_info of Object.values(classes)) {\n    if (class_info.calculation_meta.reason === 'pins_free') return true;\n  }\n  return false;\n"
    },
    {
      "args": [
        {
          "description": "Причина сурджа",
          "name": "reason"
        }
      ],
      "in_bindings": [],
      "name": "is_linear_dependency",
      "source_code": "return reason === 'linear_dependency';"
    },
    {
      "conditions": [
        {
          "args": [],
          "predicate": "is_balance_equation_needed",
          "type": "predicate"
        }
      ],
      "name": "group0",
      "stages": [
        {
          "conditions": [],
          "name": "group1",
          "stages": [
            {
              "conditions": [],
              "in_bindings": [
                {
                  "domain": "output",
                  "query": "classes"
                },
                {
                  "domain": "input",
                  "query": "request.point_a"
                },
                {
                  "domain": "input",
                  "query": "request.tariff_zone"
                },
                {
                  "domain": "input",
                  "query": "layer_meta"
                }
              ],
              "name": "fetch_drivers_info",
              "optional": false,
              "resources": [
                {
                  "field": "drivers_info",
                  "name": "count_by_categories"
                }
              ],
              "source_code": "\n    function map_object_to_array(object, fn, fn_if) {\n        let result = [];\n        for (let key in object) {\n            let item = object[key];\n            if (typeof fn_if !== 'function' || fn_if(item)) {\n                result.push(fn(item));\n            }\n        }\n        return result;\n    }\n\n    let request = {\n        allowed_classes: map_object_to_array(\n            classes,\n            info => info.name,\n            info => info.calculation_meta.reason === \"pins_free\" || info.name === base_class\n        ),\n        limit: 400,\n        max_distance: 2500,\n        point: point_a,\n    };\n\n    if (tariff_zone) {\n        request.zone_id = tariff_zone;\n    }\n\n    return {\n        drivers_info: {\n            layer_meta: layer_meta,\n            request: request,\n        }\n    };\n"
            },
            {
              "conditions": [],
              "in_bindings": [
                {
                  "domain": "output",
                  "query": "classes"
                },
                {
                  "domain": "input",
                  "query": "request.point_a"
                },
                {
                  "domain": "resource",
                  "query": "drivers_info.radius"
                },
                {
                  "domain": "input",
                  "query": "layer_meta"
                }
              ],
              "name": "fetch_pins_info",
              "optional": false,
              "resources": [
                {
                  "field": "pins_info",
                  "name": "pin_stats"
                }
              ],
              "source_code": "\n    function map_object_to_array(object, fn, fn_if) {\n        let result = [];\n        for (let key in object) {\n            let item = object[key];\n            if (typeof fn_if !== 'function' || fn_if(item)) {\n                result.push(fn(item));\n            }\n        }\n        return result;\n    }\n\n    return {\n        pins_info: {\n            layer_meta: layer_meta,\n            request: {\n                categories: map_object_to_array(\n                    classes,\n                    info => info.name,\n                    info => info.calculation_meta.reason === \"pins_free\"\n                ),\n                point: point_a,\n                radius: radius,\n                high_surge_b: [50, 70, 95, 98]\n            }\n        }\n    };\n"
            },
            {
              "conditions": [
                {
                  "args": [],
                  "predicate": "is_umlaas_statistics_needed",
                  "type": "predicate"
                }
              ],
              "in_bindings": [
                {
                  "domain": "input",
                  "query": "request.point_a"
                },
                {
                  "domain": "input",
                  "query": "request.user_id"
                },
                {
                  "domain": "input",
                  "query": "request.phone_id"
                },
                {
                  "domain": "input",
                  "query": "request.distance"
                },
                {
                  "domain": "input",
                  "query": "request.payment_type"
                },
                {
                  "domain": "input",
                  "query": "request.orders_complete"
                },
                {
                  "domain": "input",
                  "query": "request.point_b"
                },
                {
                  "domain": "input",
                  "query": "request.tariff_zone"
                },
                {
                  "domain": "input",
                  "query": "request.classes{categories}"
                },
                {
                  "domain": "resource",
                  "query": "drivers_info.radius"
                },
                {
                  "domain": "resource",
                  "query": "drivers_info.generic{drivers_by_category}"
                },
                {
                  "domain": "resource",
                  "query": "drivers_info.reposition{reposition_by_category}"
                },
                {
                  "domain": "input",
                  "query": "application_info{client}"
                },
                {
                  "domain": "resource",
                  "query": "pins_info.pins"
                },
                {
                  "domain": "resource",
                  "query": "pins_info.pins_with_b{pins_b}"
                },
                {
                  "domain": "resource",
                  "query": "pins_info.pins_with_order{pins_order}"
                },
                {
                  "domain": "resource",
                  "query": "pins_info.pins_with_driver{pins_driver}"
                },
                {
                  "domain": "resource",
                  "query": "pins_info.prev_pins"
                },
                {
                  "domain": "resource",
                  "query": "pins_info.values_by_category{pins_meta_by_category}"
                }
              ],
              "name": "fetch_surge_statistics",
              "optional": true,
              "resources": [
                {
                  "field": "surge_statistics_info",
                  "name": "surge_statistics"
                }
              ],
              "source_code": "\n  let req = {\n    point_a: point_a,\n    user_id: user_id,\n    phone_id: phone_id,\n    distance: distance,\n    payment_type: payment_type,\n    orders_complete: orders_complete,\n    point_b: point_b,\n    tariff_zone: tariff_zone,\n    radius: radius,\n    client: client,\n  }\n\n  Object.keys(req).forEach(key => {\n    if (req[key] === undefined) {\n      delete req[key];\n    }\n  })\n\n  if (req.user_id === undefined) {\n    req.user_id = \"\";\n  }\n\n  let by_category = {}\n  for (let category of categories) {\n    let drivers = drivers_by_category[category];\n    let cat_req = {\n      pins: pins,\n      pins_b: pins_b,\n      pins_order: pins_order,\n      prev_pins: prev_pins,\n      free: drivers.free,\n      free_chain: drivers.free_chain,\n      total: drivers.total\n    }\n    if (!Object.values(cat_req).every(is_present)) {\n      // Missing required field\n      continue;\n    }\n\n    if (reposition_by_category && reposition_by_category[category]) {\n      let reposition = reposition_by_category[category];\n      cat_req.reposition = {\n        free: reposition.free,\n        free_chain: reposition.free_chain,\n        total: reposition.total\n      }\n    }\n\n    if (pins_meta_by_category && pins_meta_by_category[category]) {\n      let meta = pins_meta_by_category[category];\n      cat_req.prev_eta = meta.estimated_waiting;\n      cat_req.prev_surge = meta.surge;\n      // These values not used by ML\n      cat_req.prev_free = 0;\n      cat_req.prev_chain = 0;\n      cat_req.prev_total = 0;\n    }\n\n    by_category[category] = cat_req;\n  }\n  req.by_category = by_category;\n  return {surge_statistics_info: req};\n"
            },
            {
              "conditions": [
                {
                  "args": [
                    {
                      "name": "value",
                      "value": "counts"
                    }
                  ],
                  "predicate": "is_present",
                  "type": "predicate"
                },
                {
                  "args": [
                    {
                      "name": "reason",
                      "value": "reason"
                    }
                  ],
                  "predicate": "is_balance_equation",
                  "type": "predicate"
                }
              ],
              "in_bindings": [
                {
                  "domain": "output",
                  "query": "classes.*{category:}.calculation_meta.reason"
                },
                {
                  "domain": "resource",
                  "query": "config.surge_latest_pins_delta_time"
                },
                {
                  "domain": "resource",
                  "query": "dynamic_config.sample_dynamic_config"
                },
                {
                  "domain": "resource",
                  "query": "zone.base_class"
                },
                {
                  "domain": "resource",
                  "query": "zone.experiment.rules[category].surge_rules"
                },
                {
                  "domain": "resource",
                  "query": "zone.experiment.balance.min_pins"
                },
                {
                  "domain": "resource",
                  "query": "zone.experiment.balance.min_total"
                },
                {
                  "domain": "resource",
                  "query": "zone.experiment.balance.f_init"
                },
                {
                  "domain": "resource",
                  "query": "zone.experiment.balance.f_equal"
                },
                {
                  "domain": "resource",
                  "query": "zone.experiment.balance.f_delta_left"
                },
                {
                  "domain": "resource",
                  "query": "zone.experiment.balance.f_delta_right"
                },
                {
                  "domain": "resource",
                  "query": "zone.experiment.balance.add_free"
                },
                {
                  "domain": "resource",
                  "query": "zone.experiment.balance.add_total"
                },
                {
                  "domain": "resource",
                  "query": "zone.experiment.balance.fs_intercept"
                },
                {
                  "domain": "resource",
                  "query": "zone.experiment.balance.fs_coef_chain"
                },
                {
                  "domain": "resource",
                  "query": "zone.experiment.balance.fs_coef_total"
                },
                {
                  "domain": "resource",
                  "query": "zone.experiment.balance.chain_factor"
                },
                {
                  "domain": "resource",
                  "query": "zone.experiment.balance.reposition_discount"
                },
                {
                  "domain": "resource",
                  "query": "zone.experiment.balance.utilization_for_non_econom{utilization_for_non_base}"
                },
                {
                  "domain": "resource",
                  "query": "zone.experiment.balance.table_coef_ps"
                },
                {
                  "domain": "resource",
                  "query": "drivers_info.radius"
                },
                {
                  "domain": "resource",
                  "query": "drivers_info.generic[category]{counts}"
                },
                {
                  "domain": "resource",
                  "query": "drivers_info.reposition[category]{reposition_counts}"
                },
                {
                  "domain": "resource",
                  "query": "drivers_info.generic[base_class]{base_class_counts}"
                },
                {
                  "domain": "resource",
                  "query": "drivers_info.reposition[base_class]{reposition_base_class_counts}"
                },
                {
                  "domain": "resource",
                  "query": "pins_info.pins"
                },
                {
                  "domain": "resource",
                  "query": "pins_info.pins_with_b"
                },
                {
                  "domain": "resource",
                  "query": "pins_info.pins_with_order"
                },
                {
                  "domain": "resource",
                  "query": "pins_info.pins_with_driver"
                },
                {
                  "domain": "resource",
                  "query": "pins_info.prev_pins"
                },
                {
                  "domain": "resource",
                  "query": "pins_info.values_by_category{pins_meta_by_category}"
                },
                {
                  "domain": "resource",
                  "query": "surge_statistics_info.by_category[category]{surge_statistics}"
                }
              ],
              "name": "balance_equation",
              "optional": false,
              "out_bindings": [
                {
                  "alias": "calculation_meta",
                  "query": "classes[category].calculation_meta"
                },
                {
                  "alias": "value_raw",
                  "query": "classes[category].value_raw"
                }
              ],
              "source_code": "\n    function require(value, description) {\n        if (!is_present(value)) {\n            throw 'no ' + description;\n        }\n    }\n\n    function map_object(object, fn, fn_if) {\n        let result = {}\n        for (let key in object) {\n            let item = object[key];\n            if (typeof fn_if !== 'function' || fn_if(item)) {\n                result[key] = (fn(item));\n            }\n        }\n        return result;\n    }\n\n    function in_epsilon_neighborhood_of_zero(value) {\n        return Math.abs(value) <= Number.EPSILON;\n    }\n\n    function get_category_specific_pin_meta(field_name, is_non_base) {\n        if (is_non_base) {\n            let result = {};\n            if (category in pins_meta_by_category) {\n                let meta = pins_meta_by_category[category];\n                if (field_name in meta) {\n                    result[category] = meta[field_name];\n                }\n            }\n            return result;\n        } else {\n            return map_object(\n                pins_meta_by_category,\n                meta => meta[field_name],\n                meta => field_name in meta,\n            );\n        }\n    }\n\n    chain_factor = chain_factor || 1.0;\n\n    require(category, 'category name');\n    require(pins, 'pins info');\n    require(counts, category + 'counts');\n    require(base_class_counts, 'base class counts');\n\n    const kDefaultSurgeValue = 1.0;\n    const kReasonNo = 'no';\n    const kReasonPinsFree = 'pins_free';\n    const kMessageNotActive = 'balance equation is not active: ';\n\n    const is_non_base = category !== base_class;\n    const is_utilization = utilization_for_non_base && is_non_base;\n\n    const selected_counts = is_utilization ? counts : base_class_counts;\n    const selected_reposition_counts = is_utilization ? reposition_counts : reposition_base_class_counts;\n\n    let free = selected_counts.free;\n    let free_chain = selected_counts.free_chain;\n    let on_order = selected_counts.on_order;  // unused\n    let total = selected_counts.total;\n\n    let balance_log_info = {\n        deviation_from_target_abs: 2.22,\n        ps_shift_past_raw: 3.33\n    }\n\n    if (is_non_base) {\n        balance_log_info = null;\n    }\n\n    // Доля свободных машин\n    function get_ratio_balance() {\n        let corrected_total = total + add_total;\n        if (is_present(reposition_discount) && is_present(selected_reposition_counts)) {\n            // https://st.yandex-team.ru/EFFICIENCYDEV-20\n            corrected_total += reposition_discount * selected_reposition_counts.total;\n        }\n        if (in_epsilon_neighborhood_of_zero(corrected_total)) {\n            return 0.0;\n        }\n        let corrected_free = free + chain_factor * free_chain + add_free;\n        if (is_present(reposition_discount) && is_present(selected_reposition_counts)) {\n            // https://st.yandex-team.ru/EFFICIENCYDEV-20\n            corrected_free += reposition_discount *\n                (selected_reposition_counts.free + chain_factor * selected_reposition_counts.free_chain);\n        }\n        return corrected_free / corrected_total;\n    }\n\n    function make_result(\n        reason = kReasonNo,\n        value_raw = kDefaultSurgeValue,\n        ps = null,\n        f_derivative = null,\n    ) {\n        const cat_meta = pins_meta_by_category[category] || {};\n\n        let pins_meta = {\n            pins_b: pins_with_b,\n            pins_order: pins_with_order,\n            pins_driver: pins_with_driver,\n            prev_pins: prev_pins,\n            eta_in_tariff: cat_meta.estimated_waiting || 0.0,\n            surge_in_tariff: cat_meta.surge || 0.0,\n            pins_order_in_tariff: cat_meta.pins_order_in_tariff || 0,\n            pins_driver_in_tariff: cat_meta.pins_driver_in_tariff || 0,\n        }\n        if (is_present(cat_meta.cost)) {\n            pins_meta.cost = cat_meta.cost;\n        }\n        if (is_present(cat_meta.surge_b)) {\n            pins_meta.surge_b_in_tariff = cat_meta.surge_b;\n        }\n        if (is_present(cat_meta.trip)) {\n            pins_meta.distance = cat_meta.trip.distance;\n            pins_meta.time = cat_meta.trip.time;\n        }\n        if (is_present(cat_meta.pins_surge_b_percentiles)) {\n            pins_meta.pins_surge_b_percentiles = cat_meta.pins_surge_b_percentiles;\n        }\n\n        let calculation_meta = {\n            counts: {\n                free: counts.free,\n                free_chain: counts.free_chain,\n                total: counts.total,\n                pins: pins,\n                radius: radius,\n            },\n            reason: reason,\n            pins_meta: pins_meta,\n        };\n\n        if (is_present(reposition_counts)) {\n            calculation_meta.reposition = {\n                free: reposition_counts.free,\n                free_chain: reposition_counts.free_chain,\n                total: reposition_counts.total,\n            };\n        }\n\n        if (is_present(ps)) {\n            calculation_meta.ps = ps;\n        }\n\n        if (is_present(f_derivative)) {\n            calculation_meta.f_derivative = f_derivative;\n        }\n\n        if (is_present(balance_log_info)) {\n            calculation_meta.deviation_from_target_abs =\n                balance_log_info.deviation_from_target_abs;\n            calculation_meta.ps_shift_past_raw =\n                balance_log_info.ps_shift_past_raw;\n        }\n\n        if (is_present(surge_statistics)) {\n            if (calculation_meta.extra === undefined) {\n                calculation_meta.extra = {};\n            }\n            calculation_meta.extra.surge_statistics = surge_statistics.results;\n        }\n\n        if (is_present(sample_dynamic_config)) {\n            if (calculation_meta.extra === undefined) {\n                calculation_meta.extra = {};\n            }\n            calculation_meta.extra.sample_dynamic_config = sample_dynamic_config;\n        }\n\n        return {\n            value_raw: value_raw,\n            calculation_meta: calculation_meta,\n        };\n    }\n\n    function make_result_by_ratio(ratio) {\n        let value_raw = kDefaultSurgeValue;\n        for (let rule of surge_rules) {\n            if (rule.min_coeff <= ratio) {\n                value_raw = rule.surge_value;\n            } else {\n                break;\n            }\n        }\n        return make_result(kReasonPinsFree, value_raw);\n    }\n\n    function make_result_by_ps(ps, f_derivative) {\n        let reason = kReasonNo;\n        let value_raw = kDefaultSurgeValue;\n\n        let ps_deviation = undefined;\n        for (let table_coef_item of table_coef_ps) {\n            let current_ps_deviation = Math.abs(ps - table_coef_item.ps);\n            if (!is_present(ps_deviation) || current_ps_deviation < ps_deviation) {\n                reason = kReasonPinsFree;\n                value_raw = table_coef_item.coeff;\n                ps_deviation = current_ps_deviation;\n            }\n        }\n        return make_result(reason, value_raw, ps, f_derivative);\n    }\n\n    const ratio = get_ratio_balance();\n    // Утилизация считается по тому же ратио, но по правилам для класса\n    // https://st.yandex-team.ru/TAXIBACKEND-6549\n    if (is_utilization) {\n        log.info(\n            'balance enabled but utilization formula is active for ' + category\n        );\n        if (total < min_total) {\n            log.info(\n                kMessageNotActive + ': total{' + total +\n                '} is less than min_total{' + min_total + '}'\n            );\n            return make_result();\n        }\n        return make_result_by_ratio(ratio);\n    }\n    // Порог, при котором не начинаем считать производную\n    if (ratio >= f_init) {\n        log.info(\n            kMessageNotActive + ': ratio{' + ratio + '} >= f_init{' +\n            f_init + '}');\n        return make_result();\n    }\n    if (in_epsilon_neighborhood_of_zero(pins)) {\n        log.info(kMessageNotActive + ': zero pins (or too close to zero)');\n        return make_result();\n    }\n    const window_minutes = surge_latest_pins_delta_time / 60;\n    // Формула уравнения баланса https://st.yandex-team.ru/TAXIBACKEND-7194:\n    // где  новая скорость = (fs_intercept + fs_coef_chain * free_chain +\n    // fs_coef_total * total) / window\n    //\n    // f_derivative * total = (fs_intercept +\n    // fs_coef_chain * free_chain + fs_coef_total * total) / window - p(s) * pins\n    // / window\n    //\n    // =>\n    //\n    // f_derivative * total * window = (fs_intercept + fs_coef_chain * free_chain\n    // + fs_coef_total * total) - p(s) * pins\n    //\n    // p(s) * pins = (fs_intercept +\n    // fs_coef_chain * free_chain + fs_coef_total * total)\n    // - f_derivative * total * window\n    //\n    // p(s) = (fs_intercept + fs_coef_chain * free_chain + fs_coef_total *\n    // total - f_derivative * total * window) / pins\n\n    let f_delta =\n        ratio < f_equal ? f_delta_left : f_delta_right;\n    // UPD: https://st.yandex-team.ru/TAXIBACKEND-6474\n    // ratio' = f_delta * (f_equal - ratio(t))\n    let f_derivative = f_delta * (f_equal - ratio);\n    if (is_present(reposition_discount) &&\n        is_present(selected_reposition_counts)\n    ) {\n        // https://st.yandex-team.ru/EFFICIENCYDEV-20\n        total += reposition_discount * selected_reposition_counts.total;\n        free_chain += reposition_discount * selected_reposition_counts.free_chain;\n    }\n\n    let ps = (\n        fs_intercept + fs_coef_chain * free_chain + total * fs_coef_total -\n        f_derivative * total * window_minutes\n    ) / pins;\n\n    return make_result_by_ps(ps, f_derivative);\n"
            }
          ]
        }
      ]
    },
    {
      "conditions": [
        {
          "args": [],
          "predicate": "is_smoothing_active",
          "type": "predicate"
        }
      ],
      "name": "group2",
      "stages": [
        {
          "conditions": [],
          "in_bindings": [
            {
              "domain": "input",
              "query": "request.point_a"
            },
            {
              "domain": "output",
              "query": "classes"
            },
            {
              "domain": "input",
              "query": "layer_meta"
            }
          ],
          "name": "fetch_point_a_smoothing_info",
          "optional": false,
          "resources": [
            {
              "field": "point_a_smoothing_info",
              "name": "surge_value_map"
            }
          ],
          "source_code": "\n    function map_object_to_array(object, fn, fn_if) {\n        let result = [];\n        for (let value of Object.values(object)) {\n            if (typeof fn_if !== 'function' || fn_if(value)) {\n                result.push(fn(value));\n            }\n        }\n        return result;\n    }\n\n    return {\n        point_a_smoothing_info: {\n            point: point_a,\n            layer_meta: layer_meta,\n            categories: map_object_to_array(classes, info => info.name),\n        }\n    }\n"
        },
        {
          "conditions": [
            {
              "args": [
                {
                  "name": "value",
                  "value": "point_b"
                }
              ],
              "predicate": "is_present",
              "type": "predicate"
            }
          ],
          "in_bindings": [
            {
              "domain": "input",
              "query": "request.point_b"
            },
            {
              "domain": "output",
              "query": "classes"
            },
            {
              "domain": "input",
              "query": "layer_meta"
            }
          ],
          "name": "fetch_point_b_smoothing_info",
          "optional": false,
          "resources": [
            {
              "field": "point_b_smoothing_info",
              "name": "surge_value_map"
            }
          ],
          "source_code": "\n    function map_object_to_array(object, fn, fn_if) {\n        let result = [];\n        for (let value of Object.values(object)) {\n            if (typeof fn_if !== 'function' || fn_if(value)) {\n                result.push(fn(value));\n            }\n        }\n        return result;\n    }\n\n    return {\n        point_b_smoothing_info: {\n            point: point_b,\n            layer_meta: layer_meta,\n            categories: map_object_to_array(classes, info => info.name),\n        }\n    }\n"
        },
        {
          "conditions": [],
          "in_bindings": [
            {
              "domain": "input",
              "query": "request.point_b"
            },
            {
              "domain": "output",
              "query": "classes.*{category:}.value_raw"
            },
            {
              "domain": "resource",
              "query": "zone.experiment.smooth_surge.max_jump_up"
            },
            {
              "domain": "resource",
              "query": "zone.experiment.smooth_surge.max_jump_down"
            },
            {
              "domain": "resource",
              "query": "zone.experiment.smooth_surge.default_smooth_surge{default_smooth_surge_a}"
            },
            {
              "domain": "resource",
              "query": "zone.experiment.smooth_surge.default_smooth_surge_b"
            },
            {
              "domain": "resource",
              "query": "point_a_smoothing_info[category]{value_smooth_a}"
            },
            {
              "domain": "resource",
              "query": "point_b_smoothing_info[category]{value_smooth_b}"
            }
          ],
          "name": "smooth_surge",
          "optional": false,
          "out_bindings": [
            {
              "alias": "smooth_a",
              "query": "classes[category].calculation_meta.smooth.point_a"
            },
            {
              "alias": "smooth_b",
              "query": "classes[category].calculation_meta.smooth.point_b"
            },
            {
              "alias": "value",
              "query": "classes[category].surge.value"
            }
          ],
          "source_code": "\n    const kDefaultSurgeValue = 1.0;\n\n    let result = {\n        smooth_a: {\n            value: value_smooth_a || default_smooth_surge_a || kDefaultSurgeValue,\n            is_default: !value_smooth_a,\n        },\n        smooth_b: point_b ? {\n            value: value_smooth_b || default_smooth_surge_b || kDefaultSurgeValue,\n            is_default: !value_smooth_b\n        } : null\n    };\n\n    result.value = Math.max(\n        Math.min(value_raw, result.smooth_a.value + max_jump_up),\n        result.smooth_a.value - max_jump_down\n    );\n\n    return result;\n"
        }
      ]
    },
    {
      "conditions": [
        {
          "stage_name": "smooth_surge",
          "stage_statuses": [
            "omitted"
          ],
          "type": "stage_status"
        }
      ],
      "in_bindings": [
        {
          "domain": "input",
          "query": "request.point_b"
        },
        {
          "domain": "resource",
          "query": "zone.id{zone_id}"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.smooth_surge.default_smooth_surge{default_smooth_surge_a}"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.smooth_surge.default_smooth_surge_b"
        },
        {
          "domain": "resource",
          "query": "config.surge_use_default_surge_if_no_smoothing[zone_id]{use_default_surge_if_no_smoothing}"
        },
        {
          "domain": "output",
          "query": "classes.*{category:}.value_raw"
        }
      ],
      "name": "set_default_smooth",
      "optional": false,
      "out_bindings": [
        {
          "alias": "smooth_a",
          "query": "classes[category].calculation_meta.smooth.point_a"
        },
        {
          "alias": "smooth_b",
          "query": "classes[category].calculation_meta.smooth.point_b"
        },
        {
          "alias": "value",
          "query": "classes[category].surge.value"
        }
      ],
      "source_code": "\n    const kDefaultSurgeValue = 1.0;\n    const default_a = default_smooth_surge_a || kDefaultSurgeValue;\n    const default_b = default_smooth_surge_b || kDefaultSurgeValue;\n\n    return {\n        smooth_a: {\n            is_default: true,\n            value: default_a,\n        },\n        smooth_b: point_b ? {\n            is_default: true,\n            value: default_b,\n        } : null,\n        value: use_default_surge_if_no_smoothing ? default_a : value_raw,\n    };\n"
    },
    {
      "conditions": [
        {
          "args": [
            {
              "name": "category",
              "value": "category"
            }
          ],
          "predicate": "has_rules",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "domain": "output",
          "query": "classes.*{category:}.surge.value"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.rules[category].surge_min_bound"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.rules[category].surge_max_bound"
        }
      ],
      "name": "bound_coeffs_1",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "query": "classes[category].surge.value"
        }
      ],
      "source_code": "\n    function value_or_number(value, default_value) {\n        return typeof value === 'number' ? value : default_value;\n    }\n\n    let min_surge = value_or_number(surge_min_bound, 1.0);\n    let max_surge = value_or_number(surge_max_bound, 4.0);\n\n    return {\n        value: Math.max(Math.min(value, max_surge), min_surge)\n    };\n"
    },
    {
      "conditions": [
        {
          "args": [],
          "predicate": "is_weighted_adjustment_experiment_enabled",
          "type": "predicate"
        },
        {
          "args": [],
          "predicate": "is_in_zone_experiment",
          "type": "predicate"
        },
        {
          "args": [
            {
              "name": "value",
              "value": "enabled"
            }
          ],
          "predicate": "is_true",
          "type": "predicate"
        },
        {
          "args": [
            {
              "name": "value",
              "value": "dep_total"
            }
          ],
          "predicate": "is_present",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "domain": "resource",
          "query": "zone.base_class"
        },
        {
          "domain": "output",
          "query": "classes[base_class].surge.value{base_value}"
        },
        {
          "domain": "output",
          "query": "classes.*{category:}"
        },
        {
          "domain": "output",
          "query": "classes[category].value_raw{dep_value_raw}"
        },
        {
          "domain": "output",
          "query": "classes[category].calculation_meta.counts.total{dep_total}"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.rules[category].weighted_surge_adjustment.enabled"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.rules[category].weighted_surge_adjustment.settings"
        }
      ],
      "name": "weighted_adjustment",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "query": "classes[category].surge.value"
        }
      ],
      "source_code": "\n    function require_setting(name) {\n        if (!(name in settings)) {\n            throw name + ' is not present in settings';\n        }\n    }\n\n    require_setting('min_adjustment_coeff');\n    require_setting('max_adjustment_coeff');\n\n    let weight_function = (x) => 1 / (1 + x);\n    let bound_weight = (x, l, r) => l + (r - l) * weight_function(x);\n    let adjusted_surge = (raw, coeff, base) => raw + coeff * (base - raw);\n\n    return {\n        value: adjusted_surge(\n            dep_value_raw,\n            bound_weight(\n                dep_total,\n                settings.min_adjustment_coeff,\n                settings.max_adjustment_coeff),\n            base_value),\n    };\n"
    },
    {
      "conditions": [
        {
          "args": [
            {
              "name": "category",
              "value": "category"
            }
          ],
          "predicate": "has_rules",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "domain": "output",
          "query": "classes.*{category:}.surge.value"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.rules[category].surge_min_bound"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.rules[category].surge_max_bound"
        }
      ],
      "name": "bound_coeffs_2",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "query": "classes[category].surge.value"
        }
      ],
      "source_code": "\n    function value_or_number(value, default_value) {\n        return typeof value === 'number' ? value : default_value;\n    }\n\n    let min_surge = value_or_number(surge_min_bound, 1.0);\n    let max_surge = value_or_number(surge_max_bound, 4.0);\n\n    return {\n        value: Math.max(Math.min(value, max_surge), min_surge)\n    };\n"
    },
    {
      "conditions": [
        {
          "args": [
            {
              "name": "value",
              "value": "restriction"
            }
          ],
          "predicate": "is_present",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "domain": "output",
          "query": "classes.*{category:}.surge.value"
        },
        {
          "domain": "resource",
          "query": "dynamic_config.surge_corp_limit[category]{restriction}"
        }
      ],
      "name": "bound_by_corp_limit",
      "out_bindings": [
        {
          "alias": "meta",
          "query": "classes[category].calculation_meta.extra.corp_bound"
        },
        {
          "alias": "value",
          "query": "classes[category].surge.value"
        }
      ],
      "source_code": "\n  let result_value = value\n  let restriction_meta = {}\n  if (typeof(restriction.min) === \"number\") {\n    result_value = Math.max(restriction.min, value)\n    restriction_meta.min = restriction.min;\n  }\n  if (typeof(restriction.max) === \"number\") {\n    result_value = Math.min(restriction.max, value)\n    restriction_meta.max = restriction.max;\n  }\n  return {\n    value: result_value,\n    meta: restriction_meta,\n  }\n"
    },
    {
      "conditions": [
        {
          "args": [
            {
              "name": "reason",
              "value": "reason"
            }
          ],
          "predicate": "is_linear_dependency",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "domain": "output",
          "query": "classes.*{category:}.calculation_meta.reason"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.rules[category].linear_dependency_formula.from_class"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.rules[category].linear_dependency_formula.surge_linear_coeff"
        },
        {
          "domain": "output",
          "query": "classes[from_class].value_raw{from_class_value_raw}"
        },
        {
          "domain": "output",
          "query": "classes[from_class].surge.value{from_class_value}"
        },
        {
          "domain": "output",
          "query": "classes[from_class].calculation_meta.smooth{from_class_smooth}"
        }
      ],
      "name": "linear_dependency",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value_raw",
          "query": "classes[category].value_raw"
        },
        {
          "alias": "value",
          "query": "classes[category].surge.value"
        },
        {
          "alias": "smooth",
          "query": "classes[category].calculation_meta.smooth"
        }
      ],
      "source_code": "\n    function require(value, description) {\n        if (!is_present(value)) {\n            throw 'no ' + description;\n        }\n    }\n\n    const kDefaultSurgeValue = 1.0;\n\n    require(category, \"category\");\n    require(from_class, \"from_class\");\n    require(surge_linear_coeff, \"linear_coeff\");\n    require(from_class_value_raw, \"from_class_value_raw\");\n    require(from_class_value, \"from_class_value\");\n    require(from_class_smooth, \"from_class_smooth\");\n\n    if (category === from_class) {\n        throw \"Impossible to apply linear dependency from itself\";\n    }\n\n    return {\n        value_raw: from_class_value_raw,\n        value: kDefaultSurgeValue + surge_linear_coeff * (from_class_value - kDefaultSurgeValue),\n        smooth: from_class_smooth,\n    };\n"
    },
    {
      "conditions": [
        {
          "args": [],
          "predicate": "is_linear_dependency_with_base_table_bounds_enabled",
          "type": "predicate"
        },
        {
          "args": [],
          "predicate": "is_in_zone_experiment",
          "type": "predicate"
        },
        {
          "args": [
            {
              "name": "value",
              "value": "use_base_class_table"
            }
          ],
          "predicate": "is_true",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "domain": "output",
          "query": "classes.*{category:}.surge.value"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.rules[category].linear_dependency_formula.use_base_class_table"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.rules[category].surge_min_bound"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.rules[category].surge_max_bound"
        }
      ],
      "name": "linear_dependency_with_base_table_bound_coeffs",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "query": "classes[category].surge.value"
        }
      ],
      "source_code": "\n    return {value: Math.max(Math.min(value, surge_max_bound), surge_min_bound)};\n"
    },
    {
      "conditions": [
        {
          "args": [
            {
              "name": "category",
              "value": "category"
            }
          ],
          "predicate": "is_antisurge_disabled",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "domain": "output",
          "query": "classes.*{category:}.surge.value"
        }
      ],
      "name": "antisurge_bound_coeffs",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "query": "classes[category].surge.value"
        }
      ],
      "source_code": "\n    const kDefaultSurgeValue = 1.0;\n    return {value: Math.max(value, kDefaultSurgeValue)};\n"
    },
    {
      "conditions": [
        {
          "args": [],
          "predicate": "is_surcharge_enabled",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "domain": "resource",
          "query": "zone.base_class"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.rules"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.balance.table_coef_ps"
        },
        {
          "domain": "output",
          "query": "classes.*{category:}.surge.value"
        }
      ],
      "name": "fill_surcharge",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "query": "classes[category].surge.value"
        },
        {
          "alias": "surcharge",
          "query": "classes[category].surge.surcharge"
        }
      ],
      "source_code": "\n    const kDefaultSurge = 1.0;\n    const kDefaultSurcharge = {\n        alpha: 1.0,\n        beta: 0.0,\n        value: 0.0,\n    };\n\n    Object.freeze(kDefaultSurcharge);\n\n    function is_number(value) {\n        return typeof value === 'number';\n    }\n\n    function find_closest(iterable, get_deviation) {\n        let selected_item = undefined;\n        let deviation = undefined;\n        for (let item of iterable) {\n            let current_deviation = Math.abs(get_deviation(item));\n            if (!is_present(deviation) || current_deviation < deviation) {\n                selected_item = item;\n                deviation = current_deviation;\n            }\n        }\n        return selected_item;\n    }\n\n    let seen_categories = new Set();\n\n    function get_surcharge_and_surge(current_category, recursive) {\n        seen_categories.add(current_category);\n\n        if (current_category === base_class) {\n            if (is_present(table_coef_ps)) {\n                let selected_table_coef_item = find_closest(table_coef_ps, item => item.coeff - value);\n                if (selected_table_coef_item) {\n                    return {\n                        value: selected_table_coef_item.coeff,\n                        surcharge: {\n                            alpha: selected_table_coef_item.alpha,\n                            beta: selected_table_coef_item.beta,\n                            value: selected_table_coef_item.surcharge,\n                        }\n                    };\n                }\n            }\n        } else {\n            let rule = rules[current_category];\n            if (rule) {\n                if (recursive) {\n                    let linear_dependency = rule.linear_dependency_formula;\n                    if (linear_dependency && linear_dependency.use_base_class_table) {\n                        // https://st.yandex-team.ru/EFFICIENCYDEV-3719\n                        if (linear_dependency.from_class !== base_class || value >= kDefaultSurge) {\n                            if (seen_categories.has(linear_dependency.from_class)) {\n                                log.error(\"cyclic linear dependency: rerunning with disabled recursive table lookup\");\n                                // degradation: get first seen category and\n                                // rerun function with recursive table lookup disabled\n                                return get_surcharge_and_surge(seen_categories.values().next().value, /*recursive=*/false);\n                            }\n                            return get_surcharge_and_surge(linear_dependency.from_class, recursive);\n                        }\n                    }\n                }\n\n                let selected_surge_rules_item = find_closest(rule.surge_rules, item => item.surge_value - value);\n                if (selected_surge_rules_item) {\n                    return {\n                        value: selected_surge_rules_item.surge_value,\n                        surcharge: {\n                            alpha: selected_surge_rules_item.alpha,\n                            beta: selected_surge_rules_item.beta,\n                            value: selected_surge_rules_item.surcharge,\n                        }\n                    };\n                }\n            }\n        }\n\n        return { value: value, surcharge: kDefaultSurcharge };\n    }\n\n    let result = get_surcharge_and_surge(category, /*recursive=*/true);\n\n    if (!is_number(result.value)) {\n        log.error('no surge value! default surcharge will be used');\n        return { value: value, surcharge: kDefaultSurcharge };\n    }\n\n    let surcharge_coeffs = Object.values(result.surcharge);\n\n    if (!surcharge_coeffs.some(is_number)) {\n        // no surcharge params at all - use default but keep value from table\n        result.surcharge = kDefaultSurcharge;\n    } else if (!surcharge_coeffs.every(is_number)) {\n        // incomplete surcharge params - considered ill formed - discard table\n        log.warning('inconsistent surcharge params! default surcharge will be used');\n        return { value: value, surcharge: kDefaultSurcharge };\n    }\n\n    return result;\n"
    },
    {
      "conditions": [],
      "in_bindings": [
        {
          "domain": "resource",
          "query": "config.surge_coefficient_precision{precision}"
        },
        {
          "domain": "output",
          "query": "classes.*{category:}.surge.value"
        }
      ],
      "name": "round_coeffs",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "query": "classes[category].surge.value"
        }
      ],
      "source_code": "\n    const factor = Math.pow(10, precision);\n    return {value: Math.round(value * factor) / factor};\n"
    },
    {
      "conditions": [
        {
          "args": [],
          "predicate": "is_not_due",
          "type": "predicate"
        },
        {
          "args": [],
          "predicate": "is_explicit_antisurge_enabled",
          "type": "predicate"
        },
        {
          "args": [
            {
              "name": "value",
              "value": "value"
            }
          ],
          "predicate": "is_explicit_antisurge_satisfied",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "domain": "resource",
          "query": "zone.experiment.explicit_antisurge_threshold{threshold}"
        },
        {
          "domain": "resource",
          "query": "zone.base_class"
        },
        {
          "domain": "output",
          "query": "classes[base_class].surge.value"
        },
        {
          "domain": "output",
          "query": "classes[base_class].surge.surcharge"
        },
        {
          "domain": "output",
          "query": "classes[base_class].calculation_meta.smooth.point_b.is_default{point_b_smooth_is_default}"
        }
      ],
      "name": "segregate_explicit_antisurge",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "query": "classes[base_class].surge.value"
        },
        {
          "alias": "surcharge",
          "query": "classes[base_class].surge.surcharge"
        },
        {
          "alias": "explicit_antisurge",
          "query": "classes[base_class].explicit_antisurge"
        }
      ],
      "source_code": "\n    const has_actual_point_b_surge = point_b_smooth_is_default === false;\n\n    function copy_object(object) {\n        return Object.assign({}, object);\n    }\n\n    let result = {\n        value: value,\n        surcharge: surcharge,\n        explicit_antisurge: null,\n    };\n\n    if (has_actual_point_b_surge) {\n        result.explicit_antisurge = {\n            value: value,\n            // FIXME: surcharge object should be explicitly copied because\n            //  its copying and changing is done in single stage.\n            //  Otherwise out bindings order should be respected:\n            //  first - copy, second - change\n            surcharge: surcharge ? copy_object(surcharge) : null,\n        };\n    } else {\n        log.info(\"Explicit antisurge: hidden only - no actual point b surge\");\n    }\n\n    result.value = threshold;\n    result.surcharge = null;\n\n    return result;\n"
    },
    {
      "conditions": [
        {
          "args": [],
          "predicate": "is_surcharge_enabled",
          "type": "predicate"
        }
      ],
      "in_bindings": [
        {
          "domain": "resource",
          "query": "zone.base_class"
        },
        {
          "domain": "resource",
          "query": "zone.base_class{category}"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.rules"
        },
        {
          "domain": "resource",
          "query": "zone.experiment.balance.table_coef_ps"
        },
        {
          "domain": "output",
          "query": "classes[category].surge.value"
        }
      ],
      "name": "fill_base_class_surcharge",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "query": "classes[category].surge.value"
        },
        {
          "alias": "surcharge",
          "query": "classes[category].surge.surcharge"
        }
      ],
      "source_code": "\n    const kDefaultSurge = 1.0;\n    const kDefaultSurcharge = {\n        alpha: 1.0,\n        beta: 0.0,\n        value: 0.0,\n    };\n\n    Object.freeze(kDefaultSurcharge);\n\n    function is_number(value) {\n        return typeof value === 'number';\n    }\n\n    function find_closest(iterable, get_deviation) {\n        let selected_item = undefined;\n        let deviation = undefined;\n        for (let item of iterable) {\n            let current_deviation = Math.abs(get_deviation(item));\n            if (!is_present(deviation) || current_deviation < deviation) {\n                selected_item = item;\n                deviation = current_deviation;\n            }\n        }\n        return selected_item;\n    }\n\n    let seen_categories = new Set();\n\n    function get_surcharge_and_surge(current_category, recursive) {\n        seen_categories.add(current_category);\n\n        if (current_category === base_class) {\n            if (is_present(table_coef_ps)) {\n                let selected_table_coef_item = find_closest(table_coef_ps, item => item.coeff - value);\n                if (selected_table_coef_item) {\n                    return {\n                        value: selected_table_coef_item.coeff,\n                        surcharge: {\n                            alpha: selected_table_coef_item.alpha,\n                            beta: selected_table_coef_item.beta,\n                            value: selected_table_coef_item.surcharge,\n                        }\n                    };\n                }\n            }\n        } else {\n            let rule = rules[current_category];\n            if (rule) {\n                if (recursive) {\n                    let linear_dependency = rule.linear_dependency_formula;\n                    if (linear_dependency && linear_dependency.use_base_class_table) {\n                        // https://st.yandex-team.ru/EFFICIENCYDEV-3719\n                        if (linear_dependency.from_class !== base_class || value >= kDefaultSurge) {\n                            if (seen_categories.has(linear_dependency.from_class)) {\n                                log.error(\"cyclic linear dependency: rerunning with disabled recursive table lookup\");\n                                // degradation: get first seen category and\n                                // rerun function with recursive table lookup disabled\n                                return get_surcharge_and_surge(seen_categories.values().next().value, /*recursive=*/false);\n                            }\n                            return get_surcharge_and_surge(linear_dependency.from_class, recursive);\n                        }\n                    }\n                }\n\n                let selected_surge_rules_item = find_closest(rule.surge_rules, item => item.surge_value - value);\n                if (selected_surge_rules_item) {\n                    return {\n                        value: selected_surge_rules_item.surge_value,\n                        surcharge: {\n                            alpha: selected_surge_rules_item.alpha,\n                            beta: selected_surge_rules_item.beta,\n                            value: selected_surge_rules_item.surcharge,\n                        }\n                    };\n                }\n            }\n        }\n\n        return { value: value, surcharge: kDefaultSurcharge };\n    }\n\n    let result = get_surcharge_and_surge(category, /*recursive=*/true);\n\n    if (!is_number(result.value)) {\n        log.error('no surge value! default surcharge will be used');\n        return { value: value, surcharge: kDefaultSurcharge };\n    }\n\n    let surcharge_coeffs = Object.values(result.surcharge);\n\n    if (!surcharge_coeffs.some(is_number)) {\n        // no surcharge params at all - use default but keep value from table\n        result.surcharge = kDefaultSurcharge;\n    } else if (!surcharge_coeffs.every(is_number)) {\n        // incomplete surcharge params - considered ill formed - discard table\n        log.warning('inconsistent surcharge params! default surcharge will be used');\n        return { value: value, surcharge: kDefaultSurcharge };\n    }\n\n    return result;\n"
    },
    {
      "conditions": [],
      "in_bindings": [
        {
          "domain": "resource",
          "query": "zone.base_class"
        },
        {
          "domain": "resource",
          "query": "config.surge_coefficient_precision{precision}"
        },
        {
          "domain": "output",
          "query": "classes[base_class].surge.value"
        }
      ],
      "name": "round_base_class_coeffs",
      "optional": false,
      "out_bindings": [
        {
          "alias": "value",
          "query": "classes[base_class].surge.value"
        }
      ],
      "source_code": "\n    const factor = Math.pow(10, precision);\n    return {value: Math.round(value * factor) / factor};\n"
    }
  ],
  "state": "active"
}
