/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s): taxi/schemas/schemas/stq/test.yaml

#include <stq_clients/test.hpp>

#include <userver/formats/serialize/common_containers.hpp>

#include <codegen/impl/convert.hpp>
#include <codegen/impl/get_validation_length.hpp>
#include <codegen/impl/optional_convert.hpp>
#include <codegen/impl/parsers.hpp>
#include <cstring>
#include <unordered_set>
#include <userver/formats/common/meta.hpp>
#include <userver/formats/json/serialize_container.hpp>
#include <userver/formats/json/string_builder.hpp>
#include <userver/formats/parse/common_containers.hpp>
#include <userver/logging/log.hpp>
#include <userver/utils/assert.hpp>
#include <userver/utils/datetime.hpp>
#include <userver/utils/datetime/from_string_saturating.hpp>
#include <userver/utils/underlying_value.hpp>

namespace stq_clients::test {

stq_clients::test::Args Parse([[maybe_unused]] const formats::json::Value& elem,
                              formats::parse::To<stq_clients::test::Args>) {
  stq_clients::test::Args result;

  elem.CheckNotMissing();
  elem.CheckObjectOrNull();

  result.simple_string = elem["simple_string"].As<std::string>();
  result.array =
      [](const formats::json::Value& array) -> std::vector<std::string> {
    std::vector<std::string> result;
    array.CheckArrayOrNull();
    result.reserve(array.GetSize());
    for (const auto& item : array) {
      result.insert(result.end(), item.As<std::string>());
    }

    return result;
  }(elem["array"]);
  result.optional_number = elem["optional_number"].As<std::optional<double>>();
  result.object_field =
      elem["object_field"]
          .As<std::optional<::stq_clients::test_definitions::TestObject>>();

  return result;
}

formats::json::Value Serialize(
    [[maybe_unused]] const stq_clients::test::Args& value,
    ::formats::serialize::To<formats::json::Value>)
{
  formats::json::ValueBuilder builder(formats::json::Type::kObject);

  builder.EmplaceNocheck("simple_string", value.simple_string);
  builder.EmplaceNocheck("array", value.array);
  if (value.optional_number)
    builder.EmplaceNocheck("optional_number", *value.optional_number);
  if (value.object_field)
    builder.EmplaceNocheck("object_field", *value.object_field);
  return builder.ExtractValue();
}

void WriteToStream([[maybe_unused]] const stq_clients::test::Args& value,
                   formats::json::StringBuilder& sw,
                   [[maybe_unused]] bool hide_brackets,
                   [[maybe_unused]] const char* hide_field_name)
{
  std::optional<::formats::json::StringBuilder::ObjectGuard> guard;
  if (!hide_brackets) guard.emplace(sw);

  if (!hide_field_name || std::strcmp(hide_field_name, "simple_string"))
  {
    sw.Key("simple_string");

    WriteToStream(value.simple_string, sw);
  }
  if (!hide_field_name || std::strcmp(hide_field_name, "array"))
  {
    sw.Key("array");

    WriteToStream(value.array, sw);
  }
  if (!hide_field_name || std::strcmp(hide_field_name, "optional_number"))
  {
    if (value.optional_number)
    {
      sw.Key("optional_number");

      WriteToStream(*value.optional_number, sw);
    }
  }
  if (!hide_field_name || std::strcmp(hide_field_name, "object_field"))
  {
    if (value.object_field)
    {
      sw.Key("object_field");

      WriteToStream(*value.object_field, sw);
    }
  }
}

}
