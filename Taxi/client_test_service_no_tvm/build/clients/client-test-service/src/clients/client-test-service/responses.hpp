/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s):
// taxi/schemas/schemas/services/client-test-service/api/api-3.0.yaml,
// taxi/schemas/schemas/services/client-test-service/api/api.yaml

#pragma once

#include <string>

#include <variant>

#include <clients/client-test-service/definitions.hpp>
#include <clients/client-test-service/exception.hpp>
#include <clients/codegen/exception.hpp>

#include <array>
#include <boost/type_traits/has_equal_to.hpp>
#include <codegen/convert_to_json_optional.hpp>
#include <codegen/format.hpp>
#include <codegen/parsing_flags.hpp>
#include <string>
#include <userver/formats/json/inline.hpp>
#include <userver/formats/json/string_builder_fwd.hpp>
#include <userver/formats/json/value_builder.hpp>
#include <userver/logging/log_helper_fwd.hpp>

#include <codegen/parser/datetime_parser.hpp>
#include <codegen/parser/dummy_parser.hpp>  // TODO: for debug only
#include <codegen/parser/enum_parser.hpp>
#include <codegen/parser/extra_helper.hpp>
#include <codegen/parser/null_swallow.hpp>
#include <codegen/parser/nullable_helper.hpp>
#include <codegen/parser/parser_converter.hpp>
#include <codegen/parser/parser_dom.hpp>
#include <codegen/parser/parser_empty.hpp>
#include <codegen/parser/parser_non_null_ptr.hpp>
#include <codegen/parser/validator.hpp>
#include <codegen/parser/value_builder_helper.hpp>
#include <userver/formats/json/parser/parser.hpp>

#include <array>
#include <boost/type_traits/has_equal_to.hpp>
#include <codegen/convert_to_json_optional.hpp>
#include <codegen/format.hpp>
#include <codegen/parsing_flags.hpp>
#include <userver/formats/json/inline.hpp>
#include <userver/formats/json/string_builder_fwd.hpp>
#include <userver/formats/json/value_builder.hpp>
#include <userver/logging/log_helper_fwd.hpp>

namespace clients::client_test_service {

namespace v1_my_arg_smth::get {

/// @brief Base exception class for all client GET operations with URL
/// '/v1/my-arg/smth'
class Exception: public clients::client_test_service::Exception {
 public:
  const char* what() const noexcept override;

  std::string_view HandleInfo() const noexcept final;

  static constexpr char kHandleInfo[] = "GET /v1/my-arg/smth";
};

/// @brief Timeout exception class for all client GET operations with URL
/// '/v1/my-arg/smth'
class TimeoutException: public Exception,
                        public clients::client_test_service::TimeoutException {
 public:
  using Exception::Exception;
  ~TimeoutException();
};

/// @brief Error response with HTTP status code for all client GET operations
/// with URL '/v1/my-arg/smth'
class ExceptionWithStatusCode
    : public Exception,
      public clients::client_test_service::ExceptionWithStatusCode {
 public:
  using clients::client_test_service::ExceptionWithStatusCode::
      ExceptionWithStatusCode;
  ~ExceptionWithStatusCode();
};

/// In place schema object for success response
struct Response200 {
  ::std::string ok;
};

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response200& v);

template <typename U>
std::enable_if_t<std::is_same<U, Response200>::value, bool> operator==(
    const U& lhs, const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(
      boost::has_equal_to<decltype(lhs.ok)>::value,
      "No operator==() defined for field 'ok' of type '::std::string'");

  return std::tie(lhs.ok) == std::tie(rhs.ok);
}

template <typename U>
std::enable_if_t<std::is_same<U, Response200>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

Response200 Parse(const formats::json::Value& elem,
                  formats::parse::To<Response200>);

namespace parser {
class PResponse200 final
    : public ::formats::json::parser::TypedParser<
          clients::client_test_service::v1_my_arg_smth::get::Response200> {
 public:
  PResponse200();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  clients::client_test_service::v1_my_arg_smth::get::Response200 result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  // ok
  // .cpp_type: std::string
  // .optional_subtype: None
  // cpp_type: std::string
  ::formats::json::parser::StringParser f_ok_;

  ::formats::json::parser::SubscriberSink<std::string> sink_ok_{result_.ok};

  bool s_ok_{false};

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

::formats::json::Value Serialize(
    const Response200& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const Response200& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

using Response = Response200;

}

namespace v1_my_arg_smth::post {

/// @brief Base exception class for all client POST operations with URL
/// '/v1/my-arg/smth'
class Exception: public clients::client_test_service::Exception {
 public:
  const char* what() const noexcept override;

  std::string_view HandleInfo() const noexcept final;

  static constexpr char kHandleInfo[] = "POST /v1/my-arg/smth";
};

/// @brief Timeout exception class for all client POST operations with URL
/// '/v1/my-arg/smth'
class TimeoutException: public Exception,
                        public clients::client_test_service::TimeoutException {
 public:
  using Exception::Exception;
  ~TimeoutException();
};

/// @brief Error response with HTTP status code for all client POST operations
/// with URL '/v1/my-arg/smth'
class ExceptionWithStatusCode
    : public Exception,
      public clients::client_test_service::ExceptionWithStatusCode {
 public:
  using clients::client_test_service::ExceptionWithStatusCode::
      ExceptionWithStatusCode;
  ~ExceptionWithStatusCode();
};

/// In place schema object for success response
struct Response200 {};

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response200& v);

template <typename U>
std::enable_if_t<std::is_same<U, Response200>::value, bool> operator==(const U&,
                                                                       const U&)
{
  return true;
}

template <typename U>
std::enable_if_t<std::is_same<U, Response200>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

Response200 Parse(const formats::json::Value& elem,
                  formats::parse::To<Response200>);

namespace parser {
class PResponse200 final
    : public ::formats::json::parser::TypedParser<
          clients::client_test_service::v1_my_arg_smth::post::Response200> {
 public:
  PResponse200();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  clients::client_test_service::v1_my_arg_smth::post::Response200 result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

::formats::json::Value Serialize(
    const Response200& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const Response200& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

/// Response without contents
struct Response201 {
  std::string ToString() const { return {}; }
};

inline ::formats::json::Value Serialize(
    const Response201&, ::formats::serialize::To<::formats::json::Value>) {
  return {};
}

/// Response without contents
struct Response404: public ExceptionWithStatusCode {
  Response404()
      : ExceptionWithStatusCode(404)
  {}
  std::string ToString() const { return {}; }
};

inline ::formats::json::Value Serialize(
    const Response404&, ::formats::serialize::To<::formats::json::Value>) {
  return {};
}

using Response = std::variant<Response200, Response201>;

}

namespace v2_smth::get {

/// @brief Base exception class for all client GET operations with URL
/// '/v2/smth'
class Exception: public clients::client_test_service::Exception {
 public:
  const char* what() const noexcept override;

  std::string_view HandleInfo() const noexcept final;

  static constexpr char kHandleInfo[] = "GET /v2/smth";
};

/// @brief Timeout exception class for all client GET operations with URL
/// '/v2/smth'
class TimeoutException: public Exception,
                        public clients::client_test_service::TimeoutException {
 public:
  using Exception::Exception;
  ~TimeoutException();
};

/// @brief Error response with HTTP status code for all client GET operations
/// with URL '/v2/smth'
class ExceptionWithStatusCode
    : public Exception,
      public clients::client_test_service::ExceptionWithStatusCode {
 public:
  using clients::client_test_service::ExceptionWithStatusCode::
      ExceptionWithStatusCode;
  ~ExceptionWithStatusCode();
};

/// In place schema object for success response
struct Response200 {};

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response200& v);

template <typename U>
std::enable_if_t<std::is_same<U, Response200>::value, bool> operator==(const U&,
                                                                       const U&)
{
  return true;
}

template <typename U>
std::enable_if_t<std::is_same<U, Response200>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

Response200 Parse(const formats::json::Value& elem,
                  formats::parse::To<Response200>);

namespace parser {
class PResponse200 final
    : public ::formats::json::parser::TypedParser<
          clients::client_test_service::v2_smth::get::Response200> {
 public:
  PResponse200();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  clients::client_test_service::v2_smth::get::Response200 result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

::formats::json::Value Serialize(
    const Response200& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const Response200& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

using Response = Response200;

}

namespace v2_smth::post {

/// @brief Base exception class for all client POST operations with URL
/// '/v2/smth'
class Exception: public clients::client_test_service::Exception {
 public:
  const char* what() const noexcept override;

  std::string_view HandleInfo() const noexcept final;

  static constexpr char kHandleInfo[] = "POST /v2/smth";
};

/// @brief Timeout exception class for all client POST operations with URL
/// '/v2/smth'
class TimeoutException: public Exception,
                        public clients::client_test_service::TimeoutException {
 public:
  using Exception::Exception;
  ~TimeoutException();
};

/// @brief Error response with HTTP status code for all client POST operations
/// with URL '/v2/smth'
class ExceptionWithStatusCode
    : public Exception,
      public clients::client_test_service::ExceptionWithStatusCode {
 public:
  using clients::client_test_service::ExceptionWithStatusCode::
      ExceptionWithStatusCode;
  ~ExceptionWithStatusCode();
};

/// In place schema object for success response
struct Response200 {};

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response200& v);

template <typename U>
std::enable_if_t<std::is_same<U, Response200>::value, bool> operator==(const U&,
                                                                       const U&)
{
  return true;
}

template <typename U>
std::enable_if_t<std::is_same<U, Response200>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

Response200 Parse(const formats::json::Value& elem,
                  formats::parse::To<Response200>);

namespace parser {
class PResponse200 final
    : public ::formats::json::parser::TypedParser<
          clients::client_test_service::v2_smth::post::Response200> {
 public:
  PResponse200();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  clients::client_test_service::v2_smth::post::Response200 result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

::formats::json::Value Serialize(
    const Response200& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const Response200& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

using Response = Response200;

}

namespace v3_smth::get {

/// @brief Base exception class for all client GET operations with URL
/// '/v3/smth'
class Exception: public clients::client_test_service::Exception {
 public:
  const char* what() const noexcept override;

  std::string_view HandleInfo() const noexcept final;

  static constexpr char kHandleInfo[] = "GET /v3/smth";
};

/// @brief Timeout exception class for all client GET operations with URL
/// '/v3/smth'
class TimeoutException: public Exception,
                        public clients::client_test_service::TimeoutException {
 public:
  using Exception::Exception;
  ~TimeoutException();
};

/// @brief Error response with HTTP status code for all client GET operations
/// with URL '/v3/smth'
class ExceptionWithStatusCode
    : public Exception,
      public clients::client_test_service::ExceptionWithStatusCode {
 public:
  using clients::client_test_service::ExceptionWithStatusCode::
      ExceptionWithStatusCode;
  ~ExceptionWithStatusCode();
};

/// In place schema object for success response
struct Response200 {};

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response200& v);

template <typename U>
std::enable_if_t<std::is_same<U, Response200>::value, bool> operator==(const U&,
                                                                       const U&)
{
  return true;
}

template <typename U>
std::enable_if_t<std::is_same<U, Response200>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

Response200 Parse(const formats::json::Value& elem,
                  formats::parse::To<Response200>);

namespace parser {
class PResponse200 final
    : public ::formats::json::parser::TypedParser<
          clients::client_test_service::v3_smth::get::Response200> {
 public:
  PResponse200();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  clients::client_test_service::v3_smth::get::Response200 result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

::formats::json::Value Serialize(
    const Response200& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const Response200& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

using Response = Response200;

}

namespace v3_smth::post {

/// @brief Base exception class for all client POST operations with URL
/// '/v3/smth'
class Exception: public clients::client_test_service::Exception {
 public:
  const char* what() const noexcept override;

  std::string_view HandleInfo() const noexcept final;

  static constexpr char kHandleInfo[] = "POST /v3/smth";
};

/// @brief Timeout exception class for all client POST operations with URL
/// '/v3/smth'
class TimeoutException: public Exception,
                        public clients::client_test_service::TimeoutException {
 public:
  using Exception::Exception;
  ~TimeoutException();
};

/// @brief Error response with HTTP status code for all client POST operations
/// with URL '/v3/smth'
class ExceptionWithStatusCode
    : public Exception,
      public clients::client_test_service::ExceptionWithStatusCode {
 public:
  using clients::client_test_service::ExceptionWithStatusCode::
      ExceptionWithStatusCode;
  ~ExceptionWithStatusCode();
};

/// In place schema object for success response
struct Response200 {};

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response200& v);

template <typename U>
std::enable_if_t<std::is_same<U, Response200>::value, bool> operator==(const U&,
                                                                       const U&)
{
  return true;
}

template <typename U>
std::enable_if_t<std::is_same<U, Response200>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

Response200 Parse(const formats::json::Value& elem,
                  formats::parse::To<Response200>);

namespace parser {
class PResponse200 final
    : public ::formats::json::parser::TypedParser<
          clients::client_test_service::v3_smth::post::Response200> {
 public:
  PResponse200();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  clients::client_test_service::v3_smth::post::Response200 result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

::formats::json::Value Serialize(
    const Response200& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const Response200& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

using Response = Response200;

}

namespace root_::get {

/// @brief Base exception class for all client GET operations with URL '/'
class Exception: public clients::client_test_service::Exception {
 public:
  const char* what() const noexcept override;

  std::string_view HandleInfo() const noexcept final;

  static constexpr char kHandleInfo[] = "GET /";
};

/// @brief Timeout exception class for all client GET operations with URL '/'
class TimeoutException: public Exception,
                        public clients::client_test_service::TimeoutException {
 public:
  using Exception::Exception;
  ~TimeoutException();
};

/// @brief Error response with HTTP status code for all client GET operations
/// with URL '/'
class ExceptionWithStatusCode
    : public Exception,
      public clients::client_test_service::ExceptionWithStatusCode {
 public:
  using clients::client_test_service::ExceptionWithStatusCode::
      ExceptionWithStatusCode;
  ~ExceptionWithStatusCode();
};

/// In place schema object for success response
struct Response200 {
  ::std::string ok;
};

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response200& v);

template <typename U>
std::enable_if_t<std::is_same<U, Response200>::value, bool> operator==(
    const U& lhs, const U& rhs)
{
  // template magic identifies whether all struct fields are comparable
  static_assert(
      boost::has_equal_to<decltype(lhs.ok)>::value,
      "No operator==() defined for field 'ok' of type '::std::string'");

  return std::tie(lhs.ok) == std::tie(rhs.ok);
}

template <typename U>
std::enable_if_t<std::is_same<U, Response200>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

Response200 Parse(const formats::json::Value& elem,
                  formats::parse::To<Response200>);

namespace parser {
class PResponse200 final
    : public ::formats::json::parser::TypedParser<
          clients::client_test_service::root_::get::Response200> {
 public:
  PResponse200();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  clients::client_test_service::root_::get::Response200 result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  // ok
  // .cpp_type: std::string
  // .optional_subtype: None
  // cpp_type: std::string
  ::formats::json::parser::StringParser f_ok_;

  ::formats::json::parser::SubscriberSink<std::string> sink_ok_{result_.ok};

  bool s_ok_{false};

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

::formats::json::Value Serialize(
    const Response200& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const Response200& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

using Response = Response200;

}

namespace root_::post {

/// @brief Base exception class for all client POST operations with URL '/'
class Exception: public clients::client_test_service::Exception {
 public:
  const char* what() const noexcept override;

  std::string_view HandleInfo() const noexcept final;

  static constexpr char kHandleInfo[] = "POST /";
};

/// @brief Timeout exception class for all client POST operations with URL '/'
class TimeoutException: public Exception,
                        public clients::client_test_service::TimeoutException {
 public:
  using Exception::Exception;
  ~TimeoutException();
};

/// @brief Error response with HTTP status code for all client POST operations
/// with URL '/'
class ExceptionWithStatusCode
    : public Exception,
      public clients::client_test_service::ExceptionWithStatusCode {
 public:
  using clients::client_test_service::ExceptionWithStatusCode::
      ExceptionWithStatusCode;
  ~ExceptionWithStatusCode();
};

/// In place schema object for success response
struct Response200 {};

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response200& v);

template <typename U>
std::enable_if_t<std::is_same<U, Response200>::value, bool> operator==(const U&,
                                                                       const U&)
{
  return true;
}

template <typename U>
std::enable_if_t<std::is_same<U, Response200>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

Response200 Parse(const formats::json::Value& elem,
                  formats::parse::To<Response200>);

namespace parser {
class PResponse200 final
    : public ::formats::json::parser::TypedParser<
          clients::client_test_service::root_::post::Response200> {
 public:
  PResponse200();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  clients::client_test_service::root_::post::Response200 result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

::formats::json::Value Serialize(
    const Response200& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const Response200& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

/// In place schema object for success response
struct Response201 {};

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response201& v);

template <typename U>
std::enable_if_t<std::is_same<U, Response201>::value, bool> operator==(const U&,
                                                                       const U&)
{
  return true;
}

template <typename U>
std::enable_if_t<std::is_same<U, Response201>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

Response201 Parse(const formats::json::Value& elem,
                  formats::parse::To<Response201>);

namespace parser {
class PResponse201 final
    : public ::formats::json::parser::TypedParser<
          clients::client_test_service::root_::post::Response201> {
 public:
  PResponse201();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  clients::client_test_service::root_::post::Response201 result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

::formats::json::Value Serialize(
    const Response201& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const Response201& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

/// In place schema object for error response
struct Response404: public ExceptionWithStatusCode {
  Response404()
      : ExceptionWithStatusCode(404)
  {}
};

logging::LogHelper& operator<<(logging::LogHelper& lh, const Response404& v);

template <typename U>
std::enable_if_t<std::is_same<U, Response404>::value, bool> operator==(const U&,
                                                                       const U&)
{
  return true;
}

template <typename U>
std::enable_if_t<std::is_same<U, Response404>::value, bool> operator!=(
    const U& lhs, const U& rhs)
{
  return !(lhs == rhs);
}

Response404 Parse(const formats::json::Value& elem,
                  formats::parse::To<Response404>);

namespace parser {
class PResponse404 final
    : public ::formats::json::parser::TypedParser<
          clients::client_test_service::root_::post::Response404> {
 public:
  PResponse404();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  clients::client_test_service::root_::post::Response404 result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

::formats::json::Value Serialize(
    const Response404& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const Response404& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

using Response = std::variant<Response200, Response201>;

}

}
