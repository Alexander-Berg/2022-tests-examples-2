/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */

// This file was generated from file(s):
// taxi/schemas/schemas/services/client-test-service/api/api-3.0.yaml,
// taxi/schemas/schemas/services/client-test-service/api/api.yaml

#pragma once

#include <userver/clients/http/response.hpp>  // for ::clients::http::Headers
#include <userver/http/url.hpp>               // for ::http::Args

#include <optional>
#include <string>
#include <vector>

#include <array>
#include <boost/type_traits/has_equal_to.hpp>
#include <codegen/convert_to_json_optional.hpp>
#include <codegen/format.hpp>
#include <codegen/parsing_flags.hpp>
#include <userver/formats/json/inline.hpp>
#include <userver/formats/json/string_builder_fwd.hpp>
#include <userver/formats/json/value_builder.hpp>
#include <userver/logging/log_helper_fwd.hpp>

#include <codegen/parser/datetime_parser.hpp>
#include <codegen/parser/dummy_parser.hpp>  // TODO: for debug only
#include <codegen/parser/enum_parser.hpp>
#include <codegen/parser/extra_helper.hpp>
#include <codegen/parser/null_swallow.hpp>
#include <codegen/parser/nullable_helper.hpp>
#include <codegen/parser/parser_converter.hpp>
#include <codegen/parser/parser_dom.hpp>
#include <codegen/parser/parser_empty.hpp>
#include <codegen/parser/parser_non_null_ptr.hpp>
#include <codegen/parser/validator.hpp>
#include <codegen/parser/value_builder_helper.hpp>
#include <userver/formats/json/parser/parser.hpp>

#include <clients/client-test-service/definitions.hpp>

namespace clients::client_test_service {

namespace v1_my_arg_smth::get {

struct Request {
  std::optional<::std::string> x_test_header;
  std::string my_arg;

  ::clients::http::Headers GetHeaders() const;

  ::http::Args GetQuery() const;

  std::string GetPath() const;
};

}

namespace v1_my_arg_smth::post {

struct Body {
  ::std::optional<::std::vector<std::string>> array{};
  int id{};
};

::formats::json::Value Serialize(
    const Body& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const Body& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

Body Parse(const formats::json::Value& elem, formats::parse::To<Body>);

namespace parser {
class PBody final
    : public ::formats::json::parser::TypedParser<
          clients::client_test_service::v1_my_arg_smth::post::Body> {
 public:
  PBody();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  clients::client_test_service::v1_my_arg_smth::post::Body result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  // array
  /* validation: ValidationData(minimum=None, maximum=None,
   * exclusiveMinimum=False, exclusiveMaximum=False, minItems=1, maxItems=None,
   * minLength=None, maxLength=None, pattern=None)
   */
  // .cpp_type: std::string
  // .optional_subtype: None
  // cpp_type: std::string
  ::formats::json::parser::StringParser f_v_array_i_;

  ::formats::json::parser::ArrayParser<std::string, decltype(f_v_array_i_),
                                       std::vector<std::string>>
      f_v_array_{f_v_array_i_};

  struct f_v_val_array_ {
    void Validate(const std::vector<std::string>& value) {
      if (!(1 <= value.size())) {
        auto msg = "incorrect size, must be 1 (limit) <= " +
                   std::to_string(value.size()) + " (value)";
        throw std::runtime_error(msg);
      }
    }
    void Validate(std::optional<::std::vector<std::string>> value)
    {
      if (!value) return;
      Validate(*value);
    }
  };
  ::codegen::parser::Validator<decltype(f_v_array_), f_v_val_array_> f_array_{
      f_v_array_};
  ::codegen::parser::NullableHelper<::std::optional<::std::vector<std::string>>,
                                    decltype(f_array_)>
      null_array_{f_array_};
  ::formats::json::parser::SubscriberSinkOptional<std::vector<std::string>>
      sink_array_{result_.array};

  bool s_array_{false};

  // id
  /* validation: ValidationData(minimum=0, maximum=None, exclusiveMinimum=False,
   * exclusiveMaximum=False, minItems=None, maxItems=None, minLength=None,
   * maxLength=None, pattern=None)
   */
  // .cpp_type: int
  // .optional_subtype: None
  // cpp_type: int
  ::formats::json::parser::IntegralParser<int> f_v_id_;

  struct f_v_val_id_ {
    void Validate(const int& value) {
      if (!(0 <= value)) {
        auto msg =
            "out of bounds, must be 0 (limit) <= " + std::to_string(value) +
            " (value)";
        throw std::runtime_error(msg);
      }
    }
  };
  ::codegen::parser::Validator<decltype(f_v_id_), f_v_val_id_> f_id_{f_v_id_};
  ::formats::json::parser::SubscriberSink<int> sink_id_{result_.id};

  bool s_id_{false};

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

struct Request {
  std::optional<::std::string> x_test_header;
  std::string my_arg;
  clients::client_test_service::v1_my_arg_smth::post::Body body;

  ::clients::http::Headers GetHeaders() const;

  ::http::Args GetQuery() const;

  std::string GetBody() const;

  std::string GetPath() const;
};

}

namespace v2_smth::get {

struct Request {
  ::clients::http::Headers GetHeaders() const;

  ::http::Args GetQuery() const;
};

}

namespace v2_smth::post {

struct Body {};

::formats::json::Value Serialize(
    const Body& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const Body& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

Body Parse(const formats::json::Value& elem, formats::parse::To<Body>);

namespace parser {
class PBody final: public ::formats::json::parser::TypedParser<
                       clients::client_test_service::v2_smth::post::Body> {
 public:
  PBody();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  clients::client_test_service::v2_smth::post::Body result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

struct Request {
  clients::client_test_service::v2_smth::post::Body body;

  ::clients::http::Headers GetHeaders() const;

  ::http::Args GetQuery() const;

  std::string GetBody() const;
};

}

namespace v3_smth::get {

struct Request {
  ::clients::http::Headers GetHeaders() const;

  ::http::Args GetQuery() const;
};

}

namespace v3_smth::post {

struct Body {};

::formats::json::Value Serialize(
    const Body& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const Body& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

Body Parse(const formats::json::Value& elem, formats::parse::To<Body>);

namespace parser {
class PBody final: public ::formats::json::parser::TypedParser<
                       clients::client_test_service::v3_smth::post::Body> {
 public:
  PBody();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  clients::client_test_service::v3_smth::post::Body result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

struct Request {
  clients::client_test_service::v3_smth::post::Body body;

  ::clients::http::Headers GetHeaders() const;

  ::http::Args GetQuery() const;

  std::string GetBody() const;
};

}

namespace root_::get {

struct Request {
  std::optional<::std::string> secret;
  std::optional<::std::string> x_test_header;

  ::clients::http::Headers GetHeaders() const;

  ::http::Args GetQuery() const;
};

}

namespace root_::post {

struct Body {
  ::std::optional<::std::vector<std::string>> array{};
  int id{};
};

::formats::json::Value Serialize(
    const Body& value, ::formats::serialize::To<::formats::json::Value>);

void WriteToStream(const Body& value, formats::json::StringBuilder& sw,
                   bool hide_brackets = false,
                   const char* hide_field_name = nullptr);

Body Parse(const formats::json::Value& elem, formats::parse::To<Body>);

namespace parser {
class PBody final: public ::formats::json::parser::TypedParser<
                       clients::client_test_service::root_::post::Body> {
 public:
  PBody();

  void Reset() override;

  void StartObject() override;

  void Key(std::string_view key) override;

  void EndObject() override;

 private:
  std::string Expected() const override;

  std::string GetPathItem() const override;

  clients::client_test_service::root_::post::Body result_;
  std::string key_;

  template <class To>
  struct ParserLocalConverterTrait {
    template <class From>
    static To Convert(From&& from);
  };

  template <class To>
  struct ParserLocalDomToType {
    static To Convert(::formats::json::Value&& value);
  };

  // array
  /* validation: ValidationData(minimum=None, maximum=None,
   * exclusiveMinimum=False, exclusiveMaximum=False, minItems=1, maxItems=None,
   * minLength=None, maxLength=None, pattern=None)
   */
  // .cpp_type: std::string
  // .optional_subtype: None
  // cpp_type: std::string
  ::formats::json::parser::StringParser f_v_array_i_;

  ::formats::json::parser::ArrayParser<std::string, decltype(f_v_array_i_),
                                       std::vector<std::string>>
      f_v_array_{f_v_array_i_};

  struct f_v_val_array_ {
    void Validate(const std::vector<std::string>& value) {
      if (!(1 <= value.size())) {
        auto msg = "incorrect size, must be 1 (limit) <= " +
                   std::to_string(value.size()) + " (value)";
        throw std::runtime_error(msg);
      }
    }
    void Validate(std::optional<::std::vector<std::string>> value)
    {
      if (!value) return;
      Validate(*value);
    }
  };
  ::codegen::parser::Validator<decltype(f_v_array_), f_v_val_array_> f_array_{
      f_v_array_};
  ::codegen::parser::NullableHelper<::std::optional<::std::vector<std::string>>,
                                    decltype(f_array_)>
      null_array_{f_array_};
  ::formats::json::parser::SubscriberSinkOptional<std::vector<std::string>>
      sink_array_{result_.array};

  bool s_array_{false};

  // id
  /* validation: ValidationData(minimum=0, maximum=None, exclusiveMinimum=False,
   * exclusiveMaximum=False, minItems=None, maxItems=None, minLength=None,
   * maxLength=None, pattern=None)
   */
  // .cpp_type: int
  // .optional_subtype: None
  // cpp_type: int
  ::formats::json::parser::IntegralParser<int> f_v_id_;

  struct f_v_val_id_ {
    void Validate(const int& value) {
      if (!(0 <= value)) {
        auto msg =
            "out of bounds, must be 0 (limit) <= " + std::to_string(value) +
            " (value)";
        throw std::runtime_error(msg);
      }
    }
  };
  ::codegen::parser::Validator<decltype(f_v_id_), f_v_val_id_> f_id_{f_v_id_};
  ::formats::json::parser::SubscriberSink<int> sink_id_{result_.id};

  bool s_id_{false};

  ::codegen::parser::EmptyParser ff_empty_;

  enum class State {
    kStart,
    kInside,
  };
  State state_;
};

}  // namespace parser

struct Request {
  std::optional<::std::string> x_test_header;
  clients::client_test_service::root_::post::Body body;

  ::clients::http::Headers GetHeaders() const;

  ::http::Args GetQuery() const;

  std::string GetBody() const;
};

}

}  // namespace clients::client_test_service
